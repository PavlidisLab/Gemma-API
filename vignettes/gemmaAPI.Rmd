---
title: "Gemma API"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Gemma API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# Don't build this whole thing if it's just for a test. Too long running/taxing on Gemma
# if(Sys.getenv('RMD_BUILD') != 1)
#   knitr::knit_exit()

# Prevent certificate issues for GitHub actions
options(gemma.SSL = FALSE)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE}
library(gemmaAPI)
library(dplyr)
library(data.table)
library(memoise)
library(microbenchmark)
```

# Getting started

The Gemma API wrapper is very straightforward to use and contains a function for each entry in the REST API docs, [here](https://gemma.msl.ubc.ca/resources/restapidocs/). We suggest you make some example queries on the interactive API docs to get a sense of the endpoints and their inputs and outputs.

In this example, we want to find the dataset with the highest [Gemma Quality Score](https://pavlidislab.github.io/Gemma/geeq.html) that is associated with bipolar disorder, and we are only interested in human data. To do this, we can use the `searchDatasets()` endpoint:

```{r search}
searchDatasets('bipolar') %>% 
  filter(taxon.Name == 'human') %>% 
  arrange(desc(geeq.qScore)) %>%
  select(ee.ShortName)
```

There are 60 datasets associated with bipolar disorder in Gemma. The dataset with 
the highest quality score is [GSE35974](https://gemma.msl.ubc.ca/expressionExperiment/showExpressionExperiment.html?id=5939). 
Now that we have the ID for our experiment, we fetch the data associated with it.

To get the basic information of a dataset, we use the `getDatasets()` endpoint.

```{r dataset}
dataset <- getDatasets('GSE35974')
colnames(dataset)
dataset$ee.Description
```

To access the actual expression data, you can use `getBioconductor()`. It is a high-level wrapper that combines various 
endpoints to return an annotated SummarizedExperiment or ExpressionSet of the queried dataset that is compatible with other Bioconductor packages. 
Both classes are very similar, SummarizedExperiments are newer and more suitable for RNA-Seq data. They include the expression matrix along with
the experimental design, and ensure the sample names match between both.

Check the Summarized  Experiment [vignette](https://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html) or the ExpressionSet [vignette](https://bioconductor.org/packages/release/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf) for more details.

```{r bioconductor}
getBioconductor('ExpressionSet', 'GSE35974')
```

Many endpoints also allow you to query multiple objects at the same time, for example:

```{r double-query}
glimpse(getDatasets(datasets = c('GSE35974', 'GSE12649')))
```

You'll be able to tell either from the function documentation or simply because the the parameter name is plural (ie. `datasets`, `platforms`).

Some API endpoints only support a single identifier.

```{r error, error = TRUE}
getDatasetAnnotations(c('GSE35974', 'GSE12649'))
```

In these cases, you will have to loop over all the identifiers you wish to query and send separate requests.

```{r loop}
lapply(c('GSE35974', 'GSE12649'), function(dataset) {
  getDatasetAnnotations(dataset)[, ee.ShortName := dataset]
}) %>% rbindlist %>% glimpse
```

For large requests, this is often insufficient and instead, we recommend using asynchronous requests, which are explained below.

## Memoised results

A different way to "speed up" requests (in a way) is to remember past results so future queries can proceed virtually instantly. This is enabled through the [{memoise}](https://github.com/r-lib/memoise) package. To enable memoisation, simply set `memoised = T`.

```{r meamoised}
knitr::kable(summary(microbenchmark(getDatasetData('GSE35974', memoised = TRUE), times = 1), unit = 'ms'))
knitr::kable(summary(microbenchmark(getDatasetData('GSE35974', memoised = TRUE), times = 1), unit = 'ms'))
```

If you're done with your fetching and want to ensure no space is being used for cached results, or if you just want to ensure you're getting up-to-date data from Gemma, you can clear the cache using `forgetGemmaMemoised`.

```{r clear-cache}
forgetGemmaMemoised()
```

## Raw data

By default, Gemma API does some parsing on the raw API results to make it easier to work with inside of R. In the process, it drops some typically unused values. Sometimes, you may wish to to get access to everything, unadulterated by the Gemma API wrapper. This is enabled by setting `raw = T`. Instead of a `data.table`, you'll be served (typically) a list that represents the underlying JSON response.

## File outputs

Sometimes, you may wish to save results to a file for future inspection. You can do this simply by providing a filename to `file`. The extension for this file will be one of three options:

1.  `.json`, if you requested results with `raw = TRUE`
2.  `.csv` if the results have no nested `data.table`s
3.  `.rds` otherwise

You can also specify whether or not the new fetched results are allowed to overwrite an existing file by specifying the `overwrite` parameter.

To illustrate these...

```{r outputs}
glimpse(getDatasetSVD('GSE35974', raw = TRUE, file = 'SVD')) # raw = T, saves SVD.json
glimpse(getDatasetPlatforms('GSE35974', file = 'platforms')) # No nested data.tables, saves platforms.csv
glimpse(getDatasetSamples('GSE35974', file = 'samples')) # Some nested data.tables, saves samples.rds
```


```{r include=FALSE}
unlink('SVD.json')
unlink('platforms.csv')
unlink('samples.rds')
```

## Changing defaults

We've seen how to change `async = T`, `memoised = T`, `overwrite = T` and `raw = T`... It's possible that you want to always use the functions these ways without specifying the option every time. You can do this by simply changing the default, which is visible in the function definition. For example, if you want Gemma API to memoise results by default, you can use:

```{r defaults}
options(gemma.memoise = TRUE)
```

## Authentication

If you have an account at [Gemma](https://gemma.msl.ubc.ca) and want to access data that is private, you can login using `setGemmaUser("USERNAME", "PASSWORD")`. These will be passed on to every API request you make until you log out (by calling `setGemmaUser()`).
