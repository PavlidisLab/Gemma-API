#' Create a new AlternateName
#'
#' @description
#' AlternateName Class
#'
#' @docType class
#' @title AlternateName
#' @description AlternateName Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AlternateName <- R6::R6Class(
  "AlternateName",
  public = list(
    `name` = NULL,
    `id` = NULL,
    #' Initialize a new AlternateName class.
    #'
    #' @description
    #' Initialize a new AlternateName class.
    #'
    #' @param name name
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `id` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AlternateName in JSON format
    #' @keywords internal
    toJSON = function() {
      AlternateNameObject <- list()
      if (!is.null(self$`name`)) {
        AlternateNameObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`id`)) {
        AlternateNameObject[["id"]] <-
          self$`id`
      }
      AlternateNameObject
    },
    #' Deserialize JSON string into an instance of AlternateName
    #'
    #' @description
    #' Deserialize JSON string into an instance of AlternateName
    #'
    #' @param input_json the JSON input
    #' @return the instance of AlternateName
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AlternateName in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AlternateName
    #'
    #' @description
    #' Deserialize JSON string into an instance of AlternateName
    #'
    #' @param input_json the JSON input
    #' @return the instance of AlternateName
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to AlternateName
    #'
    #' @description
    #' Validate JSON input with respect to AlternateName and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AlternateName
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AlternateName$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AlternateName$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AlternateName$lock()


#' Create a new Analysis
#'
#' @description
#' Analysis Class
#'
#' @docType class
#' @title Analysis
#' @description Analysis Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field protocol  \link{Protocol} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Analysis <- R6::R6Class(
  "Analysis",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `protocol` = NULL,
    #' Initialize a new Analysis class.
    #'
    #' @description
    #' Initialize a new Analysis class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param protocol protocol
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `protocol` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`protocol`)) {
        stopifnot(R6::is.R6(`protocol`))
        self$`protocol` <- `protocol`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Analysis in JSON format
    #' @keywords internal
    toJSON = function() {
      AnalysisObject <- list()
      if (!is.null(self$`name`)) {
        AnalysisObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        AnalysisObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        AnalysisObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`protocol`)) {
        AnalysisObject[["protocol"]] <-
          self$`protocol`$toJSON()
      }
      AnalysisObject
    },
    #' Deserialize JSON string into an instance of Analysis
    #'
    #' @description
    #' Deserialize JSON string into an instance of Analysis
    #'
    #' @param input_json the JSON input
    #' @return the instance of Analysis
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`protocol`)) {
        protocol_object <- Protocol$new()
        protocol_object$fromJSON(jsonlite::toJSON(this_object$protocol, auto_unbox = TRUE, digits = NA))
        self$`protocol` <- protocol_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Analysis in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`protocol`)) {
          sprintf(
          '"protocol":
          %s
          ',
          jsonlite::toJSON(self$`protocol`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Analysis
    #'
    #' @description
    #' Deserialize JSON string into an instance of Analysis
    #'
    #' @param input_json the JSON input
    #' @return the instance of Analysis
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`protocol` <- Protocol$new()$fromJSON(jsonlite::toJSON(this_object$protocol, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to Analysis
    #'
    #' @description
    #' Validate JSON input with respect to Analysis and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Analysis
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Analysis$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Analysis$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Analysis$lock()


#' Create a new AnnotationSearchResultValueObject
#'
#' @description
#' AnnotationSearchResultValueObject Class
#'
#' @docType class
#' @title AnnotationSearchResultValueObject
#' @description AnnotationSearchResultValueObject Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @field valueUri  character optional
#' @field category  character optional
#' @field categoryUri  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AnnotationSearchResultValueObject <- R6::R6Class(
  "AnnotationSearchResultValueObject",
  public = list(
    `value` = NULL,
    `valueUri` = NULL,
    `category` = NULL,
    `categoryUri` = NULL,
    #' Initialize a new AnnotationSearchResultValueObject class.
    #'
    #' @description
    #' Initialize a new AnnotationSearchResultValueObject class.
    #'
    #' @param value value
    #' @param valueUri valueUri
    #' @param category category
    #' @param categoryUri categoryUri
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, `valueUri` = NULL, `category` = NULL, `categoryUri` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
      if (!is.null(`valueUri`)) {
        stopifnot(is.character(`valueUri`), length(`valueUri`) == 1)
        self$`valueUri` <- `valueUri`
      }
      if (!is.null(`category`)) {
        stopifnot(is.character(`category`), length(`category`) == 1)
        self$`category` <- `category`
      }
      if (!is.null(`categoryUri`)) {
        stopifnot(is.character(`categoryUri`), length(`categoryUri`) == 1)
        self$`categoryUri` <- `categoryUri`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AnnotationSearchResultValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      AnnotationSearchResultValueObjectObject <- list()
      if (!is.null(self$`value`)) {
        AnnotationSearchResultValueObjectObject[["value"]] <-
          self$`value`
      }
      if (!is.null(self$`valueUri`)) {
        AnnotationSearchResultValueObjectObject[["valueUri"]] <-
          self$`valueUri`
      }
      if (!is.null(self$`category`)) {
        AnnotationSearchResultValueObjectObject[["category"]] <-
          self$`category`
      }
      if (!is.null(self$`categoryUri`)) {
        AnnotationSearchResultValueObjectObject[["categoryUri"]] <-
          self$`categoryUri`
      }
      AnnotationSearchResultValueObjectObject
    },
    #' Deserialize JSON string into an instance of AnnotationSearchResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of AnnotationSearchResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of AnnotationSearchResultValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      if (!is.null(this_object$`valueUri`)) {
        self$`valueUri` <- this_object$`valueUri`
      }
      if (!is.null(this_object$`category`)) {
        self$`category` <- this_object$`category`
      }
      if (!is.null(this_object$`categoryUri`)) {
        self$`categoryUri` <- this_object$`categoryUri`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AnnotationSearchResultValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        },
        if (!is.null(self$`valueUri`)) {
          sprintf(
          '"valueUri":
            "%s"
                    ',
          self$`valueUri`
          )
        },
        if (!is.null(self$`category`)) {
          sprintf(
          '"category":
            "%s"
                    ',
          self$`category`
          )
        },
        if (!is.null(self$`categoryUri`)) {
          sprintf(
          '"categoryUri":
            "%s"
                    ',
          self$`categoryUri`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AnnotationSearchResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of AnnotationSearchResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of AnnotationSearchResultValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self$`valueUri` <- this_object$`valueUri`
      self$`category` <- this_object$`category`
      self$`categoryUri` <- this_object$`categoryUri`
      self
    },
    #' Validate JSON input with respect to AnnotationSearchResultValueObject
    #'
    #' @description
    #' Validate JSON input with respect to AnnotationSearchResultValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AnnotationSearchResultValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AnnotationSearchResultValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AnnotationSearchResultValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AnnotationSearchResultValueObject$lock()


#' Create a new AnnotationValueObject
#'
#' @description
#' AnnotationValueObject Class
#'
#' @docType class
#' @title AnnotationValueObject
#' @description AnnotationValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field classUri  character optional
#' @field className  character optional
#' @field termUri  character optional
#' @field termName  character optional
#' @field parentName  character optional
#' @field parentDescription  character optional
#' @field parentLink  character optional
#' @field parentOfParentName  character optional
#' @field parentOfParentDescription  character optional
#' @field parentOfParentLink  character optional
#' @field description  character optional
#' @field evidenceCode  character optional
#' @field objectClass  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AnnotationValueObject <- R6::R6Class(
  "AnnotationValueObject",
  public = list(
    `id` = NULL,
    `classUri` = NULL,
    `className` = NULL,
    `termUri` = NULL,
    `termName` = NULL,
    `parentName` = NULL,
    `parentDescription` = NULL,
    `parentLink` = NULL,
    `parentOfParentName` = NULL,
    `parentOfParentDescription` = NULL,
    `parentOfParentLink` = NULL,
    `description` = NULL,
    `evidenceCode` = NULL,
    `objectClass` = NULL,
    #' Initialize a new AnnotationValueObject class.
    #'
    #' @description
    #' Initialize a new AnnotationValueObject class.
    #'
    #' @param id id
    #' @param classUri classUri
    #' @param className className
    #' @param termUri termUri
    #' @param termName termName
    #' @param parentName parentName
    #' @param parentDescription parentDescription
    #' @param parentLink parentLink
    #' @param parentOfParentName parentOfParentName
    #' @param parentOfParentDescription parentOfParentDescription
    #' @param parentOfParentLink parentOfParentLink
    #' @param description description
    #' @param evidenceCode evidenceCode
    #' @param objectClass objectClass
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `classUri` = NULL, `className` = NULL, `termUri` = NULL, `termName` = NULL, `parentName` = NULL, `parentDescription` = NULL, `parentLink` = NULL, `parentOfParentName` = NULL, `parentOfParentDescription` = NULL, `parentOfParentLink` = NULL, `description` = NULL, `evidenceCode` = NULL, `objectClass` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`classUri`)) {
        stopifnot(is.character(`classUri`), length(`classUri`) == 1)
        self$`classUri` <- `classUri`
      }
      if (!is.null(`className`)) {
        stopifnot(is.character(`className`), length(`className`) == 1)
        self$`className` <- `className`
      }
      if (!is.null(`termUri`)) {
        stopifnot(is.character(`termUri`), length(`termUri`) == 1)
        self$`termUri` <- `termUri`
      }
      if (!is.null(`termName`)) {
        stopifnot(is.character(`termName`), length(`termName`) == 1)
        self$`termName` <- `termName`
      }
      if (!is.null(`parentName`)) {
        stopifnot(is.character(`parentName`), length(`parentName`) == 1)
        self$`parentName` <- `parentName`
      }
      if (!is.null(`parentDescription`)) {
        stopifnot(is.character(`parentDescription`), length(`parentDescription`) == 1)
        self$`parentDescription` <- `parentDescription`
      }
      if (!is.null(`parentLink`)) {
        stopifnot(is.character(`parentLink`), length(`parentLink`) == 1)
        self$`parentLink` <- `parentLink`
      }
      if (!is.null(`parentOfParentName`)) {
        stopifnot(is.character(`parentOfParentName`), length(`parentOfParentName`) == 1)
        self$`parentOfParentName` <- `parentOfParentName`
      }
      if (!is.null(`parentOfParentDescription`)) {
        stopifnot(is.character(`parentOfParentDescription`), length(`parentOfParentDescription`) == 1)
        self$`parentOfParentDescription` <- `parentOfParentDescription`
      }
      if (!is.null(`parentOfParentLink`)) {
        stopifnot(is.character(`parentOfParentLink`), length(`parentOfParentLink`) == 1)
        self$`parentOfParentLink` <- `parentOfParentLink`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`evidenceCode`)) {
        stopifnot(is.character(`evidenceCode`), length(`evidenceCode`) == 1)
        self$`evidenceCode` <- `evidenceCode`
      }
      if (!is.null(`objectClass`)) {
        stopifnot(is.character(`objectClass`), length(`objectClass`) == 1)
        self$`objectClass` <- `objectClass`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AnnotationValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      AnnotationValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        AnnotationValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`classUri`)) {
        AnnotationValueObjectObject[["classUri"]] <-
          self$`classUri`
      }
      if (!is.null(self$`className`)) {
        AnnotationValueObjectObject[["className"]] <-
          self$`className`
      }
      if (!is.null(self$`termUri`)) {
        AnnotationValueObjectObject[["termUri"]] <-
          self$`termUri`
      }
      if (!is.null(self$`termName`)) {
        AnnotationValueObjectObject[["termName"]] <-
          self$`termName`
      }
      if (!is.null(self$`parentName`)) {
        AnnotationValueObjectObject[["parentName"]] <-
          self$`parentName`
      }
      if (!is.null(self$`parentDescription`)) {
        AnnotationValueObjectObject[["parentDescription"]] <-
          self$`parentDescription`
      }
      if (!is.null(self$`parentLink`)) {
        AnnotationValueObjectObject[["parentLink"]] <-
          self$`parentLink`
      }
      if (!is.null(self$`parentOfParentName`)) {
        AnnotationValueObjectObject[["parentOfParentName"]] <-
          self$`parentOfParentName`
      }
      if (!is.null(self$`parentOfParentDescription`)) {
        AnnotationValueObjectObject[["parentOfParentDescription"]] <-
          self$`parentOfParentDescription`
      }
      if (!is.null(self$`parentOfParentLink`)) {
        AnnotationValueObjectObject[["parentOfParentLink"]] <-
          self$`parentOfParentLink`
      }
      if (!is.null(self$`description`)) {
        AnnotationValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`evidenceCode`)) {
        AnnotationValueObjectObject[["evidenceCode"]] <-
          self$`evidenceCode`
      }
      if (!is.null(self$`objectClass`)) {
        AnnotationValueObjectObject[["objectClass"]] <-
          self$`objectClass`
      }
      AnnotationValueObjectObject
    },
    #' Deserialize JSON string into an instance of AnnotationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of AnnotationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of AnnotationValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`classUri`)) {
        self$`classUri` <- this_object$`classUri`
      }
      if (!is.null(this_object$`className`)) {
        self$`className` <- this_object$`className`
      }
      if (!is.null(this_object$`termUri`)) {
        self$`termUri` <- this_object$`termUri`
      }
      if (!is.null(this_object$`termName`)) {
        self$`termName` <- this_object$`termName`
      }
      if (!is.null(this_object$`parentName`)) {
        self$`parentName` <- this_object$`parentName`
      }
      if (!is.null(this_object$`parentDescription`)) {
        self$`parentDescription` <- this_object$`parentDescription`
      }
      if (!is.null(this_object$`parentLink`)) {
        self$`parentLink` <- this_object$`parentLink`
      }
      if (!is.null(this_object$`parentOfParentName`)) {
        self$`parentOfParentName` <- this_object$`parentOfParentName`
      }
      if (!is.null(this_object$`parentOfParentDescription`)) {
        self$`parentOfParentDescription` <- this_object$`parentOfParentDescription`
      }
      if (!is.null(this_object$`parentOfParentLink`)) {
        self$`parentOfParentLink` <- this_object$`parentOfParentLink`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`evidenceCode`)) {
        self$`evidenceCode` <- this_object$`evidenceCode`
      }
      if (!is.null(this_object$`objectClass`)) {
        self$`objectClass` <- this_object$`objectClass`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AnnotationValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`classUri`)) {
          sprintf(
          '"classUri":
            "%s"
                    ',
          self$`classUri`
          )
        },
        if (!is.null(self$`className`)) {
          sprintf(
          '"className":
            "%s"
                    ',
          self$`className`
          )
        },
        if (!is.null(self$`termUri`)) {
          sprintf(
          '"termUri":
            "%s"
                    ',
          self$`termUri`
          )
        },
        if (!is.null(self$`termName`)) {
          sprintf(
          '"termName":
            "%s"
                    ',
          self$`termName`
          )
        },
        if (!is.null(self$`parentName`)) {
          sprintf(
          '"parentName":
            "%s"
                    ',
          self$`parentName`
          )
        },
        if (!is.null(self$`parentDescription`)) {
          sprintf(
          '"parentDescription":
            "%s"
                    ',
          self$`parentDescription`
          )
        },
        if (!is.null(self$`parentLink`)) {
          sprintf(
          '"parentLink":
            "%s"
                    ',
          self$`parentLink`
          )
        },
        if (!is.null(self$`parentOfParentName`)) {
          sprintf(
          '"parentOfParentName":
            "%s"
                    ',
          self$`parentOfParentName`
          )
        },
        if (!is.null(self$`parentOfParentDescription`)) {
          sprintf(
          '"parentOfParentDescription":
            "%s"
                    ',
          self$`parentOfParentDescription`
          )
        },
        if (!is.null(self$`parentOfParentLink`)) {
          sprintf(
          '"parentOfParentLink":
            "%s"
                    ',
          self$`parentOfParentLink`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`evidenceCode`)) {
          sprintf(
          '"evidenceCode":
            "%s"
                    ',
          self$`evidenceCode`
          )
        },
        if (!is.null(self$`objectClass`)) {
          sprintf(
          '"objectClass":
            "%s"
                    ',
          self$`objectClass`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AnnotationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of AnnotationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of AnnotationValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`classUri` <- this_object$`classUri`
      self$`className` <- this_object$`className`
      self$`termUri` <- this_object$`termUri`
      self$`termName` <- this_object$`termName`
      self$`parentName` <- this_object$`parentName`
      self$`parentDescription` <- this_object$`parentDescription`
      self$`parentLink` <- this_object$`parentLink`
      self$`parentOfParentName` <- this_object$`parentOfParentName`
      self$`parentOfParentDescription` <- this_object$`parentOfParentDescription`
      self$`parentOfParentLink` <- this_object$`parentOfParentLink`
      self$`description` <- this_object$`description`
      self$`evidenceCode` <- this_object$`evidenceCode`
      self$`objectClass` <- this_object$`objectClass`
      self
    },
    #' Validate JSON input with respect to AnnotationValueObject
    #'
    #' @description
    #' Validate JSON input with respect to AnnotationValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AnnotationValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AnnotationValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AnnotationValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AnnotationValueObject$lock()


#' Gemma RESTful API
#'
#' This website documents the usage of the Gemma REST API(https://gemma.msl.ubc.ca/rest/v2/). Here you can find example script usage of the API, as well as graphical interface for each endpoint, with description of its parameters and the endpoint URL.  The documentation of the underlying java code can be found here(https://gemma.msl.ubc.ca/resources/apidocs/ubic/gemma/web/services/rest/package-summary.html). See the links section(https://gemma.msl.ubc.ca/resources/restapidocs/#footer) in the footer of this page for other relevant links.  Use of this webpage and Gemma web services, including the REST API, is subject to these terms and conditions(https://pavlidislab.github.io/Gemma/terms.html). Please read these in full before continuing to use this webpage or any other part of the Gemma system. 
#'
#' The version of the OpenAPI document: 2.4.1
#' Contact: pavlab-support@msl.ubc.ca
#' Generated by: https://openapi-generator.tech
#'
#' ApiClient Class
#'
#' Generic API client for OpenAPI client library builds.
#' OpenAPI generic API client. This client handles the client-
#' server communication, and is invariant across implementations. Specifics of
#' the methods and models for each application are generated from the OpenAPI Generator
#' templates.
#'
#' NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
#' Ref: https://openapi-generator.tech
#' Do not edit the class manually.
#'
#' @docType class
#' @title ApiClient
#' @description ApiClient Class
#' @format An \code{R6Class} generator object
#' @field base_path Base url
#' @field user_agent Default user agent
#' @field default_headers Default headers
#' @field username Username for HTTP basic authentication
#' @field password Password for HTTP basic authentication
#' @field api_keys API keys
#' @field bearer_token Bearer token
#' @field timeout Default timeout in seconds
#' @field retry_status_codes vector of status codes to retry
#' @field max_retry_attempts maximum number of retries for the status codes
#' @importFrom httr add_headers accept timeout content
#' @keywords internal
ApiClient  <- R6::R6Class(
  "ApiClient",
  public = list(
    # base path of all requests
    base_path = "/rest/v2",
    # user agent in the HTTP request
    user_agent = "OpenAPI-Generator/1.0.0/r",
    # default headers in the HTTP request
    default_headers = NULL,
    # username (HTTP basic authentication)
    username = NULL,
    # password (HTTP basic authentication)
    password = NULL,
    # API keys
    api_keys = NULL,
    # Bearer token
    bearer_token = NULL,
    # Time Out (seconds)
    timeout = NULL,
    # Vector of status codes to retry
    retry_status_codes = NULL,
    # Maximum number of retry attempts for the retry status codes
    max_retry_attempts = NULL,
    #' Initialize a new ApiClient.
    #'
    #' @description
    #' Initialize a new ApiClient.
    #'
    #' @param base_path Base path.
    #' @param user_agent User agent.
    #' @param default_headers Default headers.
    #' @param username User name.
    #' @param password Password.
    #' @param api_keys API keys.
    #' @param access_token Access token.
    #' @param bearer_token Bearer token.
    #' @param timeout Timeout.
    #' @param retry_status_codes Status codes for retry.
    #' @param max_retry_attempts Maxmium number of retry.
    #' @keywords internal
    initialize = function(base_path = NULL, user_agent = NULL,
                          default_headers = NULL,
                          username = NULL, password = NULL, api_keys = NULL,
                          access_token = NULL, bearer_token = NULL, timeout = NULL,
                          retry_status_codes = NULL, max_retry_attempts = NULL) {
      if (!is.null(base_path)) {
        self$base_path <- base_path
      }

      if (!is.null(default_headers)) {
        self$default_headers <- default_headers
      }

      if (!is.null(username)) {
        self$username <- username
      }

      if (!is.null(password)) {
        self$password <- password
      }

      if (!is.null(access_token)) {
        self$access_token <- access_token
      }

      if (!is.null(bearer_token)) {
        self$bearer_token <- bearer_token
      }

      if (!is.null(api_keys)) {
        self$api_keys <- api_keys
      } else {
        self$api_keys <- list()
      }

      if (!is.null(user_agent)) {
        self$`user_agent` <- user_agent
      }

      if (!is.null(timeout)) {
        self$timeout <- timeout
      }

      if (!is.null(retry_status_codes)) {
        self$retry_status_codes <- retry_status_codes
      }

      if (!is.null(max_retry_attempts)) {
        self$max_retry_attempts <- max_retry_attempts
      }
    },
    #' Prepare to make an API call with the retry logic.
    #'
    #' @description
    #' Prepare to make an API call with the retry logic.
    #'
    #' @param url URL.
    #' @param method HTTP method.
    #' @param query_params The query parameters.
    #' @param header_params The header parameters.
    #' @param form_params The form parameters.
    #' @param file_params The form parameters for uploading files.
    #' @param accepts The list of Accept headers.
    #' @param content_types The list of Content-Type headers.
    #' @param body The HTTP request body.
    #' @param stream_callback Callback function to process the data stream
    #' @param ... Other optional arguments.
    #' @return HTTP response
    #' @keywords internal
    CallApi = function(url, method, query_params, header_params, form_params,
                       file_params, accepts, content_types,
                       body, stream_callback = NULL, ...) {

      resp <- self$Execute(url, method, query_params, header_params,
                           form_params, file_params,
                           accepts, content_types,
                           body, stream_callback = stream_callback, ...)

      if (is.null(self$max_retry_attempts)) {
        self$max_retry_attempts <- 3
      }

      if (!is.null(self$retry_status_codes)) {

        for (i in 1 : self$max_retry_attempts) {
          if (resp$status_code %in% self$retry_status_codes) {
            Sys.sleep((2 ^ i) + stats::runif(n = 1, min = 0, max = 1))
            resp <- self$Execute(url, method, query_params, header_params,
                                 form_params, file_params, accepts, content_types,
                                 body, stream_callback = stream_callback, ...)
          } else {
            break
          }
        }
      }

      resp
    },
    #' Make an API call
    #'
    #' @description
    #' Make an API call
    #'
    #' @param url URL.
    #' @param method HTTP method.
    #' @param query_params The query parameters.
    #' @param header_params The header parameters.
    #' @param form_params The form parameters.
    #' @param file_params The form parameters for uploading files.
    #' @param accepts The list of Accept headers
    #' @param content_types The list of Content-Type headers
    #' @param body The HTTP request body.
    #' @param stream_callback Callback function to process data stream
    #' @param ... Other optional arguments.
    #' @return HTTP response
    #' @keywords internal
    Execute = function(url, method, query_params, header_params,
                       form_params, file_params,
                       accepts, content_types,
                       body, stream_callback = NULL, ...) {
      headers <- httr::add_headers(c(header_params, self$default_headers))

      http_timeout <- NULL
      if (!is.null(self$timeout)) {
        http_timeout <- httr::timeout(self$timeout)
      }

      # set HTTP accept header
      accept = self$select_header(accepts)
      if (!is.null(accept)) {
        headers['Accept'] = accept
      }

      # set HTTP content-type header
      content_type = self$select_header(content_types)
      if (!is.null(content_type)) {
        headers['Content-Type'] = content_type
      }

      if (typeof(stream_callback) == "closure") { # stream data
        if (method == "GET") {
          httr::GET(url, query = query_params, headers, http_timeout,
                    httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "POST") {
          httr::POST(url, query = query_params, headers, body = body,
                     httr::content_type("application/json"), http_timeout,
                     httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "PUT") {
          httr::PUT(url, query = query_params, headers, body = body,
                    httr::content_type("application/json"), http_timeout,
                    http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "PATCH") {
          httr::PATCH(url, query = query_params, headers, body = body,
                      httr::content_type("application/json"), http_timeout,
                      http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "HEAD") {
          httr::HEAD(url, query = query_params, headers, http_timeout,
                     http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "DELETE") {
          httr::DELETE(url, query = query_params, headers, http_timeout,
                       http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else {
          err_msg <- "Http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`."
          stop(err_msg)
        }
      } else { # no streaming
        if (method == "GET") {
          httr_response <- httr::GET(url, query = query_params, headers, http_timeout,
                    httr::user_agent(self$`user_agent`), ...)
        } else if (method == "POST") {
          httr_response <- httr::POST(url, query = query_params, headers, body = body,
                     httr::content_type("application/json"), http_timeout,
                     httr::user_agent(self$`user_agent`), ...)
        } else if (method == "PUT") {
          httr_response <- httr::PUT(url, query = query_params, headers, body = body,
                    httr::content_type("application/json"), http_timeout,
                    http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else if (method == "PATCH") {
          httr_response <- httr::PATCH(url, query = query_params, headers, body = body,
                      httr::content_type("application/json"), http_timeout,
                      http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else if (method == "HEAD") {
          httr_response <- httr::HEAD(url, query = query_params, headers, http_timeout,
                     http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else if (method == "DELETE") {
          httr_response <- httr::DELETE(url, query = query_params, headers, http_timeout,
                       http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else {
          err_msg <- "Http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`."
          stop(err_msg)
        }

        # return ApiResponse
        api_response <- ApiResponse$new()
        api_response$status_code <- httr::status_code(httr_response) 
        api_response$status_code_desc <- httr::http_status(httr_response)$reason
        api_response$response <- httr::content(httr_response, "text", encoding = "UTF-8")
        api_response$headers <- httr::headers(httr_response)

        api_response
      }
    },
    #' Deserialize the content of API response to the given type.
    #'
    #' @description
    #' Deserialize the content of API response to the given type.
    #'
    #' @param raw_response Raw response.
    #' @param return_type R return type.
    #' @param pkg_env Package environment.
    #' @return Deserialized object.
    #' @keywords internal
    deserialize = function(raw_response, return_type, pkg_env) {
      resp_obj <- jsonlite::fromJSON(raw_response)
      self$deserializeObj(resp_obj, return_type, pkg_env)
    },
    #' Deserialize the response from jsonlite object based on the given type
    #'
    #' @description
    #' Deserialize the response from jsonlite object based on the given type
    #' by handling complex and nested types by iterating recursively
    #' Example return_types will be like "arrayinteger", "map(Pet)", "arraymap(Tag)", etc.,
    #'
    #' @param obj Response object.
    #' @param return_type R return type.
    #' @param pkg_env Package environment.
    #' @return Deserialized object.
    #' @keywords internal
    deserializeObj = function(obj, return_type, pkg_env) {
      return_obj <- NULL
      primitive_types <- c("character", "numeric", "integer", "logical", "complex")

      # To handle the "map" type
      if (startsWith(return_type, "map(")) {
        inner_return_type <- regmatches(return_type,
                                        regexec(pattern = "map\\((.*)\\)", return_type))[[1]][2]
        return_obj <- lapply(names(obj), function(name) {
          self$deserializeObj(obj[[name]], inner_return_type, pkg_env)
        })
        names(return_obj) <- names(obj)
      } else if (startsWith(return_type, "array[")) {
        # To handle the "array" type
        inner_return_type <- regmatches(return_type,
                                        regexec(pattern = "array\\[(.*)\\]", return_type))[[1]][2]
        if (c(inner_return_type) %in% primitive_types) {
          return_obj <- vector("list", length = length(obj))
          if (length(obj) > 0) {
            for (row in 1:length(obj)) {
              return_obj[[row]] <- self$deserializeObj(obj[row], inner_return_type, pkg_env)
            }
          }
        } else {
          if (!is.null(nrow(obj))) {
            return_obj <- vector("list", length = nrow(obj))
            if (nrow(obj) > 0) {
              for (row in 1:nrow(obj)) {
                return_obj[[row]] <- self$deserializeObj(obj[row, , drop = FALSE],
                                                         inner_return_type, pkg_env)
              }
            }
          }
        }
      } else if (exists(return_type, pkg_env) && !(c(return_type) %in% primitive_types)) {
        # To handle model objects which are not array or map containers. Ex:"Pet"
        return_type <- get(return_type, envir = as.environment(pkg_env))
        return_obj <- return_type$new()
        return_obj$fromJSON(
          jsonlite::toJSON(obj, digits = NA, auto_unbox = TRUE)
        )
      } else {
        # To handle primitive type
        return_obj <- obj
      }
      return_obj
    },
    #' Return a propery header (for accept or content-type).
    #'
    #' @description
    #' Return a propery header (for accept or content-type). If JSON-related MIME is found,
    #' return it. Otherwise, return the first one, if any.
    #'
    #' @param headers A list of headers
    #' @return A header (e.g. 'application/json')
    #' @keywords internal
    select_header = function(headers) {
      if (length(headers) == 0) {
        return(invisible(NULL))
      } else {
        for (header in headers) {
          if (str_detect(header, "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$")) {
            # return JSON-related MIME
            return(header)
          }
        }

        # not json mime type, simply return the first one
        return(headers[1])
      }
    }
  )
)

#' Create a new ApiInfoValueObject
#'
#' @description
#' ApiInfoValueObject Class
#'
#' @docType class
#' @title ApiInfoValueObject
#' @description ApiInfoValueObject Class
#' @format An \code{R6Class} generator object
#' @field welcome  character optional
#' @field version  character optional
#' @field docs  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ApiInfoValueObject <- R6::R6Class(
  "ApiInfoValueObject",
  public = list(
    `welcome` = NULL,
    `version` = NULL,
    `docs` = NULL,
    #' Initialize a new ApiInfoValueObject class.
    #'
    #' @description
    #' Initialize a new ApiInfoValueObject class.
    #'
    #' @param welcome welcome
    #' @param version version
    #' @param docs docs
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `welcome` = NULL, `version` = NULL, `docs` = NULL, ...
    ) {
      if (!is.null(`welcome`)) {
        stopifnot(is.character(`welcome`), length(`welcome`) == 1)
        self$`welcome` <- `welcome`
      }
      if (!is.null(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
      if (!is.null(`docs`)) {
        stopifnot(is.character(`docs`), length(`docs`) == 1)
        self$`docs` <- `docs`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ApiInfoValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ApiInfoValueObjectObject <- list()
      if (!is.null(self$`welcome`)) {
        ApiInfoValueObjectObject[["welcome"]] <-
          self$`welcome`
      }
      if (!is.null(self$`version`)) {
        ApiInfoValueObjectObject[["version"]] <-
          self$`version`
      }
      if (!is.null(self$`docs`)) {
        ApiInfoValueObjectObject[["docs"]] <-
          self$`docs`
      }
      ApiInfoValueObjectObject
    },
    #' Deserialize JSON string into an instance of ApiInfoValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ApiInfoValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ApiInfoValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`welcome`)) {
        self$`welcome` <- this_object$`welcome`
      }
      if (!is.null(this_object$`version`)) {
        self$`version` <- this_object$`version`
      }
      if (!is.null(this_object$`docs`)) {
        self$`docs` <- this_object$`docs`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ApiInfoValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`welcome`)) {
          sprintf(
          '"welcome":
            "%s"
                    ',
          self$`welcome`
          )
        },
        if (!is.null(self$`version`)) {
          sprintf(
          '"version":
            "%s"
                    ',
          self$`version`
          )
        },
        if (!is.null(self$`docs`)) {
          sprintf(
          '"docs":
            "%s"
                    ',
          self$`docs`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ApiInfoValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ApiInfoValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ApiInfoValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`welcome` <- this_object$`welcome`
      self$`version` <- this_object$`version`
      self$`docs` <- this_object$`docs`
      self
    },
    #' Validate JSON input with respect to ApiInfoValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ApiInfoValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ApiInfoValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ApiInfoValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ApiInfoValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ApiInfoValueObject$lock()


#' Gemma RESTful API
#'
#' This website documents the usage of the Gemma REST API(https://gemma.msl.ubc.ca/rest/v2/). Here you can find example script usage of the API, as well as graphical interface for each endpoint, with description of its parameters and the endpoint URL.  The documentation of the underlying java code can be found here(https://gemma.msl.ubc.ca/resources/apidocs/ubic/gemma/web/services/rest/package-summary.html). See the links section(https://gemma.msl.ubc.ca/resources/restapidocs/#footer) in the footer of this page for other relevant links.  Use of this webpage and Gemma web services, including the REST API, is subject to these terms and conditions(https://pavlidislab.github.io/Gemma/terms.html). Please read these in full before continuing to use this webpage or any other part of the Gemma system. 
#'
#' The version of the OpenAPI document: 2.4.1
#' Contact: pavlab-support@msl.ubc.ca
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title ApiResponse
#' @description ApiResponse Class
#' @format An \code{R6Class} generator object
#' @field content The deserialized response body.
#' @field response The raw response from the endpoint.
#' @field status_code The HTTP response status code.
#' @field status_code_desc The brief descriptoin of the HTTP response status code.
#' @field headers The HTTP response headers.
#' @keywords internal
ApiResponse <- R6::R6Class(
  "ApiResponse",
  public = list(
    content = NULL,
    response = NULL,
    status_code = NULL,
    status_code_desc = NULL,
    headers = NULL,
    #' Initialize a new ApiResponse class.
    #'
    #' @description
    #' Initialize a new ApiResponse class.
    #'
    #' @param content The deserialized response body.
    #' @param response The raw response from the endpoint.
    #' @param status_code The HTTP response status code.
    #' @param status_code_desc The brief description of the HTTP response status code.
    #' @param headers The HTTP response headers.
    #' @keywords internal
    initialize = function(content = NULL,
                          response = NULL,
                          status_code = NULL,
                          status_code_desc = NULL,
                          headers = NULL) {
      self$content <- content
      self$response <- response
      self$status_code <- status_code
      self$status_code_desc <- status_code_desc
      self$headers <- headers
    }
  )
)

#' Create a new ArrayDesign
#'
#' @description
#' ArrayDesign Class
#'
#' @docType class
#' @title ArrayDesign
#' @description ArrayDesign Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field auditTrail  \link{AuditTrail} optional
#' @field advertisedNumberOfDesignElements  integer optional
#' @field alternateNames  list(\link{AlternateName}) optional
#' @field alternativeTo  \link{ArrayDesign} optional
#' @field compositeSequences  list(\link{CompositeSequence}) optional
#' @field curationDetails  \link{CurationDetails} optional
#' @field designProvider  \link{Contact} optional
#' @field externalReferences  list(\link{DatabaseEntry}) optional
#' @field mergedInto  \link{ArrayDesign} optional
#' @field mergees  list(\link{ArrayDesign}) optional
#' @field primaryTaxon  \link{Taxon} optional
#' @field shortName  character optional
#' @field subsumedArrayDesigns  list(\link{ArrayDesign}) optional
#' @field subsumingArrayDesign  \link{ArrayDesign} optional
#' @field technologyType  \link{TechnologyType} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ArrayDesign <- R6::R6Class(
  "ArrayDesign",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `auditTrail` = NULL,
    `advertisedNumberOfDesignElements` = NULL,
    `alternateNames` = NULL,
    `alternativeTo` = NULL,
    `compositeSequences` = NULL,
    `curationDetails` = NULL,
    `designProvider` = NULL,
    `externalReferences` = NULL,
    `mergedInto` = NULL,
    `mergees` = NULL,
    `primaryTaxon` = NULL,
    `shortName` = NULL,
    `subsumedArrayDesigns` = NULL,
    `subsumingArrayDesign` = NULL,
    `technologyType` = NULL,
    #' Initialize a new ArrayDesign class.
    #'
    #' @description
    #' Initialize a new ArrayDesign class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param auditTrail auditTrail
    #' @param advertisedNumberOfDesignElements advertisedNumberOfDesignElements
    #' @param alternateNames alternateNames
    #' @param alternativeTo alternativeTo
    #' @param compositeSequences compositeSequences
    #' @param curationDetails curationDetails
    #' @param designProvider designProvider
    #' @param externalReferences externalReferences
    #' @param mergedInto mergedInto
    #' @param mergees mergees
    #' @param primaryTaxon primaryTaxon
    #' @param shortName shortName
    #' @param subsumedArrayDesigns subsumedArrayDesigns
    #' @param subsumingArrayDesign subsumingArrayDesign
    #' @param technologyType technologyType
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `auditTrail` = NULL, `advertisedNumberOfDesignElements` = NULL, `alternateNames` = NULL, `alternativeTo` = NULL, `compositeSequences` = NULL, `curationDetails` = NULL, `designProvider` = NULL, `externalReferences` = NULL, `mergedInto` = NULL, `mergees` = NULL, `primaryTaxon` = NULL, `shortName` = NULL, `subsumedArrayDesigns` = NULL, `subsumingArrayDesign` = NULL, `technologyType` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`auditTrail`)) {
        stopifnot(R6::is.R6(`auditTrail`))
        self$`auditTrail` <- `auditTrail`
      }
      if (!is.null(`advertisedNumberOfDesignElements`)) {
        stopifnot(is.numeric(`advertisedNumberOfDesignElements`), length(`advertisedNumberOfDesignElements`) == 1)
        self$`advertisedNumberOfDesignElements` <- `advertisedNumberOfDesignElements`
      }
      if (!is.null(`alternateNames`)) {
        stopifnot(is.vector(`alternateNames`), length(`alternateNames`) != 0)
        sapply(`alternateNames`, function(x) stopifnot(R6::is.R6(x)))
        self$`alternateNames` <- `alternateNames`
      }
      if (!is.null(`alternativeTo`)) {
        stopifnot(R6::is.R6(`alternativeTo`))
        self$`alternativeTo` <- `alternativeTo`
      }
      if (!is.null(`compositeSequences`)) {
        stopifnot(is.vector(`compositeSequences`), length(`compositeSequences`) != 0)
        sapply(`compositeSequences`, function(x) stopifnot(R6::is.R6(x)))
        self$`compositeSequences` <- `compositeSequences`
      }
      if (!is.null(`curationDetails`)) {
        stopifnot(R6::is.R6(`curationDetails`))
        self$`curationDetails` <- `curationDetails`
      }
      if (!is.null(`designProvider`)) {
        stopifnot(R6::is.R6(`designProvider`))
        self$`designProvider` <- `designProvider`
      }
      if (!is.null(`externalReferences`)) {
        stopifnot(is.vector(`externalReferences`), length(`externalReferences`) != 0)
        sapply(`externalReferences`, function(x) stopifnot(R6::is.R6(x)))
        self$`externalReferences` <- `externalReferences`
      }
      if (!is.null(`mergedInto`)) {
        stopifnot(R6::is.R6(`mergedInto`))
        self$`mergedInto` <- `mergedInto`
      }
      if (!is.null(`mergees`)) {
        stopifnot(is.vector(`mergees`), length(`mergees`) != 0)
        sapply(`mergees`, function(x) stopifnot(R6::is.R6(x)))
        self$`mergees` <- `mergees`
      }
      if (!is.null(`primaryTaxon`)) {
        stopifnot(R6::is.R6(`primaryTaxon`))
        self$`primaryTaxon` <- `primaryTaxon`
      }
      if (!is.null(`shortName`)) {
        stopifnot(is.character(`shortName`), length(`shortName`) == 1)
        self$`shortName` <- `shortName`
      }
      if (!is.null(`subsumedArrayDesigns`)) {
        stopifnot(is.vector(`subsumedArrayDesigns`), length(`subsumedArrayDesigns`) != 0)
        sapply(`subsumedArrayDesigns`, function(x) stopifnot(R6::is.R6(x)))
        self$`subsumedArrayDesigns` <- `subsumedArrayDesigns`
      }
      if (!is.null(`subsumingArrayDesign`)) {
        stopifnot(R6::is.R6(`subsumingArrayDesign`))
        self$`subsumingArrayDesign` <- `subsumingArrayDesign`
      }
      if (!is.null(`technologyType`)) {
        stopifnot(R6::is.R6(`technologyType`))
        self$`technologyType` <- `technologyType`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ArrayDesign in JSON format
    #' @keywords internal
    toJSON = function() {
      ArrayDesignObject <- list()
      if (!is.null(self$`name`)) {
        ArrayDesignObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        ArrayDesignObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        ArrayDesignObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`auditTrail`)) {
        ArrayDesignObject[["auditTrail"]] <-
          self$`auditTrail`$toJSON()
      }
      if (!is.null(self$`advertisedNumberOfDesignElements`)) {
        ArrayDesignObject[["advertisedNumberOfDesignElements"]] <-
          self$`advertisedNumberOfDesignElements`
      }
      if (!is.null(self$`alternateNames`)) {
        ArrayDesignObject[["alternateNames"]] <-
          lapply(self$`alternateNames`, function(x) x$toJSON())
      }
      if (!is.null(self$`alternativeTo`)) {
        ArrayDesignObject[["alternativeTo"]] <-
          self$`alternativeTo`$toJSON()
      }
      if (!is.null(self$`compositeSequences`)) {
        ArrayDesignObject[["compositeSequences"]] <-
          lapply(self$`compositeSequences`, function(x) x$toJSON())
      }
      if (!is.null(self$`curationDetails`)) {
        ArrayDesignObject[["curationDetails"]] <-
          self$`curationDetails`$toJSON()
      }
      if (!is.null(self$`designProvider`)) {
        ArrayDesignObject[["designProvider"]] <-
          self$`designProvider`$toJSON()
      }
      if (!is.null(self$`externalReferences`)) {
        ArrayDesignObject[["externalReferences"]] <-
          lapply(self$`externalReferences`, function(x) x$toJSON())
      }
      if (!is.null(self$`mergedInto`)) {
        ArrayDesignObject[["mergedInto"]] <-
          self$`mergedInto`$toJSON()
      }
      if (!is.null(self$`mergees`)) {
        ArrayDesignObject[["mergees"]] <-
          lapply(self$`mergees`, function(x) x$toJSON())
      }
      if (!is.null(self$`primaryTaxon`)) {
        ArrayDesignObject[["primaryTaxon"]] <-
          self$`primaryTaxon`$toJSON()
      }
      if (!is.null(self$`shortName`)) {
        ArrayDesignObject[["shortName"]] <-
          self$`shortName`
      }
      if (!is.null(self$`subsumedArrayDesigns`)) {
        ArrayDesignObject[["subsumedArrayDesigns"]] <-
          lapply(self$`subsumedArrayDesigns`, function(x) x$toJSON())
      }
      if (!is.null(self$`subsumingArrayDesign`)) {
        ArrayDesignObject[["subsumingArrayDesign"]] <-
          self$`subsumingArrayDesign`$toJSON()
      }
      if (!is.null(self$`technologyType`)) {
        ArrayDesignObject[["technologyType"]] <-
          self$`technologyType`$toJSON()
      }
      ArrayDesignObject
    },
    #' Deserialize JSON string into an instance of ArrayDesign
    #'
    #' @description
    #' Deserialize JSON string into an instance of ArrayDesign
    #'
    #' @param input_json the JSON input
    #' @return the instance of ArrayDesign
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`auditTrail`)) {
        audittrail_object <- AuditTrail$new()
        audittrail_object$fromJSON(jsonlite::toJSON(this_object$auditTrail, auto_unbox = TRUE, digits = NA))
        self$`auditTrail` <- audittrail_object
      }
      if (!is.null(this_object$`advertisedNumberOfDesignElements`)) {
        self$`advertisedNumberOfDesignElements` <- this_object$`advertisedNumberOfDesignElements`
      }
      if (!is.null(this_object$`alternateNames`)) {
        self$`alternateNames` <- ApiClient$new()$deserializeObj(this_object$`alternateNames`, "set[AlternateName]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`alternativeTo`)) {
        alternativeto_object <- ArrayDesign$new()
        alternativeto_object$fromJSON(jsonlite::toJSON(this_object$alternativeTo, auto_unbox = TRUE, digits = NA))
        self$`alternativeTo` <- alternativeto_object
      }
      if (!is.null(this_object$`compositeSequences`)) {
        self$`compositeSequences` <- ApiClient$new()$deserializeObj(this_object$`compositeSequences`, "set[CompositeSequence]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`curationDetails`)) {
        curationdetails_object <- CurationDetails$new()
        curationdetails_object$fromJSON(jsonlite::toJSON(this_object$curationDetails, auto_unbox = TRUE, digits = NA))
        self$`curationDetails` <- curationdetails_object
      }
      if (!is.null(this_object$`designProvider`)) {
        designprovider_object <- Contact$new()
        designprovider_object$fromJSON(jsonlite::toJSON(this_object$designProvider, auto_unbox = TRUE, digits = NA))
        self$`designProvider` <- designprovider_object
      }
      if (!is.null(this_object$`externalReferences`)) {
        self$`externalReferences` <- ApiClient$new()$deserializeObj(this_object$`externalReferences`, "set[DatabaseEntry]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`mergedInto`)) {
        mergedinto_object <- ArrayDesign$new()
        mergedinto_object$fromJSON(jsonlite::toJSON(this_object$mergedInto, auto_unbox = TRUE, digits = NA))
        self$`mergedInto` <- mergedinto_object
      }
      if (!is.null(this_object$`mergees`)) {
        self$`mergees` <- ApiClient$new()$deserializeObj(this_object$`mergees`, "set[ArrayDesign]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`primaryTaxon`)) {
        primarytaxon_object <- Taxon$new()
        primarytaxon_object$fromJSON(jsonlite::toJSON(this_object$primaryTaxon, auto_unbox = TRUE, digits = NA))
        self$`primaryTaxon` <- primarytaxon_object
      }
      if (!is.null(this_object$`shortName`)) {
        self$`shortName` <- this_object$`shortName`
      }
      if (!is.null(this_object$`subsumedArrayDesigns`)) {
        self$`subsumedArrayDesigns` <- ApiClient$new()$deserializeObj(this_object$`subsumedArrayDesigns`, "set[ArrayDesign]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`subsumingArrayDesign`)) {
        subsumingarraydesign_object <- ArrayDesign$new()
        subsumingarraydesign_object$fromJSON(jsonlite::toJSON(this_object$subsumingArrayDesign, auto_unbox = TRUE, digits = NA))
        self$`subsumingArrayDesign` <- subsumingarraydesign_object
      }
      if (!is.null(this_object$`technologyType`)) {
        technologytype_object <- TechnologyType$new()
        technologytype_object$fromJSON(jsonlite::toJSON(this_object$technologyType, auto_unbox = TRUE, digits = NA))
        self$`technologyType` <- technologytype_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ArrayDesign in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`auditTrail`)) {
          sprintf(
          '"auditTrail":
          %s
          ',
          jsonlite::toJSON(self$`auditTrail`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`advertisedNumberOfDesignElements`)) {
          sprintf(
          '"advertisedNumberOfDesignElements":
            %d
                    ',
          self$`advertisedNumberOfDesignElements`
          )
        },
        if (!is.null(self$`alternateNames`)) {
          sprintf(
          '"alternateNames":
          [%s]
',
          paste(sapply(self$`alternateNames`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`alternativeTo`)) {
          sprintf(
          '"alternativeTo":
          %s
          ',
          jsonlite::toJSON(self$`alternativeTo`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`compositeSequences`)) {
          sprintf(
          '"compositeSequences":
          [%s]
',
          paste(sapply(self$`compositeSequences`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`curationDetails`)) {
          sprintf(
          '"curationDetails":
          %s
          ',
          jsonlite::toJSON(self$`curationDetails`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`designProvider`)) {
          sprintf(
          '"designProvider":
          %s
          ',
          jsonlite::toJSON(self$`designProvider`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`externalReferences`)) {
          sprintf(
          '"externalReferences":
          [%s]
',
          paste(sapply(self$`externalReferences`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`mergedInto`)) {
          sprintf(
          '"mergedInto":
          %s
          ',
          jsonlite::toJSON(self$`mergedInto`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`mergees`)) {
          sprintf(
          '"mergees":
          [%s]
',
          paste(sapply(self$`mergees`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`primaryTaxon`)) {
          sprintf(
          '"primaryTaxon":
          %s
          ',
          jsonlite::toJSON(self$`primaryTaxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`shortName`)) {
          sprintf(
          '"shortName":
            "%s"
                    ',
          self$`shortName`
          )
        },
        if (!is.null(self$`subsumedArrayDesigns`)) {
          sprintf(
          '"subsumedArrayDesigns":
          [%s]
',
          paste(sapply(self$`subsumedArrayDesigns`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`subsumingArrayDesign`)) {
          sprintf(
          '"subsumingArrayDesign":
          %s
          ',
          jsonlite::toJSON(self$`subsumingArrayDesign`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`technologyType`)) {
          sprintf(
          '"technologyType":
          %s
          ',
          jsonlite::toJSON(self$`technologyType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ArrayDesign
    #'
    #' @description
    #' Deserialize JSON string into an instance of ArrayDesign
    #'
    #' @param input_json the JSON input
    #' @return the instance of ArrayDesign
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`auditTrail` <- AuditTrail$new()$fromJSON(jsonlite::toJSON(this_object$auditTrail, auto_unbox = TRUE, digits = NA))
      self$`advertisedNumberOfDesignElements` <- this_object$`advertisedNumberOfDesignElements`
      self$`alternateNames` <- ApiClient$new()$deserializeObj(this_object$`alternateNames`, "set[AlternateName]", loadNamespace("gemma.R"))
      self$`alternativeTo` <- ArrayDesign$new()$fromJSON(jsonlite::toJSON(this_object$alternativeTo, auto_unbox = TRUE, digits = NA))
      self$`compositeSequences` <- ApiClient$new()$deserializeObj(this_object$`compositeSequences`, "set[CompositeSequence]", loadNamespace("gemma.R"))
      self$`curationDetails` <- CurationDetails$new()$fromJSON(jsonlite::toJSON(this_object$curationDetails, auto_unbox = TRUE, digits = NA))
      self$`designProvider` <- Contact$new()$fromJSON(jsonlite::toJSON(this_object$designProvider, auto_unbox = TRUE, digits = NA))
      self$`externalReferences` <- ApiClient$new()$deserializeObj(this_object$`externalReferences`, "set[DatabaseEntry]", loadNamespace("gemma.R"))
      self$`mergedInto` <- ArrayDesign$new()$fromJSON(jsonlite::toJSON(this_object$mergedInto, auto_unbox = TRUE, digits = NA))
      self$`mergees` <- ApiClient$new()$deserializeObj(this_object$`mergees`, "set[ArrayDesign]", loadNamespace("gemma.R"))
      self$`primaryTaxon` <- Taxon$new()$fromJSON(jsonlite::toJSON(this_object$primaryTaxon, auto_unbox = TRUE, digits = NA))
      self$`shortName` <- this_object$`shortName`
      self$`subsumedArrayDesigns` <- ApiClient$new()$deserializeObj(this_object$`subsumedArrayDesigns`, "set[ArrayDesign]", loadNamespace("gemma.R"))
      self$`subsumingArrayDesign` <- ArrayDesign$new()$fromJSON(jsonlite::toJSON(this_object$subsumingArrayDesign, auto_unbox = TRUE, digits = NA))
      self$`technologyType` <- TechnologyType$new()$fromJSON(jsonlite::toJSON(this_object$technologyType, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to ArrayDesign
    #'
    #' @description
    #' Validate JSON input with respect to ArrayDesign and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ArrayDesign
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {





      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()





      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ArrayDesign$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ArrayDesign$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ArrayDesign$lock()


#' Create a new ArrayDesignValueObject
#'
#' @description
#' ArrayDesignValueObject Class
#'
#' @docType class
#' @title ArrayDesignValueObject
#' @description ArrayDesignValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field lastUpdated  character optional
#' @field troubled  character optional
#' @field lastTroubledEvent  \link{AuditEventValueObject} optional
#' @field needsAttention  character optional
#' @field lastNeedsAttentionEvent  \link{AuditEventValueObject} optional
#' @field curationNote  character optional
#' @field lastNoteUpdateEvent  \link{AuditEventValueObject} optional
#' @field blackListed  character optional
#' @field color  character optional
#' @field dateCached  character optional
#' @field description  character optional
#' @field designElementCount  integer optional
#' @field expressionExperimentCount  integer optional
#' @field hasBlatAssociations  character optional
#' @field hasGeneAssociations  character optional
#' @field hasSequenceAssociations  character optional
#' @field isAffymetrixAltCdf  character optional
#' @field isMerged  character optional
#' @field isMergee  character optional
#' @field isSubsumed  character optional
#' @field isSubsumer  character optional
#' @field lastGeneMapping  character optional
#' @field lastRepeatMask  character optional
#' @field lastSequenceAnalysis  character optional
#' @field lastSequenceUpdate  character optional
#' @field name  character optional
#' @field numGenes  character optional
#' @field numProbeAlignments  character optional
#' @field numProbeSequences  character optional
#' @field numProbesToGenes  character optional
#' @field shortName  character optional
#' @field switchedExpressionExperimentCount  integer optional
#' @field taxon  character optional
#' @field taxonID  integer optional
#' @field technologyType  character optional
#' @field troubleDetails  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ArrayDesignValueObject <- R6::R6Class(
  "ArrayDesignValueObject",
  public = list(
    `id` = NULL,
    `lastUpdated` = NULL,
    `troubled` = NULL,
    `lastTroubledEvent` = NULL,
    `needsAttention` = NULL,
    `lastNeedsAttentionEvent` = NULL,
    `curationNote` = NULL,
    `lastNoteUpdateEvent` = NULL,
    `blackListed` = NULL,
    `color` = NULL,
    `dateCached` = NULL,
    `description` = NULL,
    `designElementCount` = NULL,
    `expressionExperimentCount` = NULL,
    `hasBlatAssociations` = NULL,
    `hasGeneAssociations` = NULL,
    `hasSequenceAssociations` = NULL,
    `isAffymetrixAltCdf` = NULL,
    `isMerged` = NULL,
    `isMergee` = NULL,
    `isSubsumed` = NULL,
    `isSubsumer` = NULL,
    `lastGeneMapping` = NULL,
    `lastRepeatMask` = NULL,
    `lastSequenceAnalysis` = NULL,
    `lastSequenceUpdate` = NULL,
    `name` = NULL,
    `numGenes` = NULL,
    `numProbeAlignments` = NULL,
    `numProbeSequences` = NULL,
    `numProbesToGenes` = NULL,
    `shortName` = NULL,
    `switchedExpressionExperimentCount` = NULL,
    `taxon` = NULL,
    `taxonID` = NULL,
    `technologyType` = NULL,
    `troubleDetails` = NULL,
    #' Initialize a new ArrayDesignValueObject class.
    #'
    #' @description
    #' Initialize a new ArrayDesignValueObject class.
    #'
    #' @param id id
    #' @param lastUpdated lastUpdated
    #' @param troubled troubled
    #' @param lastTroubledEvent lastTroubledEvent
    #' @param needsAttention needsAttention
    #' @param lastNeedsAttentionEvent lastNeedsAttentionEvent
    #' @param curationNote curationNote
    #' @param lastNoteUpdateEvent lastNoteUpdateEvent
    #' @param blackListed blackListed
    #' @param color color
    #' @param dateCached dateCached
    #' @param description description
    #' @param designElementCount designElementCount
    #' @param expressionExperimentCount expressionExperimentCount
    #' @param hasBlatAssociations hasBlatAssociations
    #' @param hasGeneAssociations hasGeneAssociations
    #' @param hasSequenceAssociations hasSequenceAssociations
    #' @param isAffymetrixAltCdf isAffymetrixAltCdf
    #' @param isMerged isMerged
    #' @param isMergee isMergee
    #' @param isSubsumed isSubsumed
    #' @param isSubsumer isSubsumer
    #' @param lastGeneMapping lastGeneMapping
    #' @param lastRepeatMask lastRepeatMask
    #' @param lastSequenceAnalysis lastSequenceAnalysis
    #' @param lastSequenceUpdate lastSequenceUpdate
    #' @param name name
    #' @param numGenes numGenes
    #' @param numProbeAlignments numProbeAlignments
    #' @param numProbeSequences numProbeSequences
    #' @param numProbesToGenes numProbesToGenes
    #' @param shortName shortName
    #' @param switchedExpressionExperimentCount switchedExpressionExperimentCount
    #' @param taxon taxon
    #' @param taxonID taxonID
    #' @param technologyType technologyType
    #' @param troubleDetails troubleDetails
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `lastUpdated` = NULL, `troubled` = NULL, `lastTroubledEvent` = NULL, `needsAttention` = NULL, `lastNeedsAttentionEvent` = NULL, `curationNote` = NULL, `lastNoteUpdateEvent` = NULL, `blackListed` = NULL, `color` = NULL, `dateCached` = NULL, `description` = NULL, `designElementCount` = NULL, `expressionExperimentCount` = NULL, `hasBlatAssociations` = NULL, `hasGeneAssociations` = NULL, `hasSequenceAssociations` = NULL, `isAffymetrixAltCdf` = NULL, `isMerged` = NULL, `isMergee` = NULL, `isSubsumed` = NULL, `isSubsumer` = NULL, `lastGeneMapping` = NULL, `lastRepeatMask` = NULL, `lastSequenceAnalysis` = NULL, `lastSequenceUpdate` = NULL, `name` = NULL, `numGenes` = NULL, `numProbeAlignments` = NULL, `numProbeSequences` = NULL, `numProbesToGenes` = NULL, `shortName` = NULL, `switchedExpressionExperimentCount` = NULL, `taxon` = NULL, `taxonID` = NULL, `technologyType` = NULL, `troubleDetails` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`lastUpdated`)) {
        stopifnot(is.character(`lastUpdated`), length(`lastUpdated`) == 1)
        self$`lastUpdated` <- `lastUpdated`
      }
      if (!is.null(`troubled`)) {
        stopifnot(is.logical(`troubled`), length(`troubled`) == 1)
        self$`troubled` <- `troubled`
      }
      if (!is.null(`lastTroubledEvent`)) {
        stopifnot(R6::is.R6(`lastTroubledEvent`))
        self$`lastTroubledEvent` <- `lastTroubledEvent`
      }
      if (!is.null(`needsAttention`)) {
        stopifnot(is.logical(`needsAttention`), length(`needsAttention`) == 1)
        self$`needsAttention` <- `needsAttention`
      }
      if (!is.null(`lastNeedsAttentionEvent`)) {
        stopifnot(R6::is.R6(`lastNeedsAttentionEvent`))
        self$`lastNeedsAttentionEvent` <- `lastNeedsAttentionEvent`
      }
      if (!is.null(`curationNote`)) {
        stopifnot(is.character(`curationNote`), length(`curationNote`) == 1)
        self$`curationNote` <- `curationNote`
      }
      if (!is.null(`lastNoteUpdateEvent`)) {
        stopifnot(R6::is.R6(`lastNoteUpdateEvent`))
        self$`lastNoteUpdateEvent` <- `lastNoteUpdateEvent`
      }
      if (!is.null(`blackListed`)) {
        stopifnot(is.logical(`blackListed`), length(`blackListed`) == 1)
        self$`blackListed` <- `blackListed`
      }
      if (!is.null(`color`)) {
        stopifnot(is.character(`color`), length(`color`) == 1)
        self$`color` <- `color`
      }
      if (!is.null(`dateCached`)) {
        stopifnot(is.character(`dateCached`), length(`dateCached`) == 1)
        self$`dateCached` <- `dateCached`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`designElementCount`)) {
        stopifnot(is.numeric(`designElementCount`), length(`designElementCount`) == 1)
        self$`designElementCount` <- `designElementCount`
      }
      if (!is.null(`expressionExperimentCount`)) {
        stopifnot(is.numeric(`expressionExperimentCount`), length(`expressionExperimentCount`) == 1)
        self$`expressionExperimentCount` <- `expressionExperimentCount`
      }
      if (!is.null(`hasBlatAssociations`)) {
        stopifnot(is.logical(`hasBlatAssociations`), length(`hasBlatAssociations`) == 1)
        self$`hasBlatAssociations` <- `hasBlatAssociations`
      }
      if (!is.null(`hasGeneAssociations`)) {
        stopifnot(is.logical(`hasGeneAssociations`), length(`hasGeneAssociations`) == 1)
        self$`hasGeneAssociations` <- `hasGeneAssociations`
      }
      if (!is.null(`hasSequenceAssociations`)) {
        stopifnot(is.logical(`hasSequenceAssociations`), length(`hasSequenceAssociations`) == 1)
        self$`hasSequenceAssociations` <- `hasSequenceAssociations`
      }
      if (!is.null(`isAffymetrixAltCdf`)) {
        stopifnot(is.logical(`isAffymetrixAltCdf`), length(`isAffymetrixAltCdf`) == 1)
        self$`isAffymetrixAltCdf` <- `isAffymetrixAltCdf`
      }
      if (!is.null(`isMerged`)) {
        stopifnot(is.logical(`isMerged`), length(`isMerged`) == 1)
        self$`isMerged` <- `isMerged`
      }
      if (!is.null(`isMergee`)) {
        stopifnot(is.logical(`isMergee`), length(`isMergee`) == 1)
        self$`isMergee` <- `isMergee`
      }
      if (!is.null(`isSubsumed`)) {
        stopifnot(is.logical(`isSubsumed`), length(`isSubsumed`) == 1)
        self$`isSubsumed` <- `isSubsumed`
      }
      if (!is.null(`isSubsumer`)) {
        stopifnot(is.logical(`isSubsumer`), length(`isSubsumer`) == 1)
        self$`isSubsumer` <- `isSubsumer`
      }
      if (!is.null(`lastGeneMapping`)) {
        stopifnot(is.character(`lastGeneMapping`), length(`lastGeneMapping`) == 1)
        self$`lastGeneMapping` <- `lastGeneMapping`
      }
      if (!is.null(`lastRepeatMask`)) {
        stopifnot(is.character(`lastRepeatMask`), length(`lastRepeatMask`) == 1)
        self$`lastRepeatMask` <- `lastRepeatMask`
      }
      if (!is.null(`lastSequenceAnalysis`)) {
        stopifnot(is.character(`lastSequenceAnalysis`), length(`lastSequenceAnalysis`) == 1)
        self$`lastSequenceAnalysis` <- `lastSequenceAnalysis`
      }
      if (!is.null(`lastSequenceUpdate`)) {
        stopifnot(is.character(`lastSequenceUpdate`), length(`lastSequenceUpdate`) == 1)
        self$`lastSequenceUpdate` <- `lastSequenceUpdate`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`numGenes`)) {
        stopifnot(is.character(`numGenes`), length(`numGenes`) == 1)
        self$`numGenes` <- `numGenes`
      }
      if (!is.null(`numProbeAlignments`)) {
        stopifnot(is.character(`numProbeAlignments`), length(`numProbeAlignments`) == 1)
        self$`numProbeAlignments` <- `numProbeAlignments`
      }
      if (!is.null(`numProbeSequences`)) {
        stopifnot(is.character(`numProbeSequences`), length(`numProbeSequences`) == 1)
        self$`numProbeSequences` <- `numProbeSequences`
      }
      if (!is.null(`numProbesToGenes`)) {
        stopifnot(is.character(`numProbesToGenes`), length(`numProbesToGenes`) == 1)
        self$`numProbesToGenes` <- `numProbesToGenes`
      }
      if (!is.null(`shortName`)) {
        stopifnot(is.character(`shortName`), length(`shortName`) == 1)
        self$`shortName` <- `shortName`
      }
      if (!is.null(`switchedExpressionExperimentCount`)) {
        stopifnot(is.numeric(`switchedExpressionExperimentCount`), length(`switchedExpressionExperimentCount`) == 1)
        self$`switchedExpressionExperimentCount` <- `switchedExpressionExperimentCount`
      }
      if (!is.null(`taxon`)) {
        stopifnot(is.character(`taxon`), length(`taxon`) == 1)
        self$`taxon` <- `taxon`
      }
      if (!is.null(`taxonID`)) {
        stopifnot(is.numeric(`taxonID`), length(`taxonID`) == 1)
        self$`taxonID` <- `taxonID`
      }
      if (!is.null(`technologyType`)) {
        stopifnot(is.character(`technologyType`), length(`technologyType`) == 1)
        self$`technologyType` <- `technologyType`
      }
      if (!is.null(`troubleDetails`)) {
        stopifnot(is.character(`troubleDetails`), length(`troubleDetails`) == 1)
        self$`troubleDetails` <- `troubleDetails`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ArrayDesignValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ArrayDesignValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        ArrayDesignValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`lastUpdated`)) {
        ArrayDesignValueObjectObject[["lastUpdated"]] <-
          self$`lastUpdated`
      }
      if (!is.null(self$`troubled`)) {
        ArrayDesignValueObjectObject[["troubled"]] <-
          self$`troubled`
      }
      if (!is.null(self$`lastTroubledEvent`)) {
        ArrayDesignValueObjectObject[["lastTroubledEvent"]] <-
          self$`lastTroubledEvent`$toJSON()
      }
      if (!is.null(self$`needsAttention`)) {
        ArrayDesignValueObjectObject[["needsAttention"]] <-
          self$`needsAttention`
      }
      if (!is.null(self$`lastNeedsAttentionEvent`)) {
        ArrayDesignValueObjectObject[["lastNeedsAttentionEvent"]] <-
          self$`lastNeedsAttentionEvent`$toJSON()
      }
      if (!is.null(self$`curationNote`)) {
        ArrayDesignValueObjectObject[["curationNote"]] <-
          self$`curationNote`
      }
      if (!is.null(self$`lastNoteUpdateEvent`)) {
        ArrayDesignValueObjectObject[["lastNoteUpdateEvent"]] <-
          self$`lastNoteUpdateEvent`$toJSON()
      }
      if (!is.null(self$`blackListed`)) {
        ArrayDesignValueObjectObject[["blackListed"]] <-
          self$`blackListed`
      }
      if (!is.null(self$`color`)) {
        ArrayDesignValueObjectObject[["color"]] <-
          self$`color`
      }
      if (!is.null(self$`dateCached`)) {
        ArrayDesignValueObjectObject[["dateCached"]] <-
          self$`dateCached`
      }
      if (!is.null(self$`description`)) {
        ArrayDesignValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`designElementCount`)) {
        ArrayDesignValueObjectObject[["designElementCount"]] <-
          self$`designElementCount`
      }
      if (!is.null(self$`expressionExperimentCount`)) {
        ArrayDesignValueObjectObject[["expressionExperimentCount"]] <-
          self$`expressionExperimentCount`
      }
      if (!is.null(self$`hasBlatAssociations`)) {
        ArrayDesignValueObjectObject[["hasBlatAssociations"]] <-
          self$`hasBlatAssociations`
      }
      if (!is.null(self$`hasGeneAssociations`)) {
        ArrayDesignValueObjectObject[["hasGeneAssociations"]] <-
          self$`hasGeneAssociations`
      }
      if (!is.null(self$`hasSequenceAssociations`)) {
        ArrayDesignValueObjectObject[["hasSequenceAssociations"]] <-
          self$`hasSequenceAssociations`
      }
      if (!is.null(self$`isAffymetrixAltCdf`)) {
        ArrayDesignValueObjectObject[["isAffymetrixAltCdf"]] <-
          self$`isAffymetrixAltCdf`
      }
      if (!is.null(self$`isMerged`)) {
        ArrayDesignValueObjectObject[["isMerged"]] <-
          self$`isMerged`
      }
      if (!is.null(self$`isMergee`)) {
        ArrayDesignValueObjectObject[["isMergee"]] <-
          self$`isMergee`
      }
      if (!is.null(self$`isSubsumed`)) {
        ArrayDesignValueObjectObject[["isSubsumed"]] <-
          self$`isSubsumed`
      }
      if (!is.null(self$`isSubsumer`)) {
        ArrayDesignValueObjectObject[["isSubsumer"]] <-
          self$`isSubsumer`
      }
      if (!is.null(self$`lastGeneMapping`)) {
        ArrayDesignValueObjectObject[["lastGeneMapping"]] <-
          self$`lastGeneMapping`
      }
      if (!is.null(self$`lastRepeatMask`)) {
        ArrayDesignValueObjectObject[["lastRepeatMask"]] <-
          self$`lastRepeatMask`
      }
      if (!is.null(self$`lastSequenceAnalysis`)) {
        ArrayDesignValueObjectObject[["lastSequenceAnalysis"]] <-
          self$`lastSequenceAnalysis`
      }
      if (!is.null(self$`lastSequenceUpdate`)) {
        ArrayDesignValueObjectObject[["lastSequenceUpdate"]] <-
          self$`lastSequenceUpdate`
      }
      if (!is.null(self$`name`)) {
        ArrayDesignValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`numGenes`)) {
        ArrayDesignValueObjectObject[["numGenes"]] <-
          self$`numGenes`
      }
      if (!is.null(self$`numProbeAlignments`)) {
        ArrayDesignValueObjectObject[["numProbeAlignments"]] <-
          self$`numProbeAlignments`
      }
      if (!is.null(self$`numProbeSequences`)) {
        ArrayDesignValueObjectObject[["numProbeSequences"]] <-
          self$`numProbeSequences`
      }
      if (!is.null(self$`numProbesToGenes`)) {
        ArrayDesignValueObjectObject[["numProbesToGenes"]] <-
          self$`numProbesToGenes`
      }
      if (!is.null(self$`shortName`)) {
        ArrayDesignValueObjectObject[["shortName"]] <-
          self$`shortName`
      }
      if (!is.null(self$`switchedExpressionExperimentCount`)) {
        ArrayDesignValueObjectObject[["switchedExpressionExperimentCount"]] <-
          self$`switchedExpressionExperimentCount`
      }
      if (!is.null(self$`taxon`)) {
        ArrayDesignValueObjectObject[["taxon"]] <-
          self$`taxon`
      }
      if (!is.null(self$`taxonID`)) {
        ArrayDesignValueObjectObject[["taxonID"]] <-
          self$`taxonID`
      }
      if (!is.null(self$`technologyType`)) {
        ArrayDesignValueObjectObject[["technologyType"]] <-
          self$`technologyType`
      }
      if (!is.null(self$`troubleDetails`)) {
        ArrayDesignValueObjectObject[["troubleDetails"]] <-
          self$`troubleDetails`
      }
      ArrayDesignValueObjectObject
    },
    #' Deserialize JSON string into an instance of ArrayDesignValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ArrayDesignValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ArrayDesignValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`lastUpdated`)) {
        self$`lastUpdated` <- this_object$`lastUpdated`
      }
      if (!is.null(this_object$`troubled`)) {
        self$`troubled` <- this_object$`troubled`
      }
      if (!is.null(this_object$`lastTroubledEvent`)) {
        lasttroubledevent_object <- AuditEventValueObject$new()
        lasttroubledevent_object$fromJSON(jsonlite::toJSON(this_object$lastTroubledEvent, auto_unbox = TRUE, digits = NA))
        self$`lastTroubledEvent` <- lasttroubledevent_object
      }
      if (!is.null(this_object$`needsAttention`)) {
        self$`needsAttention` <- this_object$`needsAttention`
      }
      if (!is.null(this_object$`lastNeedsAttentionEvent`)) {
        lastneedsattentionevent_object <- AuditEventValueObject$new()
        lastneedsattentionevent_object$fromJSON(jsonlite::toJSON(this_object$lastNeedsAttentionEvent, auto_unbox = TRUE, digits = NA))
        self$`lastNeedsAttentionEvent` <- lastneedsattentionevent_object
      }
      if (!is.null(this_object$`curationNote`)) {
        self$`curationNote` <- this_object$`curationNote`
      }
      if (!is.null(this_object$`lastNoteUpdateEvent`)) {
        lastnoteupdateevent_object <- AuditEventValueObject$new()
        lastnoteupdateevent_object$fromJSON(jsonlite::toJSON(this_object$lastNoteUpdateEvent, auto_unbox = TRUE, digits = NA))
        self$`lastNoteUpdateEvent` <- lastnoteupdateevent_object
      }
      if (!is.null(this_object$`blackListed`)) {
        self$`blackListed` <- this_object$`blackListed`
      }
      if (!is.null(this_object$`color`)) {
        self$`color` <- this_object$`color`
      }
      if (!is.null(this_object$`dateCached`)) {
        self$`dateCached` <- this_object$`dateCached`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`designElementCount`)) {
        self$`designElementCount` <- this_object$`designElementCount`
      }
      if (!is.null(this_object$`expressionExperimentCount`)) {
        self$`expressionExperimentCount` <- this_object$`expressionExperimentCount`
      }
      if (!is.null(this_object$`hasBlatAssociations`)) {
        self$`hasBlatAssociations` <- this_object$`hasBlatAssociations`
      }
      if (!is.null(this_object$`hasGeneAssociations`)) {
        self$`hasGeneAssociations` <- this_object$`hasGeneAssociations`
      }
      if (!is.null(this_object$`hasSequenceAssociations`)) {
        self$`hasSequenceAssociations` <- this_object$`hasSequenceAssociations`
      }
      if (!is.null(this_object$`isAffymetrixAltCdf`)) {
        self$`isAffymetrixAltCdf` <- this_object$`isAffymetrixAltCdf`
      }
      if (!is.null(this_object$`isMerged`)) {
        self$`isMerged` <- this_object$`isMerged`
      }
      if (!is.null(this_object$`isMergee`)) {
        self$`isMergee` <- this_object$`isMergee`
      }
      if (!is.null(this_object$`isSubsumed`)) {
        self$`isSubsumed` <- this_object$`isSubsumed`
      }
      if (!is.null(this_object$`isSubsumer`)) {
        self$`isSubsumer` <- this_object$`isSubsumer`
      }
      if (!is.null(this_object$`lastGeneMapping`)) {
        self$`lastGeneMapping` <- this_object$`lastGeneMapping`
      }
      if (!is.null(this_object$`lastRepeatMask`)) {
        self$`lastRepeatMask` <- this_object$`lastRepeatMask`
      }
      if (!is.null(this_object$`lastSequenceAnalysis`)) {
        self$`lastSequenceAnalysis` <- this_object$`lastSequenceAnalysis`
      }
      if (!is.null(this_object$`lastSequenceUpdate`)) {
        self$`lastSequenceUpdate` <- this_object$`lastSequenceUpdate`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`numGenes`)) {
        self$`numGenes` <- this_object$`numGenes`
      }
      if (!is.null(this_object$`numProbeAlignments`)) {
        self$`numProbeAlignments` <- this_object$`numProbeAlignments`
      }
      if (!is.null(this_object$`numProbeSequences`)) {
        self$`numProbeSequences` <- this_object$`numProbeSequences`
      }
      if (!is.null(this_object$`numProbesToGenes`)) {
        self$`numProbesToGenes` <- this_object$`numProbesToGenes`
      }
      if (!is.null(this_object$`shortName`)) {
        self$`shortName` <- this_object$`shortName`
      }
      if (!is.null(this_object$`switchedExpressionExperimentCount`)) {
        self$`switchedExpressionExperimentCount` <- this_object$`switchedExpressionExperimentCount`
      }
      if (!is.null(this_object$`taxon`)) {
        self$`taxon` <- this_object$`taxon`
      }
      if (!is.null(this_object$`taxonID`)) {
        self$`taxonID` <- this_object$`taxonID`
      }
      if (!is.null(this_object$`technologyType`)) {
        self$`technologyType` <- this_object$`technologyType`
      }
      if (!is.null(this_object$`troubleDetails`)) {
        self$`troubleDetails` <- this_object$`troubleDetails`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ArrayDesignValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`lastUpdated`)) {
          sprintf(
          '"lastUpdated":
            "%s"
                    ',
          self$`lastUpdated`
          )
        },
        if (!is.null(self$`troubled`)) {
          sprintf(
          '"troubled":
            %s
                    ',
          tolower(self$`troubled`)
          )
        },
        if (!is.null(self$`lastTroubledEvent`)) {
          sprintf(
          '"lastTroubledEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastTroubledEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`needsAttention`)) {
          sprintf(
          '"needsAttention":
            %s
                    ',
          tolower(self$`needsAttention`)
          )
        },
        if (!is.null(self$`lastNeedsAttentionEvent`)) {
          sprintf(
          '"lastNeedsAttentionEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastNeedsAttentionEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`curationNote`)) {
          sprintf(
          '"curationNote":
            "%s"
                    ',
          self$`curationNote`
          )
        },
        if (!is.null(self$`lastNoteUpdateEvent`)) {
          sprintf(
          '"lastNoteUpdateEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastNoteUpdateEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`blackListed`)) {
          sprintf(
          '"blackListed":
            %s
                    ',
          tolower(self$`blackListed`)
          )
        },
        if (!is.null(self$`color`)) {
          sprintf(
          '"color":
            "%s"
                    ',
          self$`color`
          )
        },
        if (!is.null(self$`dateCached`)) {
          sprintf(
          '"dateCached":
            "%s"
                    ',
          self$`dateCached`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`designElementCount`)) {
          sprintf(
          '"designElementCount":
            %d
                    ',
          self$`designElementCount`
          )
        },
        if (!is.null(self$`expressionExperimentCount`)) {
          sprintf(
          '"expressionExperimentCount":
            %d
                    ',
          self$`expressionExperimentCount`
          )
        },
        if (!is.null(self$`hasBlatAssociations`)) {
          sprintf(
          '"hasBlatAssociations":
            %s
                    ',
          tolower(self$`hasBlatAssociations`)
          )
        },
        if (!is.null(self$`hasGeneAssociations`)) {
          sprintf(
          '"hasGeneAssociations":
            %s
                    ',
          tolower(self$`hasGeneAssociations`)
          )
        },
        if (!is.null(self$`hasSequenceAssociations`)) {
          sprintf(
          '"hasSequenceAssociations":
            %s
                    ',
          tolower(self$`hasSequenceAssociations`)
          )
        },
        if (!is.null(self$`isAffymetrixAltCdf`)) {
          sprintf(
          '"isAffymetrixAltCdf":
            %s
                    ',
          tolower(self$`isAffymetrixAltCdf`)
          )
        },
        if (!is.null(self$`isMerged`)) {
          sprintf(
          '"isMerged":
            %s
                    ',
          tolower(self$`isMerged`)
          )
        },
        if (!is.null(self$`isMergee`)) {
          sprintf(
          '"isMergee":
            %s
                    ',
          tolower(self$`isMergee`)
          )
        },
        if (!is.null(self$`isSubsumed`)) {
          sprintf(
          '"isSubsumed":
            %s
                    ',
          tolower(self$`isSubsumed`)
          )
        },
        if (!is.null(self$`isSubsumer`)) {
          sprintf(
          '"isSubsumer":
            %s
                    ',
          tolower(self$`isSubsumer`)
          )
        },
        if (!is.null(self$`lastGeneMapping`)) {
          sprintf(
          '"lastGeneMapping":
            "%s"
                    ',
          self$`lastGeneMapping`
          )
        },
        if (!is.null(self$`lastRepeatMask`)) {
          sprintf(
          '"lastRepeatMask":
            "%s"
                    ',
          self$`lastRepeatMask`
          )
        },
        if (!is.null(self$`lastSequenceAnalysis`)) {
          sprintf(
          '"lastSequenceAnalysis":
            "%s"
                    ',
          self$`lastSequenceAnalysis`
          )
        },
        if (!is.null(self$`lastSequenceUpdate`)) {
          sprintf(
          '"lastSequenceUpdate":
            "%s"
                    ',
          self$`lastSequenceUpdate`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`numGenes`)) {
          sprintf(
          '"numGenes":
            "%s"
                    ',
          self$`numGenes`
          )
        },
        if (!is.null(self$`numProbeAlignments`)) {
          sprintf(
          '"numProbeAlignments":
            "%s"
                    ',
          self$`numProbeAlignments`
          )
        },
        if (!is.null(self$`numProbeSequences`)) {
          sprintf(
          '"numProbeSequences":
            "%s"
                    ',
          self$`numProbeSequences`
          )
        },
        if (!is.null(self$`numProbesToGenes`)) {
          sprintf(
          '"numProbesToGenes":
            "%s"
                    ',
          self$`numProbesToGenes`
          )
        },
        if (!is.null(self$`shortName`)) {
          sprintf(
          '"shortName":
            "%s"
                    ',
          self$`shortName`
          )
        },
        if (!is.null(self$`switchedExpressionExperimentCount`)) {
          sprintf(
          '"switchedExpressionExperimentCount":
            %d
                    ',
          self$`switchedExpressionExperimentCount`
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
            "%s"
                    ',
          self$`taxon`
          )
        },
        if (!is.null(self$`taxonID`)) {
          sprintf(
          '"taxonID":
            %d
                    ',
          self$`taxonID`
          )
        },
        if (!is.null(self$`technologyType`)) {
          sprintf(
          '"technologyType":
            "%s"
                    ',
          self$`technologyType`
          )
        },
        if (!is.null(self$`troubleDetails`)) {
          sprintf(
          '"troubleDetails":
            "%s"
                    ',
          self$`troubleDetails`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ArrayDesignValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ArrayDesignValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ArrayDesignValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`lastUpdated` <- this_object$`lastUpdated`
      self$`troubled` <- this_object$`troubled`
      self$`lastTroubledEvent` <- AuditEventValueObject$new()$fromJSON(jsonlite::toJSON(this_object$lastTroubledEvent, auto_unbox = TRUE, digits = NA))
      self$`needsAttention` <- this_object$`needsAttention`
      self$`lastNeedsAttentionEvent` <- AuditEventValueObject$new()$fromJSON(jsonlite::toJSON(this_object$lastNeedsAttentionEvent, auto_unbox = TRUE, digits = NA))
      self$`curationNote` <- this_object$`curationNote`
      self$`lastNoteUpdateEvent` <- AuditEventValueObject$new()$fromJSON(jsonlite::toJSON(this_object$lastNoteUpdateEvent, auto_unbox = TRUE, digits = NA))
      self$`blackListed` <- this_object$`blackListed`
      self$`color` <- this_object$`color`
      self$`dateCached` <- this_object$`dateCached`
      self$`description` <- this_object$`description`
      self$`designElementCount` <- this_object$`designElementCount`
      self$`expressionExperimentCount` <- this_object$`expressionExperimentCount`
      self$`hasBlatAssociations` <- this_object$`hasBlatAssociations`
      self$`hasGeneAssociations` <- this_object$`hasGeneAssociations`
      self$`hasSequenceAssociations` <- this_object$`hasSequenceAssociations`
      self$`isAffymetrixAltCdf` <- this_object$`isAffymetrixAltCdf`
      self$`isMerged` <- this_object$`isMerged`
      self$`isMergee` <- this_object$`isMergee`
      self$`isSubsumed` <- this_object$`isSubsumed`
      self$`isSubsumer` <- this_object$`isSubsumer`
      self$`lastGeneMapping` <- this_object$`lastGeneMapping`
      self$`lastRepeatMask` <- this_object$`lastRepeatMask`
      self$`lastSequenceAnalysis` <- this_object$`lastSequenceAnalysis`
      self$`lastSequenceUpdate` <- this_object$`lastSequenceUpdate`
      self$`name` <- this_object$`name`
      self$`numGenes` <- this_object$`numGenes`
      self$`numProbeAlignments` <- this_object$`numProbeAlignments`
      self$`numProbeSequences` <- this_object$`numProbeSequences`
      self$`numProbesToGenes` <- this_object$`numProbesToGenes`
      self$`shortName` <- this_object$`shortName`
      self$`switchedExpressionExperimentCount` <- this_object$`switchedExpressionExperimentCount`
      self$`taxon` <- this_object$`taxon`
      self$`taxonID` <- this_object$`taxonID`
      self$`technologyType` <- this_object$`technologyType`
      self$`troubleDetails` <- this_object$`troubleDetails`
      self
    },
    #' Validate JSON input with respect to ArrayDesignValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ArrayDesignValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ArrayDesignValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ArrayDesignValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ArrayDesignValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ArrayDesignValueObject$lock()


#' Create a new AuditAction
#'
#' @description
#' AuditAction Class
#'
#' @docType class
#' @title AuditAction
#' @description AuditAction Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AuditAction <- R6::R6Class(
  "AuditAction",
  public = list(
    `value` = NULL,
    #' Initialize a new AuditAction class.
    #'
    #' @description
    #' Initialize a new AuditAction class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditAction in JSON format
    #' @keywords internal
    toJSON = function() {
      AuditActionObject <- list()
      if (!is.null(self$`value`)) {
        AuditActionObject[["value"]] <-
          self$`value`
      }
      AuditActionObject
    },
    #' Deserialize JSON string into an instance of AuditAction
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditAction
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditAction
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditAction in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AuditAction
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditAction
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditAction
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to AuditAction
    #'
    #' @description
    #' Validate JSON input with respect to AuditAction and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AuditAction
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AuditAction$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AuditAction$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AuditAction$lock()


#' Create a new AuditEvent
#'
#' @description
#' AuditEvent Class
#'
#' @docType class
#' @title AuditEvent
#' @description AuditEvent Class
#' @format An \code{R6Class} generator object
#' @field action  \link{AuditAction} optional
#' @field date  character optional
#' @field detail  character optional
#' @field eventType  \link{AuditEventType} optional
#' @field id  integer optional
#' @field note  character optional
#' @field performer  \link{User} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AuditEvent <- R6::R6Class(
  "AuditEvent",
  public = list(
    `action` = NULL,
    `date` = NULL,
    `detail` = NULL,
    `eventType` = NULL,
    `id` = NULL,
    `note` = NULL,
    `performer` = NULL,
    #' Initialize a new AuditEvent class.
    #'
    #' @description
    #' Initialize a new AuditEvent class.
    #'
    #' @param action action
    #' @param date date
    #' @param detail detail
    #' @param eventType eventType
    #' @param id id
    #' @param note note
    #' @param performer performer
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `action` = NULL, `date` = NULL, `detail` = NULL, `eventType` = NULL, `id` = NULL, `note` = NULL, `performer` = NULL, ...
    ) {
      if (!is.null(`action`)) {
        stopifnot(R6::is.R6(`action`))
        self$`action` <- `action`
      }
      if (!is.null(`date`)) {
        stopifnot(is.character(`date`), length(`date`) == 1)
        self$`date` <- `date`
      }
      if (!is.null(`detail`)) {
        stopifnot(is.character(`detail`), length(`detail`) == 1)
        self$`detail` <- `detail`
      }
      if (!is.null(`eventType`)) {
        stopifnot(R6::is.R6(`eventType`))
        self$`eventType` <- `eventType`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`note`)) {
        stopifnot(is.character(`note`), length(`note`) == 1)
        self$`note` <- `note`
      }
      if (!is.null(`performer`)) {
        stopifnot(R6::is.R6(`performer`))
        self$`performer` <- `performer`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditEvent in JSON format
    #' @keywords internal
    toJSON = function() {
      AuditEventObject <- list()
      if (!is.null(self$`action`)) {
        AuditEventObject[["action"]] <-
          self$`action`$toJSON()
      }
      if (!is.null(self$`date`)) {
        AuditEventObject[["date"]] <-
          self$`date`
      }
      if (!is.null(self$`detail`)) {
        AuditEventObject[["detail"]] <-
          self$`detail`
      }
      if (!is.null(self$`eventType`)) {
        AuditEventObject[["eventType"]] <-
          self$`eventType`$toJSON()
      }
      if (!is.null(self$`id`)) {
        AuditEventObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`note`)) {
        AuditEventObject[["note"]] <-
          self$`note`
      }
      if (!is.null(self$`performer`)) {
        AuditEventObject[["performer"]] <-
          self$`performer`$toJSON()
      }
      AuditEventObject
    },
    #' Deserialize JSON string into an instance of AuditEvent
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditEvent
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditEvent
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`action`)) {
        action_object <- AuditAction$new()
        action_object$fromJSON(jsonlite::toJSON(this_object$action, auto_unbox = TRUE, digits = NA))
        self$`action` <- action_object
      }
      if (!is.null(this_object$`date`)) {
        self$`date` <- this_object$`date`
      }
      if (!is.null(this_object$`detail`)) {
        self$`detail` <- this_object$`detail`
      }
      if (!is.null(this_object$`eventType`)) {
        eventtype_object <- AuditEventType$new()
        eventtype_object$fromJSON(jsonlite::toJSON(this_object$eventType, auto_unbox = TRUE, digits = NA))
        self$`eventType` <- eventtype_object
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`note`)) {
        self$`note` <- this_object$`note`
      }
      if (!is.null(this_object$`performer`)) {
        performer_object <- User$new()
        performer_object$fromJSON(jsonlite::toJSON(this_object$performer, auto_unbox = TRUE, digits = NA))
        self$`performer` <- performer_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditEvent in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`action`)) {
          sprintf(
          '"action":
          %s
          ',
          jsonlite::toJSON(self$`action`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`date`)) {
          sprintf(
          '"date":
            "%s"
                    ',
          self$`date`
          )
        },
        if (!is.null(self$`detail`)) {
          sprintf(
          '"detail":
            "%s"
                    ',
          self$`detail`
          )
        },
        if (!is.null(self$`eventType`)) {
          sprintf(
          '"eventType":
          %s
          ',
          jsonlite::toJSON(self$`eventType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`note`)) {
          sprintf(
          '"note":
            "%s"
                    ',
          self$`note`
          )
        },
        if (!is.null(self$`performer`)) {
          sprintf(
          '"performer":
          %s
          ',
          jsonlite::toJSON(self$`performer`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AuditEvent
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditEvent
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditEvent
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`action` <- AuditAction$new()$fromJSON(jsonlite::toJSON(this_object$action, auto_unbox = TRUE, digits = NA))
      self$`date` <- this_object$`date`
      self$`detail` <- this_object$`detail`
      self$`eventType` <- AuditEventType$new()$fromJSON(jsonlite::toJSON(this_object$eventType, auto_unbox = TRUE, digits = NA))
      self$`id` <- this_object$`id`
      self$`note` <- this_object$`note`
      self$`performer` <- User$new()$fromJSON(jsonlite::toJSON(this_object$performer, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to AuditEvent
    #'
    #' @description
    #' Validate JSON input with respect to AuditEvent and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AuditEvent
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AuditEvent$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AuditEvent$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AuditEvent$lock()


#' Create a new AuditEventType
#'
#' @description
#' AuditEventType Class
#'
#' @docType class
#' @title AuditEventType
#' @description AuditEventType Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AuditEventType <- R6::R6Class(
  "AuditEventType",
  public = list(
    `id` = NULL,
    #' Initialize a new AuditEventType class.
    #'
    #' @description
    #' Initialize a new AuditEventType class.
    #'
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditEventType in JSON format
    #' @keywords internal
    toJSON = function() {
      AuditEventTypeObject <- list()
      if (!is.null(self$`id`)) {
        AuditEventTypeObject[["id"]] <-
          self$`id`
      }
      AuditEventTypeObject
    },
    #' Deserialize JSON string into an instance of AuditEventType
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditEventType
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditEventType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditEventType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AuditEventType
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditEventType
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditEventType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to AuditEventType
    #'
    #' @description
    #' Validate JSON input with respect to AuditEventType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AuditEventType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AuditEventType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AuditEventType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AuditEventType$lock()


#' Create a new AuditEventValueObject
#'
#' @description
#' AuditEventValueObject Class
#'
#' @docType class
#' @title AuditEventValueObject
#' @description AuditEventValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field performer  character optional
#' @field date  character optional
#' @field action  character optional
#' @field note  character optional
#' @field detail  character optional
#' @field eventType  \link{AuditEventType} optional
#' @field actionName  character optional
#' @field eventTypeName  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AuditEventValueObject <- R6::R6Class(
  "AuditEventValueObject",
  public = list(
    `id` = NULL,
    `performer` = NULL,
    `date` = NULL,
    `action` = NULL,
    `note` = NULL,
    `detail` = NULL,
    `eventType` = NULL,
    `actionName` = NULL,
    `eventTypeName` = NULL,
    #' Initialize a new AuditEventValueObject class.
    #'
    #' @description
    #' Initialize a new AuditEventValueObject class.
    #'
    #' @param id id
    #' @param performer performer
    #' @param date date
    #' @param action action
    #' @param note note
    #' @param detail detail
    #' @param eventType eventType
    #' @param actionName actionName
    #' @param eventTypeName eventTypeName
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `performer` = NULL, `date` = NULL, `action` = NULL, `note` = NULL, `detail` = NULL, `eventType` = NULL, `actionName` = NULL, `eventTypeName` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`performer`)) {
        stopifnot(is.character(`performer`), length(`performer`) == 1)
        self$`performer` <- `performer`
      }
      if (!is.null(`date`)) {
        stopifnot(is.character(`date`), length(`date`) == 1)
        self$`date` <- `date`
      }
      if (!is.null(`action`)) {
        stopifnot(is.character(`action`), length(`action`) == 1)
        self$`action` <- `action`
      }
      if (!is.null(`note`)) {
        stopifnot(is.character(`note`), length(`note`) == 1)
        self$`note` <- `note`
      }
      if (!is.null(`detail`)) {
        stopifnot(is.character(`detail`), length(`detail`) == 1)
        self$`detail` <- `detail`
      }
      if (!is.null(`eventType`)) {
        stopifnot(R6::is.R6(`eventType`))
        self$`eventType` <- `eventType`
      }
      if (!is.null(`actionName`)) {
        stopifnot(is.character(`actionName`), length(`actionName`) == 1)
        self$`actionName` <- `actionName`
      }
      if (!is.null(`eventTypeName`)) {
        stopifnot(is.character(`eventTypeName`), length(`eventTypeName`) == 1)
        self$`eventTypeName` <- `eventTypeName`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditEventValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      AuditEventValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        AuditEventValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`performer`)) {
        AuditEventValueObjectObject[["performer"]] <-
          self$`performer`
      }
      if (!is.null(self$`date`)) {
        AuditEventValueObjectObject[["date"]] <-
          self$`date`
      }
      if (!is.null(self$`action`)) {
        AuditEventValueObjectObject[["action"]] <-
          self$`action`
      }
      if (!is.null(self$`note`)) {
        AuditEventValueObjectObject[["note"]] <-
          self$`note`
      }
      if (!is.null(self$`detail`)) {
        AuditEventValueObjectObject[["detail"]] <-
          self$`detail`
      }
      if (!is.null(self$`eventType`)) {
        AuditEventValueObjectObject[["eventType"]] <-
          self$`eventType`$toJSON()
      }
      if (!is.null(self$`actionName`)) {
        AuditEventValueObjectObject[["actionName"]] <-
          self$`actionName`
      }
      if (!is.null(self$`eventTypeName`)) {
        AuditEventValueObjectObject[["eventTypeName"]] <-
          self$`eventTypeName`
      }
      AuditEventValueObjectObject
    },
    #' Deserialize JSON string into an instance of AuditEventValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditEventValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditEventValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`performer`)) {
        self$`performer` <- this_object$`performer`
      }
      if (!is.null(this_object$`date`)) {
        self$`date` <- this_object$`date`
      }
      if (!is.null(this_object$`action`)) {
        self$`action` <- this_object$`action`
      }
      if (!is.null(this_object$`note`)) {
        self$`note` <- this_object$`note`
      }
      if (!is.null(this_object$`detail`)) {
        self$`detail` <- this_object$`detail`
      }
      if (!is.null(this_object$`eventType`)) {
        eventtype_object <- AuditEventType$new()
        eventtype_object$fromJSON(jsonlite::toJSON(this_object$eventType, auto_unbox = TRUE, digits = NA))
        self$`eventType` <- eventtype_object
      }
      if (!is.null(this_object$`actionName`)) {
        self$`actionName` <- this_object$`actionName`
      }
      if (!is.null(this_object$`eventTypeName`)) {
        self$`eventTypeName` <- this_object$`eventTypeName`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditEventValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`performer`)) {
          sprintf(
          '"performer":
            "%s"
                    ',
          self$`performer`
          )
        },
        if (!is.null(self$`date`)) {
          sprintf(
          '"date":
            "%s"
                    ',
          self$`date`
          )
        },
        if (!is.null(self$`action`)) {
          sprintf(
          '"action":
            "%s"
                    ',
          self$`action`
          )
        },
        if (!is.null(self$`note`)) {
          sprintf(
          '"note":
            "%s"
                    ',
          self$`note`
          )
        },
        if (!is.null(self$`detail`)) {
          sprintf(
          '"detail":
            "%s"
                    ',
          self$`detail`
          )
        },
        if (!is.null(self$`eventType`)) {
          sprintf(
          '"eventType":
          %s
          ',
          jsonlite::toJSON(self$`eventType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`actionName`)) {
          sprintf(
          '"actionName":
            "%s"
                    ',
          self$`actionName`
          )
        },
        if (!is.null(self$`eventTypeName`)) {
          sprintf(
          '"eventTypeName":
            "%s"
                    ',
          self$`eventTypeName`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AuditEventValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditEventValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditEventValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`performer` <- this_object$`performer`
      self$`date` <- this_object$`date`
      self$`action` <- this_object$`action`
      self$`note` <- this_object$`note`
      self$`detail` <- this_object$`detail`
      self$`eventType` <- AuditEventType$new()$fromJSON(jsonlite::toJSON(this_object$eventType, auto_unbox = TRUE, digits = NA))
      self$`actionName` <- this_object$`actionName`
      self$`eventTypeName` <- this_object$`eventTypeName`
      self
    },
    #' Validate JSON input with respect to AuditEventValueObject
    #'
    #' @description
    #' Validate JSON input with respect to AuditEventValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AuditEventValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AuditEventValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AuditEventValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AuditEventValueObject$lock()


#' Create a new AuditTrail
#'
#' @description
#' AuditTrail Class
#'
#' @docType class
#' @title AuditTrail
#' @description AuditTrail Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field events  list(\link{AuditEvent}) optional
#' @field creationEvent  \link{AuditEvent} optional
#' @field last  \link{AuditEvent} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
AuditTrail <- R6::R6Class(
  "AuditTrail",
  public = list(
    `id` = NULL,
    `events` = NULL,
    `creationEvent` = NULL,
    `last` = NULL,
    #' Initialize a new AuditTrail class.
    #'
    #' @description
    #' Initialize a new AuditTrail class.
    #'
    #' @param id id
    #' @param events events
    #' @param creationEvent creationEvent
    #' @param last last
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `events` = NULL, `creationEvent` = NULL, `last` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`events`)) {
        stopifnot(is.vector(`events`), length(`events`) != 0)
        sapply(`events`, function(x) stopifnot(R6::is.R6(x)))
        self$`events` <- `events`
      }
      if (!is.null(`creationEvent`)) {
        stopifnot(R6::is.R6(`creationEvent`))
        self$`creationEvent` <- `creationEvent`
      }
      if (!is.null(`last`)) {
        stopifnot(R6::is.R6(`last`))
        self$`last` <- `last`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditTrail in JSON format
    #' @keywords internal
    toJSON = function() {
      AuditTrailObject <- list()
      if (!is.null(self$`id`)) {
        AuditTrailObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`events`)) {
        AuditTrailObject[["events"]] <-
          lapply(self$`events`, function(x) x$toJSON())
      }
      if (!is.null(self$`creationEvent`)) {
        AuditTrailObject[["creationEvent"]] <-
          self$`creationEvent`$toJSON()
      }
      if (!is.null(self$`last`)) {
        AuditTrailObject[["last"]] <-
          self$`last`$toJSON()
      }
      AuditTrailObject
    },
    #' Deserialize JSON string into an instance of AuditTrail
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditTrail
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditTrail
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`events`)) {
        self$`events` <- ApiClient$new()$deserializeObj(this_object$`events`, "array[AuditEvent]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`creationEvent`)) {
        creationevent_object <- AuditEvent$new()
        creationevent_object$fromJSON(jsonlite::toJSON(this_object$creationEvent, auto_unbox = TRUE, digits = NA))
        self$`creationEvent` <- creationevent_object
      }
      if (!is.null(this_object$`last`)) {
        last_object <- AuditEvent$new()
        last_object$fromJSON(jsonlite::toJSON(this_object$last, auto_unbox = TRUE, digits = NA))
        self$`last` <- last_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return AuditTrail in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`events`)) {
          sprintf(
          '"events":
          [%s]
',
          paste(sapply(self$`events`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`creationEvent`)) {
          sprintf(
          '"creationEvent":
          %s
          ',
          jsonlite::toJSON(self$`creationEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`last`)) {
          sprintf(
          '"last":
          %s
          ',
          jsonlite::toJSON(self$`last`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of AuditTrail
    #'
    #' @description
    #' Deserialize JSON string into an instance of AuditTrail
    #'
    #' @param input_json the JSON input
    #' @return the instance of AuditTrail
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`events` <- ApiClient$new()$deserializeObj(this_object$`events`, "array[AuditEvent]", loadNamespace("gemma.R"))
      self$`creationEvent` <- AuditEvent$new()$fromJSON(jsonlite::toJSON(this_object$creationEvent, auto_unbox = TRUE, digits = NA))
      self$`last` <- AuditEvent$new()$fromJSON(jsonlite::toJSON(this_object$last, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to AuditTrail
    #'
    #' @description
    #' Validate JSON input with respect to AuditTrail and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of AuditTrail
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
AuditTrail$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
AuditTrail$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
AuditTrail$lock()


#' Create a new BibliographicReference
#'
#' @description
#' BibliographicReference Class
#'
#' @docType class
#' @title BibliographicReference
#' @description BibliographicReference Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field authorList  character optional
#' @field title  character optional
#' @field publisher  character optional
#' @field editor  character optional
#' @field volume  character optional
#' @field issue  character optional
#' @field pages  character optional
#' @field publication  character optional
#' @field fullTextUri  character optional
#' @field abstractText  character optional
#' @field citation  character optional
#' @field publicationDate  character optional
#' @field annotatedAbstract  character optional
#' @field pubAccession  \link{DatabaseEntry} optional
#' @field retracted  character optional
#' @field annotations  list(\link{Characteristic}) optional
#' @field meshTerms  list(\link{MedicalSubjectHeading}) optional
#' @field keywords  list(\link{Keyword}) optional
#' @field chemicals  list(\link{Compound}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
BibliographicReference <- R6::R6Class(
  "BibliographicReference",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `authorList` = NULL,
    `title` = NULL,
    `publisher` = NULL,
    `editor` = NULL,
    `volume` = NULL,
    `issue` = NULL,
    `pages` = NULL,
    `publication` = NULL,
    `fullTextUri` = NULL,
    `abstractText` = NULL,
    `citation` = NULL,
    `publicationDate` = NULL,
    `annotatedAbstract` = NULL,
    `pubAccession` = NULL,
    `retracted` = NULL,
    `annotations` = NULL,
    `meshTerms` = NULL,
    `keywords` = NULL,
    `chemicals` = NULL,
    #' Initialize a new BibliographicReference class.
    #'
    #' @description
    #' Initialize a new BibliographicReference class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param authorList authorList
    #' @param title title
    #' @param publisher publisher
    #' @param editor editor
    #' @param volume volume
    #' @param issue issue
    #' @param pages pages
    #' @param publication publication
    #' @param fullTextUri fullTextUri
    #' @param abstractText abstractText
    #' @param citation citation
    #' @param publicationDate publicationDate
    #' @param annotatedAbstract annotatedAbstract
    #' @param pubAccession pubAccession
    #' @param retracted retracted
    #' @param annotations annotations
    #' @param meshTerms meshTerms
    #' @param keywords keywords
    #' @param chemicals chemicals
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `authorList` = NULL, `title` = NULL, `publisher` = NULL, `editor` = NULL, `volume` = NULL, `issue` = NULL, `pages` = NULL, `publication` = NULL, `fullTextUri` = NULL, `abstractText` = NULL, `citation` = NULL, `publicationDate` = NULL, `annotatedAbstract` = NULL, `pubAccession` = NULL, `retracted` = NULL, `annotations` = NULL, `meshTerms` = NULL, `keywords` = NULL, `chemicals` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`authorList`)) {
        stopifnot(is.character(`authorList`), length(`authorList`) == 1)
        self$`authorList` <- `authorList`
      }
      if (!is.null(`title`)) {
        stopifnot(is.character(`title`), length(`title`) == 1)
        self$`title` <- `title`
      }
      if (!is.null(`publisher`)) {
        stopifnot(is.character(`publisher`), length(`publisher`) == 1)
        self$`publisher` <- `publisher`
      }
      if (!is.null(`editor`)) {
        stopifnot(is.character(`editor`), length(`editor`) == 1)
        self$`editor` <- `editor`
      }
      if (!is.null(`volume`)) {
        stopifnot(is.character(`volume`), length(`volume`) == 1)
        self$`volume` <- `volume`
      }
      if (!is.null(`issue`)) {
        stopifnot(is.character(`issue`), length(`issue`) == 1)
        self$`issue` <- `issue`
      }
      if (!is.null(`pages`)) {
        stopifnot(is.character(`pages`), length(`pages`) == 1)
        self$`pages` <- `pages`
      }
      if (!is.null(`publication`)) {
        stopifnot(is.character(`publication`), length(`publication`) == 1)
        self$`publication` <- `publication`
      }
      if (!is.null(`fullTextUri`)) {
        stopifnot(is.character(`fullTextUri`), length(`fullTextUri`) == 1)
        self$`fullTextUri` <- `fullTextUri`
      }
      if (!is.null(`abstractText`)) {
        stopifnot(is.character(`abstractText`), length(`abstractText`) == 1)
        self$`abstractText` <- `abstractText`
      }
      if (!is.null(`citation`)) {
        stopifnot(is.character(`citation`), length(`citation`) == 1)
        self$`citation` <- `citation`
      }
      if (!is.null(`publicationDate`)) {
        stopifnot(is.character(`publicationDate`), length(`publicationDate`) == 1)
        self$`publicationDate` <- `publicationDate`
      }
      if (!is.null(`annotatedAbstract`)) {
        stopifnot(is.character(`annotatedAbstract`), length(`annotatedAbstract`) == 1)
        self$`annotatedAbstract` <- `annotatedAbstract`
      }
      if (!is.null(`pubAccession`)) {
        stopifnot(R6::is.R6(`pubAccession`))
        self$`pubAccession` <- `pubAccession`
      }
      if (!is.null(`retracted`)) {
        stopifnot(is.logical(`retracted`), length(`retracted`) == 1)
        self$`retracted` <- `retracted`
      }
      if (!is.null(`annotations`)) {
        stopifnot(is.vector(`annotations`), length(`annotations`) != 0)
        sapply(`annotations`, function(x) stopifnot(R6::is.R6(x)))
        self$`annotations` <- `annotations`
      }
      if (!is.null(`meshTerms`)) {
        stopifnot(is.vector(`meshTerms`), length(`meshTerms`) != 0)
        sapply(`meshTerms`, function(x) stopifnot(R6::is.R6(x)))
        self$`meshTerms` <- `meshTerms`
      }
      if (!is.null(`keywords`)) {
        stopifnot(is.vector(`keywords`), length(`keywords`) != 0)
        sapply(`keywords`, function(x) stopifnot(R6::is.R6(x)))
        self$`keywords` <- `keywords`
      }
      if (!is.null(`chemicals`)) {
        stopifnot(is.vector(`chemicals`), length(`chemicals`) != 0)
        sapply(`chemicals`, function(x) stopifnot(R6::is.R6(x)))
        self$`chemicals` <- `chemicals`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BibliographicReference in JSON format
    #' @keywords internal
    toJSON = function() {
      BibliographicReferenceObject <- list()
      if (!is.null(self$`name`)) {
        BibliographicReferenceObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        BibliographicReferenceObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        BibliographicReferenceObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`authorList`)) {
        BibliographicReferenceObject[["authorList"]] <-
          self$`authorList`
      }
      if (!is.null(self$`title`)) {
        BibliographicReferenceObject[["title"]] <-
          self$`title`
      }
      if (!is.null(self$`publisher`)) {
        BibliographicReferenceObject[["publisher"]] <-
          self$`publisher`
      }
      if (!is.null(self$`editor`)) {
        BibliographicReferenceObject[["editor"]] <-
          self$`editor`
      }
      if (!is.null(self$`volume`)) {
        BibliographicReferenceObject[["volume"]] <-
          self$`volume`
      }
      if (!is.null(self$`issue`)) {
        BibliographicReferenceObject[["issue"]] <-
          self$`issue`
      }
      if (!is.null(self$`pages`)) {
        BibliographicReferenceObject[["pages"]] <-
          self$`pages`
      }
      if (!is.null(self$`publication`)) {
        BibliographicReferenceObject[["publication"]] <-
          self$`publication`
      }
      if (!is.null(self$`fullTextUri`)) {
        BibliographicReferenceObject[["fullTextUri"]] <-
          self$`fullTextUri`
      }
      if (!is.null(self$`abstractText`)) {
        BibliographicReferenceObject[["abstractText"]] <-
          self$`abstractText`
      }
      if (!is.null(self$`citation`)) {
        BibliographicReferenceObject[["citation"]] <-
          self$`citation`
      }
      if (!is.null(self$`publicationDate`)) {
        BibliographicReferenceObject[["publicationDate"]] <-
          self$`publicationDate`
      }
      if (!is.null(self$`annotatedAbstract`)) {
        BibliographicReferenceObject[["annotatedAbstract"]] <-
          self$`annotatedAbstract`
      }
      if (!is.null(self$`pubAccession`)) {
        BibliographicReferenceObject[["pubAccession"]] <-
          self$`pubAccession`$toJSON()
      }
      if (!is.null(self$`retracted`)) {
        BibliographicReferenceObject[["retracted"]] <-
          self$`retracted`
      }
      if (!is.null(self$`annotations`)) {
        BibliographicReferenceObject[["annotations"]] <-
          lapply(self$`annotations`, function(x) x$toJSON())
      }
      if (!is.null(self$`meshTerms`)) {
        BibliographicReferenceObject[["meshTerms"]] <-
          lapply(self$`meshTerms`, function(x) x$toJSON())
      }
      if (!is.null(self$`keywords`)) {
        BibliographicReferenceObject[["keywords"]] <-
          lapply(self$`keywords`, function(x) x$toJSON())
      }
      if (!is.null(self$`chemicals`)) {
        BibliographicReferenceObject[["chemicals"]] <-
          lapply(self$`chemicals`, function(x) x$toJSON())
      }
      BibliographicReferenceObject
    },
    #' Deserialize JSON string into an instance of BibliographicReference
    #'
    #' @description
    #' Deserialize JSON string into an instance of BibliographicReference
    #'
    #' @param input_json the JSON input
    #' @return the instance of BibliographicReference
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`authorList`)) {
        self$`authorList` <- this_object$`authorList`
      }
      if (!is.null(this_object$`title`)) {
        self$`title` <- this_object$`title`
      }
      if (!is.null(this_object$`publisher`)) {
        self$`publisher` <- this_object$`publisher`
      }
      if (!is.null(this_object$`editor`)) {
        self$`editor` <- this_object$`editor`
      }
      if (!is.null(this_object$`volume`)) {
        self$`volume` <- this_object$`volume`
      }
      if (!is.null(this_object$`issue`)) {
        self$`issue` <- this_object$`issue`
      }
      if (!is.null(this_object$`pages`)) {
        self$`pages` <- this_object$`pages`
      }
      if (!is.null(this_object$`publication`)) {
        self$`publication` <- this_object$`publication`
      }
      if (!is.null(this_object$`fullTextUri`)) {
        self$`fullTextUri` <- this_object$`fullTextUri`
      }
      if (!is.null(this_object$`abstractText`)) {
        self$`abstractText` <- this_object$`abstractText`
      }
      if (!is.null(this_object$`citation`)) {
        self$`citation` <- this_object$`citation`
      }
      if (!is.null(this_object$`publicationDate`)) {
        self$`publicationDate` <- this_object$`publicationDate`
      }
      if (!is.null(this_object$`annotatedAbstract`)) {
        self$`annotatedAbstract` <- this_object$`annotatedAbstract`
      }
      if (!is.null(this_object$`pubAccession`)) {
        pubaccession_object <- DatabaseEntry$new()
        pubaccession_object$fromJSON(jsonlite::toJSON(this_object$pubAccession, auto_unbox = TRUE, digits = NA))
        self$`pubAccession` <- pubaccession_object
      }
      if (!is.null(this_object$`retracted`)) {
        self$`retracted` <- this_object$`retracted`
      }
      if (!is.null(this_object$`annotations`)) {
        self$`annotations` <- ApiClient$new()$deserializeObj(this_object$`annotations`, "set[Characteristic]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`meshTerms`)) {
        self$`meshTerms` <- ApiClient$new()$deserializeObj(this_object$`meshTerms`, "set[MedicalSubjectHeading]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`keywords`)) {
        self$`keywords` <- ApiClient$new()$deserializeObj(this_object$`keywords`, "set[Keyword]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`chemicals`)) {
        self$`chemicals` <- ApiClient$new()$deserializeObj(this_object$`chemicals`, "set[Compound]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BibliographicReference in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`authorList`)) {
          sprintf(
          '"authorList":
            "%s"
                    ',
          self$`authorList`
          )
        },
        if (!is.null(self$`title`)) {
          sprintf(
          '"title":
            "%s"
                    ',
          self$`title`
          )
        },
        if (!is.null(self$`publisher`)) {
          sprintf(
          '"publisher":
            "%s"
                    ',
          self$`publisher`
          )
        },
        if (!is.null(self$`editor`)) {
          sprintf(
          '"editor":
            "%s"
                    ',
          self$`editor`
          )
        },
        if (!is.null(self$`volume`)) {
          sprintf(
          '"volume":
            "%s"
                    ',
          self$`volume`
          )
        },
        if (!is.null(self$`issue`)) {
          sprintf(
          '"issue":
            "%s"
                    ',
          self$`issue`
          )
        },
        if (!is.null(self$`pages`)) {
          sprintf(
          '"pages":
            "%s"
                    ',
          self$`pages`
          )
        },
        if (!is.null(self$`publication`)) {
          sprintf(
          '"publication":
            "%s"
                    ',
          self$`publication`
          )
        },
        if (!is.null(self$`fullTextUri`)) {
          sprintf(
          '"fullTextUri":
            "%s"
                    ',
          self$`fullTextUri`
          )
        },
        if (!is.null(self$`abstractText`)) {
          sprintf(
          '"abstractText":
            "%s"
                    ',
          self$`abstractText`
          )
        },
        if (!is.null(self$`citation`)) {
          sprintf(
          '"citation":
            "%s"
                    ',
          self$`citation`
          )
        },
        if (!is.null(self$`publicationDate`)) {
          sprintf(
          '"publicationDate":
            "%s"
                    ',
          self$`publicationDate`
          )
        },
        if (!is.null(self$`annotatedAbstract`)) {
          sprintf(
          '"annotatedAbstract":
            "%s"
                    ',
          self$`annotatedAbstract`
          )
        },
        if (!is.null(self$`pubAccession`)) {
          sprintf(
          '"pubAccession":
          %s
          ',
          jsonlite::toJSON(self$`pubAccession`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`retracted`)) {
          sprintf(
          '"retracted":
            %s
                    ',
          tolower(self$`retracted`)
          )
        },
        if (!is.null(self$`annotations`)) {
          sprintf(
          '"annotations":
          [%s]
',
          paste(sapply(self$`annotations`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`meshTerms`)) {
          sprintf(
          '"meshTerms":
          [%s]
',
          paste(sapply(self$`meshTerms`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`keywords`)) {
          sprintf(
          '"keywords":
          [%s]
',
          paste(sapply(self$`keywords`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`chemicals`)) {
          sprintf(
          '"chemicals":
          [%s]
',
          paste(sapply(self$`chemicals`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of BibliographicReference
    #'
    #' @description
    #' Deserialize JSON string into an instance of BibliographicReference
    #'
    #' @param input_json the JSON input
    #' @return the instance of BibliographicReference
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`authorList` <- this_object$`authorList`
      self$`title` <- this_object$`title`
      self$`publisher` <- this_object$`publisher`
      self$`editor` <- this_object$`editor`
      self$`volume` <- this_object$`volume`
      self$`issue` <- this_object$`issue`
      self$`pages` <- this_object$`pages`
      self$`publication` <- this_object$`publication`
      self$`fullTextUri` <- this_object$`fullTextUri`
      self$`abstractText` <- this_object$`abstractText`
      self$`citation` <- this_object$`citation`
      self$`publicationDate` <- this_object$`publicationDate`
      self$`annotatedAbstract` <- this_object$`annotatedAbstract`
      self$`pubAccession` <- DatabaseEntry$new()$fromJSON(jsonlite::toJSON(this_object$pubAccession, auto_unbox = TRUE, digits = NA))
      self$`retracted` <- this_object$`retracted`
      self$`annotations` <- ApiClient$new()$deserializeObj(this_object$`annotations`, "set[Characteristic]", loadNamespace("gemma.R"))
      self$`meshTerms` <- ApiClient$new()$deserializeObj(this_object$`meshTerms`, "set[MedicalSubjectHeading]", loadNamespace("gemma.R"))
      self$`keywords` <- ApiClient$new()$deserializeObj(this_object$`keywords`, "set[Keyword]", loadNamespace("gemma.R"))
      self$`chemicals` <- ApiClient$new()$deserializeObj(this_object$`chemicals`, "set[Compound]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to BibliographicReference
    #'
    #' @description
    #' Validate JSON input with respect to BibliographicReference and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of BibliographicReference
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {




      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()




      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
BibliographicReference$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
BibliographicReference$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
BibliographicReference$lock()


#' Create a new BioAssayValueObject
#'
#' @description
#' BioAssayValueObject Class
#'
#' @docType class
#' @title BioAssayValueObject
#' @description BioAssayValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field accession  \link{DatabaseEntryValueObject} optional
#' @field arrayDesign  \link{ArrayDesignValueObject} optional
#' @field description  character optional
#' @field metadata  character optional
#' @field name  character optional
#' @field originalPlatform  \link{ArrayDesignValueObject} optional
#' @field outlier  character optional
#' @field predictedOutlier  character optional
#' @field processingDate  character optional
#' @field sample  \link{BioMaterialValueObject} optional
#' @field sequencePairedReads  character optional
#' @field sequenceReadCount  integer optional
#' @field sequenceReadLength  integer optional
#' @field userFlaggedOutlier  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
BioAssayValueObject <- R6::R6Class(
  "BioAssayValueObject",
  public = list(
    `id` = NULL,
    `accession` = NULL,
    `arrayDesign` = NULL,
    `description` = NULL,
    `metadata` = NULL,
    `name` = NULL,
    `originalPlatform` = NULL,
    `outlier` = NULL,
    `predictedOutlier` = NULL,
    `processingDate` = NULL,
    `sample` = NULL,
    `sequencePairedReads` = NULL,
    `sequenceReadCount` = NULL,
    `sequenceReadLength` = NULL,
    `userFlaggedOutlier` = NULL,
    #' Initialize a new BioAssayValueObject class.
    #'
    #' @description
    #' Initialize a new BioAssayValueObject class.
    #'
    #' @param id id
    #' @param accession accession
    #' @param arrayDesign arrayDesign
    #' @param description description
    #' @param metadata metadata
    #' @param name name
    #' @param originalPlatform originalPlatform
    #' @param outlier outlier
    #' @param predictedOutlier predictedOutlier
    #' @param processingDate processingDate
    #' @param sample sample
    #' @param sequencePairedReads sequencePairedReads
    #' @param sequenceReadCount sequenceReadCount
    #' @param sequenceReadLength sequenceReadLength
    #' @param userFlaggedOutlier userFlaggedOutlier
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `accession` = NULL, `arrayDesign` = NULL, `description` = NULL, `metadata` = NULL, `name` = NULL, `originalPlatform` = NULL, `outlier` = NULL, `predictedOutlier` = NULL, `processingDate` = NULL, `sample` = NULL, `sequencePairedReads` = NULL, `sequenceReadCount` = NULL, `sequenceReadLength` = NULL, `userFlaggedOutlier` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`accession`)) {
        stopifnot(R6::is.R6(`accession`))
        self$`accession` <- `accession`
      }
      if (!is.null(`arrayDesign`)) {
        stopifnot(R6::is.R6(`arrayDesign`))
        self$`arrayDesign` <- `arrayDesign`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`metadata`)) {
        stopifnot(is.character(`metadata`), length(`metadata`) == 1)
        self$`metadata` <- `metadata`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`originalPlatform`)) {
        stopifnot(R6::is.R6(`originalPlatform`))
        self$`originalPlatform` <- `originalPlatform`
      }
      if (!is.null(`outlier`)) {
        stopifnot(is.logical(`outlier`), length(`outlier`) == 1)
        self$`outlier` <- `outlier`
      }
      if (!is.null(`predictedOutlier`)) {
        stopifnot(is.logical(`predictedOutlier`), length(`predictedOutlier`) == 1)
        self$`predictedOutlier` <- `predictedOutlier`
      }
      if (!is.null(`processingDate`)) {
        stopifnot(is.character(`processingDate`), length(`processingDate`) == 1)
        self$`processingDate` <- `processingDate`
      }
      if (!is.null(`sample`)) {
        stopifnot(R6::is.R6(`sample`))
        self$`sample` <- `sample`
      }
      if (!is.null(`sequencePairedReads`)) {
        stopifnot(is.logical(`sequencePairedReads`), length(`sequencePairedReads`) == 1)
        self$`sequencePairedReads` <- `sequencePairedReads`
      }
      if (!is.null(`sequenceReadCount`)) {
        stopifnot(is.numeric(`sequenceReadCount`), length(`sequenceReadCount`) == 1)
        self$`sequenceReadCount` <- `sequenceReadCount`
      }
      if (!is.null(`sequenceReadLength`)) {
        stopifnot(is.numeric(`sequenceReadLength`), length(`sequenceReadLength`) == 1)
        self$`sequenceReadLength` <- `sequenceReadLength`
      }
      if (!is.null(`userFlaggedOutlier`)) {
        stopifnot(is.logical(`userFlaggedOutlier`), length(`userFlaggedOutlier`) == 1)
        self$`userFlaggedOutlier` <- `userFlaggedOutlier`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioAssayValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      BioAssayValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        BioAssayValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`accession`)) {
        BioAssayValueObjectObject[["accession"]] <-
          self$`accession`$toJSON()
      }
      if (!is.null(self$`arrayDesign`)) {
        BioAssayValueObjectObject[["arrayDesign"]] <-
          self$`arrayDesign`$toJSON()
      }
      if (!is.null(self$`description`)) {
        BioAssayValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`metadata`)) {
        BioAssayValueObjectObject[["metadata"]] <-
          self$`metadata`
      }
      if (!is.null(self$`name`)) {
        BioAssayValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`originalPlatform`)) {
        BioAssayValueObjectObject[["originalPlatform"]] <-
          self$`originalPlatform`$toJSON()
      }
      if (!is.null(self$`outlier`)) {
        BioAssayValueObjectObject[["outlier"]] <-
          self$`outlier`
      }
      if (!is.null(self$`predictedOutlier`)) {
        BioAssayValueObjectObject[["predictedOutlier"]] <-
          self$`predictedOutlier`
      }
      if (!is.null(self$`processingDate`)) {
        BioAssayValueObjectObject[["processingDate"]] <-
          self$`processingDate`
      }
      if (!is.null(self$`sample`)) {
        BioAssayValueObjectObject[["sample"]] <-
          self$`sample`$toJSON()
      }
      if (!is.null(self$`sequencePairedReads`)) {
        BioAssayValueObjectObject[["sequencePairedReads"]] <-
          self$`sequencePairedReads`
      }
      if (!is.null(self$`sequenceReadCount`)) {
        BioAssayValueObjectObject[["sequenceReadCount"]] <-
          self$`sequenceReadCount`
      }
      if (!is.null(self$`sequenceReadLength`)) {
        BioAssayValueObjectObject[["sequenceReadLength"]] <-
          self$`sequenceReadLength`
      }
      if (!is.null(self$`userFlaggedOutlier`)) {
        BioAssayValueObjectObject[["userFlaggedOutlier"]] <-
          self$`userFlaggedOutlier`
      }
      BioAssayValueObjectObject
    },
    #' Deserialize JSON string into an instance of BioAssayValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioAssayValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioAssayValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`accession`)) {
        accession_object <- DatabaseEntryValueObject$new()
        accession_object$fromJSON(jsonlite::toJSON(this_object$accession, auto_unbox = TRUE, digits = NA))
        self$`accession` <- accession_object
      }
      if (!is.null(this_object$`arrayDesign`)) {
        arraydesign_object <- ArrayDesignValueObject$new()
        arraydesign_object$fromJSON(jsonlite::toJSON(this_object$arrayDesign, auto_unbox = TRUE, digits = NA))
        self$`arrayDesign` <- arraydesign_object
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`metadata`)) {
        self$`metadata` <- this_object$`metadata`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`originalPlatform`)) {
        originalplatform_object <- ArrayDesignValueObject$new()
        originalplatform_object$fromJSON(jsonlite::toJSON(this_object$originalPlatform, auto_unbox = TRUE, digits = NA))
        self$`originalPlatform` <- originalplatform_object
      }
      if (!is.null(this_object$`outlier`)) {
        self$`outlier` <- this_object$`outlier`
      }
      if (!is.null(this_object$`predictedOutlier`)) {
        self$`predictedOutlier` <- this_object$`predictedOutlier`
      }
      if (!is.null(this_object$`processingDate`)) {
        self$`processingDate` <- this_object$`processingDate`
      }
      if (!is.null(this_object$`sample`)) {
        sample_object <- BioMaterialValueObject$new()
        sample_object$fromJSON(jsonlite::toJSON(this_object$sample, auto_unbox = TRUE, digits = NA))
        self$`sample` <- sample_object
      }
      if (!is.null(this_object$`sequencePairedReads`)) {
        self$`sequencePairedReads` <- this_object$`sequencePairedReads`
      }
      if (!is.null(this_object$`sequenceReadCount`)) {
        self$`sequenceReadCount` <- this_object$`sequenceReadCount`
      }
      if (!is.null(this_object$`sequenceReadLength`)) {
        self$`sequenceReadLength` <- this_object$`sequenceReadLength`
      }
      if (!is.null(this_object$`userFlaggedOutlier`)) {
        self$`userFlaggedOutlier` <- this_object$`userFlaggedOutlier`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioAssayValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`accession`)) {
          sprintf(
          '"accession":
          %s
          ',
          jsonlite::toJSON(self$`accession`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`arrayDesign`)) {
          sprintf(
          '"arrayDesign":
          %s
          ',
          jsonlite::toJSON(self$`arrayDesign`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`metadata`)) {
          sprintf(
          '"metadata":
            "%s"
                    ',
          self$`metadata`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`originalPlatform`)) {
          sprintf(
          '"originalPlatform":
          %s
          ',
          jsonlite::toJSON(self$`originalPlatform`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`outlier`)) {
          sprintf(
          '"outlier":
            %s
                    ',
          tolower(self$`outlier`)
          )
        },
        if (!is.null(self$`predictedOutlier`)) {
          sprintf(
          '"predictedOutlier":
            %s
                    ',
          tolower(self$`predictedOutlier`)
          )
        },
        if (!is.null(self$`processingDate`)) {
          sprintf(
          '"processingDate":
            "%s"
                    ',
          self$`processingDate`
          )
        },
        if (!is.null(self$`sample`)) {
          sprintf(
          '"sample":
          %s
          ',
          jsonlite::toJSON(self$`sample`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`sequencePairedReads`)) {
          sprintf(
          '"sequencePairedReads":
            %s
                    ',
          tolower(self$`sequencePairedReads`)
          )
        },
        if (!is.null(self$`sequenceReadCount`)) {
          sprintf(
          '"sequenceReadCount":
            %d
                    ',
          self$`sequenceReadCount`
          )
        },
        if (!is.null(self$`sequenceReadLength`)) {
          sprintf(
          '"sequenceReadLength":
            %d
                    ',
          self$`sequenceReadLength`
          )
        },
        if (!is.null(self$`userFlaggedOutlier`)) {
          sprintf(
          '"userFlaggedOutlier":
            %s
                    ',
          tolower(self$`userFlaggedOutlier`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of BioAssayValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioAssayValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioAssayValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`accession` <- DatabaseEntryValueObject$new()$fromJSON(jsonlite::toJSON(this_object$accession, auto_unbox = TRUE, digits = NA))
      self$`arrayDesign` <- ArrayDesignValueObject$new()$fromJSON(jsonlite::toJSON(this_object$arrayDesign, auto_unbox = TRUE, digits = NA))
      self$`description` <- this_object$`description`
      self$`metadata` <- this_object$`metadata`
      self$`name` <- this_object$`name`
      self$`originalPlatform` <- ArrayDesignValueObject$new()$fromJSON(jsonlite::toJSON(this_object$originalPlatform, auto_unbox = TRUE, digits = NA))
      self$`outlier` <- this_object$`outlier`
      self$`predictedOutlier` <- this_object$`predictedOutlier`
      self$`processingDate` <- this_object$`processingDate`
      self$`sample` <- BioMaterialValueObject$new()$fromJSON(jsonlite::toJSON(this_object$sample, auto_unbox = TRUE, digits = NA))
      self$`sequencePairedReads` <- this_object$`sequencePairedReads`
      self$`sequenceReadCount` <- this_object$`sequenceReadCount`
      self$`sequenceReadLength` <- this_object$`sequenceReadLength`
      self$`userFlaggedOutlier` <- this_object$`userFlaggedOutlier`
      self
    },
    #' Validate JSON input with respect to BioAssayValueObject
    #'
    #' @description
    #' Validate JSON input with respect to BioAssayValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of BioAssayValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
BioAssayValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
BioAssayValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
BioAssayValueObject$lock()


#' Create a new BioMaterialValueObject
#'
#' @description
#' BioMaterialValueObject Class
#'
#' @docType class
#' @title BioMaterialValueObject
#' @description BioMaterialValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field assayDescription  character optional
#' @field assayName  character optional
#' @field bioAssays  list(integer) optional
#' @field characteristics  list(\link{CharacteristicValueObject}) optional
#' @field description  character optional
#' @field factorIdToFactorValueId  named list(character) optional
#' @field factors  named list(character) optional
#' @field factorValueObjects  list(\link{IdentifiableValueObject}) optional
#' @field factorValues  named list(character) optional
#' @field name  character optional
#' @field assayProcessingDate  character optional
#' @field characteristicValues  named list(character) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
BioMaterialValueObject <- R6::R6Class(
  "BioMaterialValueObject",
  public = list(
    `id` = NULL,
    `assayDescription` = NULL,
    `assayName` = NULL,
    `bioAssays` = NULL,
    `characteristics` = NULL,
    `description` = NULL,
    `factorIdToFactorValueId` = NULL,
    `factors` = NULL,
    `factorValueObjects` = NULL,
    `factorValues` = NULL,
    `name` = NULL,
    `assayProcessingDate` = NULL,
    `characteristicValues` = NULL,
    #' Initialize a new BioMaterialValueObject class.
    #'
    #' @description
    #' Initialize a new BioMaterialValueObject class.
    #'
    #' @param id id
    #' @param assayDescription assayDescription
    #' @param assayName assayName
    #' @param bioAssays bioAssays
    #' @param characteristics characteristics
    #' @param description description
    #' @param factorIdToFactorValueId factorIdToFactorValueId
    #' @param factors factors
    #' @param factorValueObjects factorValueObjects
    #' @param factorValues factorValues
    #' @param name name
    #' @param assayProcessingDate assayProcessingDate
    #' @param characteristicValues characteristicValues
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `assayDescription` = NULL, `assayName` = NULL, `bioAssays` = NULL, `characteristics` = NULL, `description` = NULL, `factorIdToFactorValueId` = NULL, `factors` = NULL, `factorValueObjects` = NULL, `factorValues` = NULL, `name` = NULL, `assayProcessingDate` = NULL, `characteristicValues` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`assayDescription`)) {
        stopifnot(is.character(`assayDescription`), length(`assayDescription`) == 1)
        self$`assayDescription` <- `assayDescription`
      }
      if (!is.null(`assayName`)) {
        stopifnot(is.character(`assayName`), length(`assayName`) == 1)
        self$`assayName` <- `assayName`
      }
      if (!is.null(`bioAssays`)) {
        stopifnot(is.vector(`bioAssays`), length(`bioAssays`) != 0)
        sapply(`bioAssays`, function(x) stopifnot(is.character(x)))
        self$`bioAssays` <- `bioAssays`
      }
      if (!is.null(`characteristics`)) {
        stopifnot(is.vector(`characteristics`), length(`characteristics`) != 0)
        sapply(`characteristics`, function(x) stopifnot(R6::is.R6(x)))
        self$`characteristics` <- `characteristics`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`factorIdToFactorValueId`)) {
        stopifnot(is.vector(`factorIdToFactorValueId`), length(`factorIdToFactorValueId`) != 0)
        sapply(`factorIdToFactorValueId`, function(x) stopifnot(is.character(x)))
        self$`factorIdToFactorValueId` <- `factorIdToFactorValueId`
      }
      if (!is.null(`factors`)) {
        stopifnot(is.vector(`factors`), length(`factors`) != 0)
        sapply(`factors`, function(x) stopifnot(is.character(x)))
        self$`factors` <- `factors`
      }
      if (!is.null(`factorValueObjects`)) {
        stopifnot(is.vector(`factorValueObjects`), length(`factorValueObjects`) != 0)
        sapply(`factorValueObjects`, function(x) stopifnot(R6::is.R6(x)))
        self$`factorValueObjects` <- `factorValueObjects`
      }
      if (!is.null(`factorValues`)) {
        stopifnot(is.vector(`factorValues`), length(`factorValues`) != 0)
        sapply(`factorValues`, function(x) stopifnot(is.character(x)))
        self$`factorValues` <- `factorValues`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`assayProcessingDate`)) {
        stopifnot(is.character(`assayProcessingDate`), length(`assayProcessingDate`) == 1)
        self$`assayProcessingDate` <- `assayProcessingDate`
      }
      if (!is.null(`characteristicValues`)) {
        stopifnot(is.vector(`characteristicValues`), length(`characteristicValues`) != 0)
        sapply(`characteristicValues`, function(x) stopifnot(is.character(x)))
        self$`characteristicValues` <- `characteristicValues`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioMaterialValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      BioMaterialValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        BioMaterialValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`assayDescription`)) {
        BioMaterialValueObjectObject[["assayDescription"]] <-
          self$`assayDescription`
      }
      if (!is.null(self$`assayName`)) {
        BioMaterialValueObjectObject[["assayName"]] <-
          self$`assayName`
      }
      if (!is.null(self$`bioAssays`)) {
        BioMaterialValueObjectObject[["bioAssays"]] <-
          self$`bioAssays`
      }
      if (!is.null(self$`characteristics`)) {
        BioMaterialValueObjectObject[["characteristics"]] <-
          lapply(self$`characteristics`, function(x) x$toJSON())
      }
      if (!is.null(self$`description`)) {
        BioMaterialValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`factorIdToFactorValueId`)) {
        BioMaterialValueObjectObject[["factorIdToFactorValueId"]] <-
          self$`factorIdToFactorValueId`
      }
      if (!is.null(self$`factors`)) {
        BioMaterialValueObjectObject[["factors"]] <-
          self$`factors`
      }
      if (!is.null(self$`factorValueObjects`)) {
        BioMaterialValueObjectObject[["factorValueObjects"]] <-
          lapply(self$`factorValueObjects`, function(x) x$toJSON())
      }
      if (!is.null(self$`factorValues`)) {
        BioMaterialValueObjectObject[["factorValues"]] <-
          self$`factorValues`
      }
      if (!is.null(self$`name`)) {
        BioMaterialValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`assayProcessingDate`)) {
        BioMaterialValueObjectObject[["assayProcessingDate"]] <-
          self$`assayProcessingDate`
      }
      if (!is.null(self$`characteristicValues`)) {
        BioMaterialValueObjectObject[["characteristicValues"]] <-
          self$`characteristicValues`
      }
      BioMaterialValueObjectObject
    },
    #' Deserialize JSON string into an instance of BioMaterialValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioMaterialValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioMaterialValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`assayDescription`)) {
        self$`assayDescription` <- this_object$`assayDescription`
      }
      if (!is.null(this_object$`assayName`)) {
        self$`assayName` <- this_object$`assayName`
      }
      if (!is.null(this_object$`bioAssays`)) {
        self$`bioAssays` <- ApiClient$new()$deserializeObj(this_object$`bioAssays`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`characteristics`)) {
        self$`characteristics` <- ApiClient$new()$deserializeObj(this_object$`characteristics`, "array[CharacteristicValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`factorIdToFactorValueId`)) {
        self$`factorIdToFactorValueId` <- ApiClient$new()$deserializeObj(this_object$`factorIdToFactorValueId`, "map(character)", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`factors`)) {
        self$`factors` <- ApiClient$new()$deserializeObj(this_object$`factors`, "map(character)", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`factorValueObjects`)) {
        self$`factorValueObjects` <- ApiClient$new()$deserializeObj(this_object$`factorValueObjects`, "array[IdentifiableValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`factorValues`)) {
        self$`factorValues` <- ApiClient$new()$deserializeObj(this_object$`factorValues`, "map(character)", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`assayProcessingDate`)) {
        self$`assayProcessingDate` <- this_object$`assayProcessingDate`
      }
      if (!is.null(this_object$`characteristicValues`)) {
        self$`characteristicValues` <- ApiClient$new()$deserializeObj(this_object$`characteristicValues`, "map(character)", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioMaterialValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`assayDescription`)) {
          sprintf(
          '"assayDescription":
            "%s"
                    ',
          self$`assayDescription`
          )
        },
        if (!is.null(self$`assayName`)) {
          sprintf(
          '"assayName":
            "%s"
                    ',
          self$`assayName`
          )
        },
        if (!is.null(self$`bioAssays`)) {
          sprintf(
          '"bioAssays":
             [%s]
          ',
          paste(unlist(lapply(self$`bioAssays`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`characteristics`)) {
          sprintf(
          '"characteristics":
          [%s]
',
          paste(sapply(self$`characteristics`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`factorIdToFactorValueId`)) {
          sprintf(
          '"factorIdToFactorValueId":
            "%s"
          ',
          jsonlite::toJSON(lapply(self$`factorIdToFactorValueId`, function(x){ x }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`factors`)) {
          sprintf(
          '"factors":
            "%s"
          ',
          jsonlite::toJSON(lapply(self$`factors`, function(x){ x }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`factorValueObjects`)) {
          sprintf(
          '"factorValueObjects":
          [%s]
',
          paste(sapply(self$`factorValueObjects`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`factorValues`)) {
          sprintf(
          '"factorValues":
            "%s"
          ',
          jsonlite::toJSON(lapply(self$`factorValues`, function(x){ x }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`assayProcessingDate`)) {
          sprintf(
          '"assayProcessingDate":
            "%s"
                    ',
          self$`assayProcessingDate`
          )
        },
        if (!is.null(self$`characteristicValues`)) {
          sprintf(
          '"characteristicValues":
            "%s"
          ',
          jsonlite::toJSON(lapply(self$`characteristicValues`, function(x){ x }), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of BioMaterialValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioMaterialValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioMaterialValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`assayDescription` <- this_object$`assayDescription`
      self$`assayName` <- this_object$`assayName`
      self$`bioAssays` <- ApiClient$new()$deserializeObj(this_object$`bioAssays`, "array[integer]", loadNamespace("gemma.R"))
      self$`characteristics` <- ApiClient$new()$deserializeObj(this_object$`characteristics`, "array[CharacteristicValueObject]", loadNamespace("gemma.R"))
      self$`description` <- this_object$`description`
      self$`factorIdToFactorValueId` <- ApiClient$new()$deserializeObj(this_object$`factorIdToFactorValueId`, "map(character)", loadNamespace("gemma.R"))
      self$`factors` <- ApiClient$new()$deserializeObj(this_object$`factors`, "map(character)", loadNamespace("gemma.R"))
      self$`factorValueObjects` <- ApiClient$new()$deserializeObj(this_object$`factorValueObjects`, "array[IdentifiableValueObject]", loadNamespace("gemma.R"))
      self$`factorValues` <- ApiClient$new()$deserializeObj(this_object$`factorValues`, "map(character)", loadNamespace("gemma.R"))
      self$`name` <- this_object$`name`
      self$`assayProcessingDate` <- this_object$`assayProcessingDate`
      self$`characteristicValues` <- ApiClient$new()$deserializeObj(this_object$`characteristicValues`, "map(character)", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to BioMaterialValueObject
    #'
    #' @description
    #' Validate JSON input with respect to BioMaterialValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of BioMaterialValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
BioMaterialValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
BioMaterialValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
BioMaterialValueObject$lock()


#' Create a new BioSequence
#'
#' @description
#' BioSequence Class
#'
#' @docType class
#' @title BioSequence
#' @description BioSequence Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field length  integer optional
#' @field sequence  character optional
#' @field isApproximateLength  character optional
#' @field isCircular  character optional
#' @field polymerType  \link{PolymerType} optional
#' @field type  \link{SequenceType} optional
#' @field fractionRepeats  numeric optional
#' @field sequenceDatabaseEntry  \link{DatabaseEntry} optional
#' @field taxon  \link{Taxon} optional
#' @field bioSequence2GeneProduct  list(\link{BioSequence2GeneProduct}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
BioSequence <- R6::R6Class(
  "BioSequence",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `length` = NULL,
    `sequence` = NULL,
    `isApproximateLength` = NULL,
    `isCircular` = NULL,
    `polymerType` = NULL,
    `type` = NULL,
    `fractionRepeats` = NULL,
    `sequenceDatabaseEntry` = NULL,
    `taxon` = NULL,
    `bioSequence2GeneProduct` = NULL,
    #' Initialize a new BioSequence class.
    #'
    #' @description
    #' Initialize a new BioSequence class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param length length
    #' @param sequence sequence
    #' @param isApproximateLength isApproximateLength
    #' @param isCircular isCircular
    #' @param polymerType polymerType
    #' @param type type
    #' @param fractionRepeats fractionRepeats
    #' @param sequenceDatabaseEntry sequenceDatabaseEntry
    #' @param taxon taxon
    #' @param bioSequence2GeneProduct bioSequence2GeneProduct
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `length` = NULL, `sequence` = NULL, `isApproximateLength` = NULL, `isCircular` = NULL, `polymerType` = NULL, `type` = NULL, `fractionRepeats` = NULL, `sequenceDatabaseEntry` = NULL, `taxon` = NULL, `bioSequence2GeneProduct` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`length`)) {
        stopifnot(is.numeric(`length`), length(`length`) == 1)
        self$`length` <- `length`
      }
      if (!is.null(`sequence`)) {
        stopifnot(is.character(`sequence`), length(`sequence`) == 1)
        self$`sequence` <- `sequence`
      }
      if (!is.null(`isApproximateLength`)) {
        stopifnot(is.logical(`isApproximateLength`), length(`isApproximateLength`) == 1)
        self$`isApproximateLength` <- `isApproximateLength`
      }
      if (!is.null(`isCircular`)) {
        stopifnot(is.logical(`isCircular`), length(`isCircular`) == 1)
        self$`isCircular` <- `isCircular`
      }
      if (!is.null(`polymerType`)) {
        stopifnot(R6::is.R6(`polymerType`))
        self$`polymerType` <- `polymerType`
      }
      if (!is.null(`type`)) {
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
      if (!is.null(`fractionRepeats`)) {
        stopifnot(is.numeric(`fractionRepeats`), length(`fractionRepeats`) == 1)
        self$`fractionRepeats` <- `fractionRepeats`
      }
      if (!is.null(`sequenceDatabaseEntry`)) {
        stopifnot(R6::is.R6(`sequenceDatabaseEntry`))
        self$`sequenceDatabaseEntry` <- `sequenceDatabaseEntry`
      }
      if (!is.null(`taxon`)) {
        stopifnot(R6::is.R6(`taxon`))
        self$`taxon` <- `taxon`
      }
      if (!is.null(`bioSequence2GeneProduct`)) {
        stopifnot(is.vector(`bioSequence2GeneProduct`), length(`bioSequence2GeneProduct`) != 0)
        sapply(`bioSequence2GeneProduct`, function(x) stopifnot(R6::is.R6(x)))
        self$`bioSequence2GeneProduct` <- `bioSequence2GeneProduct`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioSequence in JSON format
    #' @keywords internal
    toJSON = function() {
      BioSequenceObject <- list()
      if (!is.null(self$`name`)) {
        BioSequenceObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        BioSequenceObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        BioSequenceObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`length`)) {
        BioSequenceObject[["length"]] <-
          self$`length`
      }
      if (!is.null(self$`sequence`)) {
        BioSequenceObject[["sequence"]] <-
          self$`sequence`
      }
      if (!is.null(self$`isApproximateLength`)) {
        BioSequenceObject[["isApproximateLength"]] <-
          self$`isApproximateLength`
      }
      if (!is.null(self$`isCircular`)) {
        BioSequenceObject[["isCircular"]] <-
          self$`isCircular`
      }
      if (!is.null(self$`polymerType`)) {
        BioSequenceObject[["polymerType"]] <-
          self$`polymerType`$toJSON()
      }
      if (!is.null(self$`type`)) {
        BioSequenceObject[["type"]] <-
          self$`type`$toJSON()
      }
      if (!is.null(self$`fractionRepeats`)) {
        BioSequenceObject[["fractionRepeats"]] <-
          self$`fractionRepeats`
      }
      if (!is.null(self$`sequenceDatabaseEntry`)) {
        BioSequenceObject[["sequenceDatabaseEntry"]] <-
          self$`sequenceDatabaseEntry`$toJSON()
      }
      if (!is.null(self$`taxon`)) {
        BioSequenceObject[["taxon"]] <-
          self$`taxon`$toJSON()
      }
      if (!is.null(self$`bioSequence2GeneProduct`)) {
        BioSequenceObject[["bioSequence2GeneProduct"]] <-
          lapply(self$`bioSequence2GeneProduct`, function(x) x$toJSON())
      }
      BioSequenceObject
    },
    #' Deserialize JSON string into an instance of BioSequence
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioSequence
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioSequence
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`length`)) {
        self$`length` <- this_object$`length`
      }
      if (!is.null(this_object$`sequence`)) {
        self$`sequence` <- this_object$`sequence`
      }
      if (!is.null(this_object$`isApproximateLength`)) {
        self$`isApproximateLength` <- this_object$`isApproximateLength`
      }
      if (!is.null(this_object$`isCircular`)) {
        self$`isCircular` <- this_object$`isCircular`
      }
      if (!is.null(this_object$`polymerType`)) {
        polymertype_object <- PolymerType$new()
        polymertype_object$fromJSON(jsonlite::toJSON(this_object$polymerType, auto_unbox = TRUE, digits = NA))
        self$`polymerType` <- polymertype_object
      }
      if (!is.null(this_object$`type`)) {
        type_object <- SequenceType$new()
        type_object$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
        self$`type` <- type_object
      }
      if (!is.null(this_object$`fractionRepeats`)) {
        self$`fractionRepeats` <- this_object$`fractionRepeats`
      }
      if (!is.null(this_object$`sequenceDatabaseEntry`)) {
        sequencedatabaseentry_object <- DatabaseEntry$new()
        sequencedatabaseentry_object$fromJSON(jsonlite::toJSON(this_object$sequenceDatabaseEntry, auto_unbox = TRUE, digits = NA))
        self$`sequenceDatabaseEntry` <- sequencedatabaseentry_object
      }
      if (!is.null(this_object$`taxon`)) {
        taxon_object <- Taxon$new()
        taxon_object$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
        self$`taxon` <- taxon_object
      }
      if (!is.null(this_object$`bioSequence2GeneProduct`)) {
        self$`bioSequence2GeneProduct` <- ApiClient$new()$deserializeObj(this_object$`bioSequence2GeneProduct`, "set[BioSequence2GeneProduct]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioSequence in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`length`)) {
          sprintf(
          '"length":
            %d
                    ',
          self$`length`
          )
        },
        if (!is.null(self$`sequence`)) {
          sprintf(
          '"sequence":
            "%s"
                    ',
          self$`sequence`
          )
        },
        if (!is.null(self$`isApproximateLength`)) {
          sprintf(
          '"isApproximateLength":
            %s
                    ',
          tolower(self$`isApproximateLength`)
          )
        },
        if (!is.null(self$`isCircular`)) {
          sprintf(
          '"isCircular":
            %s
                    ',
          tolower(self$`isCircular`)
          )
        },
        if (!is.null(self$`polymerType`)) {
          sprintf(
          '"polymerType":
          %s
          ',
          jsonlite::toJSON(self$`polymerType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
          '"type":
          %s
          ',
          jsonlite::toJSON(self$`type`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`fractionRepeats`)) {
          sprintf(
          '"fractionRepeats":
            %d
                    ',
          self$`fractionRepeats`
          )
        },
        if (!is.null(self$`sequenceDatabaseEntry`)) {
          sprintf(
          '"sequenceDatabaseEntry":
          %s
          ',
          jsonlite::toJSON(self$`sequenceDatabaseEntry`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
          %s
          ',
          jsonlite::toJSON(self$`taxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`bioSequence2GeneProduct`)) {
          sprintf(
          '"bioSequence2GeneProduct":
          [%s]
',
          paste(sapply(self$`bioSequence2GeneProduct`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of BioSequence
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioSequence
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioSequence
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`length` <- this_object$`length`
      self$`sequence` <- this_object$`sequence`
      self$`isApproximateLength` <- this_object$`isApproximateLength`
      self$`isCircular` <- this_object$`isCircular`
      self$`polymerType` <- PolymerType$new()$fromJSON(jsonlite::toJSON(this_object$polymerType, auto_unbox = TRUE, digits = NA))
      self$`type` <- SequenceType$new()$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
      self$`fractionRepeats` <- this_object$`fractionRepeats`
      self$`sequenceDatabaseEntry` <- DatabaseEntry$new()$fromJSON(jsonlite::toJSON(this_object$sequenceDatabaseEntry, auto_unbox = TRUE, digits = NA))
      self$`taxon` <- Taxon$new()$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
      self$`bioSequence2GeneProduct` <- ApiClient$new()$deserializeObj(this_object$`bioSequence2GeneProduct`, "set[BioSequence2GeneProduct]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to BioSequence
    #'
    #' @description
    #' Validate JSON input with respect to BioSequence and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of BioSequence
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {

      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()

      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
BioSequence$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
BioSequence$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
BioSequence$lock()


#' Create a new BioSequence2GeneProduct
#'
#' @description
#' BioSequence2GeneProduct Class
#'
#' @docType class
#' @title BioSequence2GeneProduct
#' @description BioSequence2GeneProduct Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field sourceAnalysis  \link{Analysis} optional
#' @field overlap  integer optional
#' @field score  numeric optional
#' @field threePrimeDistance  integer optional
#' @field threePrimeDistanceMeasurementMethod  \link{ThreePrimeDistanceMethod} optional
#' @field specificity  numeric optional
#' @field bioSequence  \link{BioSequence} optional
#' @field geneProduct  \link{GeneProduct} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
BioSequence2GeneProduct <- R6::R6Class(
  "BioSequence2GeneProduct",
  public = list(
    `id` = NULL,
    `sourceAnalysis` = NULL,
    `overlap` = NULL,
    `score` = NULL,
    `threePrimeDistance` = NULL,
    `threePrimeDistanceMeasurementMethod` = NULL,
    `specificity` = NULL,
    `bioSequence` = NULL,
    `geneProduct` = NULL,
    #' Initialize a new BioSequence2GeneProduct class.
    #'
    #' @description
    #' Initialize a new BioSequence2GeneProduct class.
    #'
    #' @param id id
    #' @param sourceAnalysis sourceAnalysis
    #' @param overlap overlap
    #' @param score score
    #' @param threePrimeDistance threePrimeDistance
    #' @param threePrimeDistanceMeasurementMethod threePrimeDistanceMeasurementMethod
    #' @param specificity specificity
    #' @param bioSequence bioSequence
    #' @param geneProduct geneProduct
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `sourceAnalysis` = NULL, `overlap` = NULL, `score` = NULL, `threePrimeDistance` = NULL, `threePrimeDistanceMeasurementMethod` = NULL, `specificity` = NULL, `bioSequence` = NULL, `geneProduct` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`sourceAnalysis`)) {
        stopifnot(R6::is.R6(`sourceAnalysis`))
        self$`sourceAnalysis` <- `sourceAnalysis`
      }
      if (!is.null(`overlap`)) {
        stopifnot(is.numeric(`overlap`), length(`overlap`) == 1)
        self$`overlap` <- `overlap`
      }
      if (!is.null(`score`)) {
        stopifnot(is.numeric(`score`), length(`score`) == 1)
        self$`score` <- `score`
      }
      if (!is.null(`threePrimeDistance`)) {
        stopifnot(is.numeric(`threePrimeDistance`), length(`threePrimeDistance`) == 1)
        self$`threePrimeDistance` <- `threePrimeDistance`
      }
      if (!is.null(`threePrimeDistanceMeasurementMethod`)) {
        stopifnot(R6::is.R6(`threePrimeDistanceMeasurementMethod`))
        self$`threePrimeDistanceMeasurementMethod` <- `threePrimeDistanceMeasurementMethod`
      }
      if (!is.null(`specificity`)) {
        stopifnot(is.numeric(`specificity`), length(`specificity`) == 1)
        self$`specificity` <- `specificity`
      }
      if (!is.null(`bioSequence`)) {
        stopifnot(R6::is.R6(`bioSequence`))
        self$`bioSequence` <- `bioSequence`
      }
      if (!is.null(`geneProduct`)) {
        stopifnot(R6::is.R6(`geneProduct`))
        self$`geneProduct` <- `geneProduct`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioSequence2GeneProduct in JSON format
    #' @keywords internal
    toJSON = function() {
      BioSequence2GeneProductObject <- list()
      if (!is.null(self$`id`)) {
        BioSequence2GeneProductObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`sourceAnalysis`)) {
        BioSequence2GeneProductObject[["sourceAnalysis"]] <-
          self$`sourceAnalysis`$toJSON()
      }
      if (!is.null(self$`overlap`)) {
        BioSequence2GeneProductObject[["overlap"]] <-
          self$`overlap`
      }
      if (!is.null(self$`score`)) {
        BioSequence2GeneProductObject[["score"]] <-
          self$`score`
      }
      if (!is.null(self$`threePrimeDistance`)) {
        BioSequence2GeneProductObject[["threePrimeDistance"]] <-
          self$`threePrimeDistance`
      }
      if (!is.null(self$`threePrimeDistanceMeasurementMethod`)) {
        BioSequence2GeneProductObject[["threePrimeDistanceMeasurementMethod"]] <-
          self$`threePrimeDistanceMeasurementMethod`$toJSON()
      }
      if (!is.null(self$`specificity`)) {
        BioSequence2GeneProductObject[["specificity"]] <-
          self$`specificity`
      }
      if (!is.null(self$`bioSequence`)) {
        BioSequence2GeneProductObject[["bioSequence"]] <-
          self$`bioSequence`$toJSON()
      }
      if (!is.null(self$`geneProduct`)) {
        BioSequence2GeneProductObject[["geneProduct"]] <-
          self$`geneProduct`$toJSON()
      }
      BioSequence2GeneProductObject
    },
    #' Deserialize JSON string into an instance of BioSequence2GeneProduct
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioSequence2GeneProduct
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioSequence2GeneProduct
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`sourceAnalysis`)) {
        sourceanalysis_object <- Analysis$new()
        sourceanalysis_object$fromJSON(jsonlite::toJSON(this_object$sourceAnalysis, auto_unbox = TRUE, digits = NA))
        self$`sourceAnalysis` <- sourceanalysis_object
      }
      if (!is.null(this_object$`overlap`)) {
        self$`overlap` <- this_object$`overlap`
      }
      if (!is.null(this_object$`score`)) {
        self$`score` <- this_object$`score`
      }
      if (!is.null(this_object$`threePrimeDistance`)) {
        self$`threePrimeDistance` <- this_object$`threePrimeDistance`
      }
      if (!is.null(this_object$`threePrimeDistanceMeasurementMethod`)) {
        threeprimedistancemeasurementmethod_object <- ThreePrimeDistanceMethod$new()
        threeprimedistancemeasurementmethod_object$fromJSON(jsonlite::toJSON(this_object$threePrimeDistanceMeasurementMethod, auto_unbox = TRUE, digits = NA))
        self$`threePrimeDistanceMeasurementMethod` <- threeprimedistancemeasurementmethod_object
      }
      if (!is.null(this_object$`specificity`)) {
        self$`specificity` <- this_object$`specificity`
      }
      if (!is.null(this_object$`bioSequence`)) {
        biosequence_object <- BioSequence$new()
        biosequence_object$fromJSON(jsonlite::toJSON(this_object$bioSequence, auto_unbox = TRUE, digits = NA))
        self$`bioSequence` <- biosequence_object
      }
      if (!is.null(this_object$`geneProduct`)) {
        geneproduct_object <- GeneProduct$new()
        geneproduct_object$fromJSON(jsonlite::toJSON(this_object$geneProduct, auto_unbox = TRUE, digits = NA))
        self$`geneProduct` <- geneproduct_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioSequence2GeneProduct in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`sourceAnalysis`)) {
          sprintf(
          '"sourceAnalysis":
          %s
          ',
          jsonlite::toJSON(self$`sourceAnalysis`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`overlap`)) {
          sprintf(
          '"overlap":
            %d
                    ',
          self$`overlap`
          )
        },
        if (!is.null(self$`score`)) {
          sprintf(
          '"score":
            %d
                    ',
          self$`score`
          )
        },
        if (!is.null(self$`threePrimeDistance`)) {
          sprintf(
          '"threePrimeDistance":
            %d
                    ',
          self$`threePrimeDistance`
          )
        },
        if (!is.null(self$`threePrimeDistanceMeasurementMethod`)) {
          sprintf(
          '"threePrimeDistanceMeasurementMethod":
          %s
          ',
          jsonlite::toJSON(self$`threePrimeDistanceMeasurementMethod`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`specificity`)) {
          sprintf(
          '"specificity":
            %d
                    ',
          self$`specificity`
          )
        },
        if (!is.null(self$`bioSequence`)) {
          sprintf(
          '"bioSequence":
          %s
          ',
          jsonlite::toJSON(self$`bioSequence`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`geneProduct`)) {
          sprintf(
          '"geneProduct":
          %s
          ',
          jsonlite::toJSON(self$`geneProduct`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of BioSequence2GeneProduct
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioSequence2GeneProduct
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioSequence2GeneProduct
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`sourceAnalysis` <- Analysis$new()$fromJSON(jsonlite::toJSON(this_object$sourceAnalysis, auto_unbox = TRUE, digits = NA))
      self$`overlap` <- this_object$`overlap`
      self$`score` <- this_object$`score`
      self$`threePrimeDistance` <- this_object$`threePrimeDistance`
      self$`threePrimeDistanceMeasurementMethod` <- ThreePrimeDistanceMethod$new()$fromJSON(jsonlite::toJSON(this_object$threePrimeDistanceMeasurementMethod, auto_unbox = TRUE, digits = NA))
      self$`specificity` <- this_object$`specificity`
      self$`bioSequence` <- BioSequence$new()$fromJSON(jsonlite::toJSON(this_object$bioSequence, auto_unbox = TRUE, digits = NA))
      self$`geneProduct` <- GeneProduct$new()$fromJSON(jsonlite::toJSON(this_object$geneProduct, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to BioSequence2GeneProduct
    #'
    #' @description
    #' Validate JSON input with respect to BioSequence2GeneProduct and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of BioSequence2GeneProduct
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
BioSequence2GeneProduct$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
BioSequence2GeneProduct$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
BioSequence2GeneProduct$lock()


#' Create a new BioSequenceValueObject
#'
#' @description
#' BioSequenceValueObject Class
#'
#' @docType class
#' @title BioSequenceValueObject
#' @description BioSequenceValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field description  character optional
#' @field fractionRepeats  numeric optional
#' @field length  integer optional
#' @field name  character optional
#' @field sequence  character optional
#' @field sequenceDatabaseEntry  \link{DatabaseEntryValueObject} optional
#' @field taxon  \link{TaxonValueObject} optional
#' @field type  \link{SequenceType} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
BioSequenceValueObject <- R6::R6Class(
  "BioSequenceValueObject",
  public = list(
    `id` = NULL,
    `description` = NULL,
    `fractionRepeats` = NULL,
    `length` = NULL,
    `name` = NULL,
    `sequence` = NULL,
    `sequenceDatabaseEntry` = NULL,
    `taxon` = NULL,
    `type` = NULL,
    #' Initialize a new BioSequenceValueObject class.
    #'
    #' @description
    #' Initialize a new BioSequenceValueObject class.
    #'
    #' @param id id
    #' @param description description
    #' @param fractionRepeats fractionRepeats
    #' @param length length
    #' @param name name
    #' @param sequence sequence
    #' @param sequenceDatabaseEntry sequenceDatabaseEntry
    #' @param taxon taxon
    #' @param type type
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `description` = NULL, `fractionRepeats` = NULL, `length` = NULL, `name` = NULL, `sequence` = NULL, `sequenceDatabaseEntry` = NULL, `taxon` = NULL, `type` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`fractionRepeats`)) {
        stopifnot(is.numeric(`fractionRepeats`), length(`fractionRepeats`) == 1)
        self$`fractionRepeats` <- `fractionRepeats`
      }
      if (!is.null(`length`)) {
        stopifnot(is.numeric(`length`), length(`length`) == 1)
        self$`length` <- `length`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`sequence`)) {
        stopifnot(is.character(`sequence`), length(`sequence`) == 1)
        self$`sequence` <- `sequence`
      }
      if (!is.null(`sequenceDatabaseEntry`)) {
        stopifnot(R6::is.R6(`sequenceDatabaseEntry`))
        self$`sequenceDatabaseEntry` <- `sequenceDatabaseEntry`
      }
      if (!is.null(`taxon`)) {
        stopifnot(R6::is.R6(`taxon`))
        self$`taxon` <- `taxon`
      }
      if (!is.null(`type`)) {
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioSequenceValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      BioSequenceValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        BioSequenceValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`description`)) {
        BioSequenceValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`fractionRepeats`)) {
        BioSequenceValueObjectObject[["fractionRepeats"]] <-
          self$`fractionRepeats`
      }
      if (!is.null(self$`length`)) {
        BioSequenceValueObjectObject[["length"]] <-
          self$`length`
      }
      if (!is.null(self$`name`)) {
        BioSequenceValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`sequence`)) {
        BioSequenceValueObjectObject[["sequence"]] <-
          self$`sequence`
      }
      if (!is.null(self$`sequenceDatabaseEntry`)) {
        BioSequenceValueObjectObject[["sequenceDatabaseEntry"]] <-
          self$`sequenceDatabaseEntry`$toJSON()
      }
      if (!is.null(self$`taxon`)) {
        BioSequenceValueObjectObject[["taxon"]] <-
          self$`taxon`$toJSON()
      }
      if (!is.null(self$`type`)) {
        BioSequenceValueObjectObject[["type"]] <-
          self$`type`$toJSON()
      }
      BioSequenceValueObjectObject
    },
    #' Deserialize JSON string into an instance of BioSequenceValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioSequenceValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioSequenceValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`fractionRepeats`)) {
        self$`fractionRepeats` <- this_object$`fractionRepeats`
      }
      if (!is.null(this_object$`length`)) {
        self$`length` <- this_object$`length`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`sequence`)) {
        self$`sequence` <- this_object$`sequence`
      }
      if (!is.null(this_object$`sequenceDatabaseEntry`)) {
        sequencedatabaseentry_object <- DatabaseEntryValueObject$new()
        sequencedatabaseentry_object$fromJSON(jsonlite::toJSON(this_object$sequenceDatabaseEntry, auto_unbox = TRUE, digits = NA))
        self$`sequenceDatabaseEntry` <- sequencedatabaseentry_object
      }
      if (!is.null(this_object$`taxon`)) {
        taxon_object <- TaxonValueObject$new()
        taxon_object$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
        self$`taxon` <- taxon_object
      }
      if (!is.null(this_object$`type`)) {
        type_object <- SequenceType$new()
        type_object$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
        self$`type` <- type_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BioSequenceValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`fractionRepeats`)) {
          sprintf(
          '"fractionRepeats":
            %d
                    ',
          self$`fractionRepeats`
          )
        },
        if (!is.null(self$`length`)) {
          sprintf(
          '"length":
            %d
                    ',
          self$`length`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`sequence`)) {
          sprintf(
          '"sequence":
            "%s"
                    ',
          self$`sequence`
          )
        },
        if (!is.null(self$`sequenceDatabaseEntry`)) {
          sprintf(
          '"sequenceDatabaseEntry":
          %s
          ',
          jsonlite::toJSON(self$`sequenceDatabaseEntry`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
          %s
          ',
          jsonlite::toJSON(self$`taxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
          '"type":
          %s
          ',
          jsonlite::toJSON(self$`type`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of BioSequenceValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BioSequenceValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BioSequenceValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`description` <- this_object$`description`
      self$`fractionRepeats` <- this_object$`fractionRepeats`
      self$`length` <- this_object$`length`
      self$`name` <- this_object$`name`
      self$`sequence` <- this_object$`sequence`
      self$`sequenceDatabaseEntry` <- DatabaseEntryValueObject$new()$fromJSON(jsonlite::toJSON(this_object$sequenceDatabaseEntry, auto_unbox = TRUE, digits = NA))
      self$`taxon` <- TaxonValueObject$new()$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
      self$`type` <- SequenceType$new()$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to BioSequenceValueObject
    #'
    #' @description
    #' Validate JSON input with respect to BioSequenceValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of BioSequenceValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
BioSequenceValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
BioSequenceValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
BioSequenceValueObject$lock()


#' Create a new BlatResultValueObject
#'
#' @description
#' BlatResultValueObject Class
#'
#' @docType class
#' @title BlatResultValueObject
#' @description BlatResultValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field blockCount  integer optional
#' @field blockSizes  character optional
#' @field identity  numeric optional
#' @field matches  integer optional
#' @field mismatches  integer optional
#' @field ns  integer optional
#' @field queryEnd  integer optional
#' @field queryGapBases  integer optional
#' @field queryGapCount  integer optional
#' @field querySequence  \link{BioSequenceValueObject} optional
#' @field queryStart  integer optional
#' @field queryStarts  character optional
#' @field repMatches  integer optional
#' @field score  numeric optional
#' @field strand  character optional
#' @field targetChromosomeName  character optional
#' @field targetDatabase  character optional
#' @field taxon  \link{TaxonValueObject} optional
#' @field targetEnd  integer optional
#' @field targetGapBases  integer optional
#' @field targetGapCount  integer optional
#' @field targetStart  integer optional
#' @field targetStarts  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
BlatResultValueObject <- R6::R6Class(
  "BlatResultValueObject",
  public = list(
    `id` = NULL,
    `blockCount` = NULL,
    `blockSizes` = NULL,
    `identity` = NULL,
    `matches` = NULL,
    `mismatches` = NULL,
    `ns` = NULL,
    `queryEnd` = NULL,
    `queryGapBases` = NULL,
    `queryGapCount` = NULL,
    `querySequence` = NULL,
    `queryStart` = NULL,
    `queryStarts` = NULL,
    `repMatches` = NULL,
    `score` = NULL,
    `strand` = NULL,
    `targetChromosomeName` = NULL,
    `targetDatabase` = NULL,
    `taxon` = NULL,
    `targetEnd` = NULL,
    `targetGapBases` = NULL,
    `targetGapCount` = NULL,
    `targetStart` = NULL,
    `targetStarts` = NULL,
    #' Initialize a new BlatResultValueObject class.
    #'
    #' @description
    #' Initialize a new BlatResultValueObject class.
    #'
    #' @param id id
    #' @param blockCount blockCount
    #' @param blockSizes blockSizes
    #' @param identity identity
    #' @param matches matches
    #' @param mismatches mismatches
    #' @param ns ns
    #' @param queryEnd queryEnd
    #' @param queryGapBases queryGapBases
    #' @param queryGapCount queryGapCount
    #' @param querySequence querySequence
    #' @param queryStart queryStart
    #' @param queryStarts queryStarts
    #' @param repMatches repMatches
    #' @param score score
    #' @param strand strand
    #' @param targetChromosomeName targetChromosomeName
    #' @param targetDatabase targetDatabase
    #' @param taxon taxon
    #' @param targetEnd targetEnd
    #' @param targetGapBases targetGapBases
    #' @param targetGapCount targetGapCount
    #' @param targetStart targetStart
    #' @param targetStarts targetStarts
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `blockCount` = NULL, `blockSizes` = NULL, `identity` = NULL, `matches` = NULL, `mismatches` = NULL, `ns` = NULL, `queryEnd` = NULL, `queryGapBases` = NULL, `queryGapCount` = NULL, `querySequence` = NULL, `queryStart` = NULL, `queryStarts` = NULL, `repMatches` = NULL, `score` = NULL, `strand` = NULL, `targetChromosomeName` = NULL, `targetDatabase` = NULL, `taxon` = NULL, `targetEnd` = NULL, `targetGapBases` = NULL, `targetGapCount` = NULL, `targetStart` = NULL, `targetStarts` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`blockCount`)) {
        stopifnot(is.numeric(`blockCount`), length(`blockCount`) == 1)
        self$`blockCount` <- `blockCount`
      }
      if (!is.null(`blockSizes`)) {
        stopifnot(is.character(`blockSizes`), length(`blockSizes`) == 1)
        self$`blockSizes` <- `blockSizes`
      }
      if (!is.null(`identity`)) {
        stopifnot(is.numeric(`identity`), length(`identity`) == 1)
        self$`identity` <- `identity`
      }
      if (!is.null(`matches`)) {
        stopifnot(is.numeric(`matches`), length(`matches`) == 1)
        self$`matches` <- `matches`
      }
      if (!is.null(`mismatches`)) {
        stopifnot(is.numeric(`mismatches`), length(`mismatches`) == 1)
        self$`mismatches` <- `mismatches`
      }
      if (!is.null(`ns`)) {
        stopifnot(is.numeric(`ns`), length(`ns`) == 1)
        self$`ns` <- `ns`
      }
      if (!is.null(`queryEnd`)) {
        stopifnot(is.numeric(`queryEnd`), length(`queryEnd`) == 1)
        self$`queryEnd` <- `queryEnd`
      }
      if (!is.null(`queryGapBases`)) {
        stopifnot(is.numeric(`queryGapBases`), length(`queryGapBases`) == 1)
        self$`queryGapBases` <- `queryGapBases`
      }
      if (!is.null(`queryGapCount`)) {
        stopifnot(is.numeric(`queryGapCount`), length(`queryGapCount`) == 1)
        self$`queryGapCount` <- `queryGapCount`
      }
      if (!is.null(`querySequence`)) {
        stopifnot(R6::is.R6(`querySequence`))
        self$`querySequence` <- `querySequence`
      }
      if (!is.null(`queryStart`)) {
        stopifnot(is.numeric(`queryStart`), length(`queryStart`) == 1)
        self$`queryStart` <- `queryStart`
      }
      if (!is.null(`queryStarts`)) {
        stopifnot(is.character(`queryStarts`), length(`queryStarts`) == 1)
        self$`queryStarts` <- `queryStarts`
      }
      if (!is.null(`repMatches`)) {
        stopifnot(is.numeric(`repMatches`), length(`repMatches`) == 1)
        self$`repMatches` <- `repMatches`
      }
      if (!is.null(`score`)) {
        stopifnot(is.numeric(`score`), length(`score`) == 1)
        self$`score` <- `score`
      }
      if (!is.null(`strand`)) {
        stopifnot(is.character(`strand`), length(`strand`) == 1)
        self$`strand` <- `strand`
      }
      if (!is.null(`targetChromosomeName`)) {
        stopifnot(is.character(`targetChromosomeName`), length(`targetChromosomeName`) == 1)
        self$`targetChromosomeName` <- `targetChromosomeName`
      }
      if (!is.null(`targetDatabase`)) {
        stopifnot(is.character(`targetDatabase`), length(`targetDatabase`) == 1)
        self$`targetDatabase` <- `targetDatabase`
      }
      if (!is.null(`taxon`)) {
        stopifnot(R6::is.R6(`taxon`))
        self$`taxon` <- `taxon`
      }
      if (!is.null(`targetEnd`)) {
        stopifnot(is.numeric(`targetEnd`), length(`targetEnd`) == 1)
        self$`targetEnd` <- `targetEnd`
      }
      if (!is.null(`targetGapBases`)) {
        stopifnot(is.numeric(`targetGapBases`), length(`targetGapBases`) == 1)
        self$`targetGapBases` <- `targetGapBases`
      }
      if (!is.null(`targetGapCount`)) {
        stopifnot(is.numeric(`targetGapCount`), length(`targetGapCount`) == 1)
        self$`targetGapCount` <- `targetGapCount`
      }
      if (!is.null(`targetStart`)) {
        stopifnot(is.numeric(`targetStart`), length(`targetStart`) == 1)
        self$`targetStart` <- `targetStart`
      }
      if (!is.null(`targetStarts`)) {
        stopifnot(is.character(`targetStarts`), length(`targetStarts`) == 1)
        self$`targetStarts` <- `targetStarts`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BlatResultValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      BlatResultValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        BlatResultValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`blockCount`)) {
        BlatResultValueObjectObject[["blockCount"]] <-
          self$`blockCount`
      }
      if (!is.null(self$`blockSizes`)) {
        BlatResultValueObjectObject[["blockSizes"]] <-
          self$`blockSizes`
      }
      if (!is.null(self$`identity`)) {
        BlatResultValueObjectObject[["identity"]] <-
          self$`identity`
      }
      if (!is.null(self$`matches`)) {
        BlatResultValueObjectObject[["matches"]] <-
          self$`matches`
      }
      if (!is.null(self$`mismatches`)) {
        BlatResultValueObjectObject[["mismatches"]] <-
          self$`mismatches`
      }
      if (!is.null(self$`ns`)) {
        BlatResultValueObjectObject[["ns"]] <-
          self$`ns`
      }
      if (!is.null(self$`queryEnd`)) {
        BlatResultValueObjectObject[["queryEnd"]] <-
          self$`queryEnd`
      }
      if (!is.null(self$`queryGapBases`)) {
        BlatResultValueObjectObject[["queryGapBases"]] <-
          self$`queryGapBases`
      }
      if (!is.null(self$`queryGapCount`)) {
        BlatResultValueObjectObject[["queryGapCount"]] <-
          self$`queryGapCount`
      }
      if (!is.null(self$`querySequence`)) {
        BlatResultValueObjectObject[["querySequence"]] <-
          self$`querySequence`$toJSON()
      }
      if (!is.null(self$`queryStart`)) {
        BlatResultValueObjectObject[["queryStart"]] <-
          self$`queryStart`
      }
      if (!is.null(self$`queryStarts`)) {
        BlatResultValueObjectObject[["queryStarts"]] <-
          self$`queryStarts`
      }
      if (!is.null(self$`repMatches`)) {
        BlatResultValueObjectObject[["repMatches"]] <-
          self$`repMatches`
      }
      if (!is.null(self$`score`)) {
        BlatResultValueObjectObject[["score"]] <-
          self$`score`
      }
      if (!is.null(self$`strand`)) {
        BlatResultValueObjectObject[["strand"]] <-
          self$`strand`
      }
      if (!is.null(self$`targetChromosomeName`)) {
        BlatResultValueObjectObject[["targetChromosomeName"]] <-
          self$`targetChromosomeName`
      }
      if (!is.null(self$`targetDatabase`)) {
        BlatResultValueObjectObject[["targetDatabase"]] <-
          self$`targetDatabase`
      }
      if (!is.null(self$`taxon`)) {
        BlatResultValueObjectObject[["taxon"]] <-
          self$`taxon`$toJSON()
      }
      if (!is.null(self$`targetEnd`)) {
        BlatResultValueObjectObject[["targetEnd"]] <-
          self$`targetEnd`
      }
      if (!is.null(self$`targetGapBases`)) {
        BlatResultValueObjectObject[["targetGapBases"]] <-
          self$`targetGapBases`
      }
      if (!is.null(self$`targetGapCount`)) {
        BlatResultValueObjectObject[["targetGapCount"]] <-
          self$`targetGapCount`
      }
      if (!is.null(self$`targetStart`)) {
        BlatResultValueObjectObject[["targetStart"]] <-
          self$`targetStart`
      }
      if (!is.null(self$`targetStarts`)) {
        BlatResultValueObjectObject[["targetStarts"]] <-
          self$`targetStarts`
      }
      BlatResultValueObjectObject
    },
    #' Deserialize JSON string into an instance of BlatResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BlatResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BlatResultValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`blockCount`)) {
        self$`blockCount` <- this_object$`blockCount`
      }
      if (!is.null(this_object$`blockSizes`)) {
        self$`blockSizes` <- this_object$`blockSizes`
      }
      if (!is.null(this_object$`identity`)) {
        self$`identity` <- this_object$`identity`
      }
      if (!is.null(this_object$`matches`)) {
        self$`matches` <- this_object$`matches`
      }
      if (!is.null(this_object$`mismatches`)) {
        self$`mismatches` <- this_object$`mismatches`
      }
      if (!is.null(this_object$`ns`)) {
        self$`ns` <- this_object$`ns`
      }
      if (!is.null(this_object$`queryEnd`)) {
        self$`queryEnd` <- this_object$`queryEnd`
      }
      if (!is.null(this_object$`queryGapBases`)) {
        self$`queryGapBases` <- this_object$`queryGapBases`
      }
      if (!is.null(this_object$`queryGapCount`)) {
        self$`queryGapCount` <- this_object$`queryGapCount`
      }
      if (!is.null(this_object$`querySequence`)) {
        querysequence_object <- BioSequenceValueObject$new()
        querysequence_object$fromJSON(jsonlite::toJSON(this_object$querySequence, auto_unbox = TRUE, digits = NA))
        self$`querySequence` <- querysequence_object
      }
      if (!is.null(this_object$`queryStart`)) {
        self$`queryStart` <- this_object$`queryStart`
      }
      if (!is.null(this_object$`queryStarts`)) {
        self$`queryStarts` <- this_object$`queryStarts`
      }
      if (!is.null(this_object$`repMatches`)) {
        self$`repMatches` <- this_object$`repMatches`
      }
      if (!is.null(this_object$`score`)) {
        self$`score` <- this_object$`score`
      }
      if (!is.null(this_object$`strand`)) {
        self$`strand` <- this_object$`strand`
      }
      if (!is.null(this_object$`targetChromosomeName`)) {
        self$`targetChromosomeName` <- this_object$`targetChromosomeName`
      }
      if (!is.null(this_object$`targetDatabase`)) {
        self$`targetDatabase` <- this_object$`targetDatabase`
      }
      if (!is.null(this_object$`taxon`)) {
        taxon_object <- TaxonValueObject$new()
        taxon_object$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
        self$`taxon` <- taxon_object
      }
      if (!is.null(this_object$`targetEnd`)) {
        self$`targetEnd` <- this_object$`targetEnd`
      }
      if (!is.null(this_object$`targetGapBases`)) {
        self$`targetGapBases` <- this_object$`targetGapBases`
      }
      if (!is.null(this_object$`targetGapCount`)) {
        self$`targetGapCount` <- this_object$`targetGapCount`
      }
      if (!is.null(this_object$`targetStart`)) {
        self$`targetStart` <- this_object$`targetStart`
      }
      if (!is.null(this_object$`targetStarts`)) {
        self$`targetStarts` <- this_object$`targetStarts`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return BlatResultValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`blockCount`)) {
          sprintf(
          '"blockCount":
            %d
                    ',
          self$`blockCount`
          )
        },
        if (!is.null(self$`blockSizes`)) {
          sprintf(
          '"blockSizes":
            "%s"
                    ',
          self$`blockSizes`
          )
        },
        if (!is.null(self$`identity`)) {
          sprintf(
          '"identity":
            %d
                    ',
          self$`identity`
          )
        },
        if (!is.null(self$`matches`)) {
          sprintf(
          '"matches":
            %d
                    ',
          self$`matches`
          )
        },
        if (!is.null(self$`mismatches`)) {
          sprintf(
          '"mismatches":
            %d
                    ',
          self$`mismatches`
          )
        },
        if (!is.null(self$`ns`)) {
          sprintf(
          '"ns":
            %d
                    ',
          self$`ns`
          )
        },
        if (!is.null(self$`queryEnd`)) {
          sprintf(
          '"queryEnd":
            %d
                    ',
          self$`queryEnd`
          )
        },
        if (!is.null(self$`queryGapBases`)) {
          sprintf(
          '"queryGapBases":
            %d
                    ',
          self$`queryGapBases`
          )
        },
        if (!is.null(self$`queryGapCount`)) {
          sprintf(
          '"queryGapCount":
            %d
                    ',
          self$`queryGapCount`
          )
        },
        if (!is.null(self$`querySequence`)) {
          sprintf(
          '"querySequence":
          %s
          ',
          jsonlite::toJSON(self$`querySequence`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`queryStart`)) {
          sprintf(
          '"queryStart":
            %d
                    ',
          self$`queryStart`
          )
        },
        if (!is.null(self$`queryStarts`)) {
          sprintf(
          '"queryStarts":
            "%s"
                    ',
          self$`queryStarts`
          )
        },
        if (!is.null(self$`repMatches`)) {
          sprintf(
          '"repMatches":
            %d
                    ',
          self$`repMatches`
          )
        },
        if (!is.null(self$`score`)) {
          sprintf(
          '"score":
            %d
                    ',
          self$`score`
          )
        },
        if (!is.null(self$`strand`)) {
          sprintf(
          '"strand":
            "%s"
                    ',
          self$`strand`
          )
        },
        if (!is.null(self$`targetChromosomeName`)) {
          sprintf(
          '"targetChromosomeName":
            "%s"
                    ',
          self$`targetChromosomeName`
          )
        },
        if (!is.null(self$`targetDatabase`)) {
          sprintf(
          '"targetDatabase":
            "%s"
                    ',
          self$`targetDatabase`
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
          %s
          ',
          jsonlite::toJSON(self$`taxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`targetEnd`)) {
          sprintf(
          '"targetEnd":
            %d
                    ',
          self$`targetEnd`
          )
        },
        if (!is.null(self$`targetGapBases`)) {
          sprintf(
          '"targetGapBases":
            %d
                    ',
          self$`targetGapBases`
          )
        },
        if (!is.null(self$`targetGapCount`)) {
          sprintf(
          '"targetGapCount":
            %d
                    ',
          self$`targetGapCount`
          )
        },
        if (!is.null(self$`targetStart`)) {
          sprintf(
          '"targetStart":
            %d
                    ',
          self$`targetStart`
          )
        },
        if (!is.null(self$`targetStarts`)) {
          sprintf(
          '"targetStarts":
            "%s"
                    ',
          self$`targetStarts`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of BlatResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of BlatResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of BlatResultValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`blockCount` <- this_object$`blockCount`
      self$`blockSizes` <- this_object$`blockSizes`
      self$`identity` <- this_object$`identity`
      self$`matches` <- this_object$`matches`
      self$`mismatches` <- this_object$`mismatches`
      self$`ns` <- this_object$`ns`
      self$`queryEnd` <- this_object$`queryEnd`
      self$`queryGapBases` <- this_object$`queryGapBases`
      self$`queryGapCount` <- this_object$`queryGapCount`
      self$`querySequence` <- BioSequenceValueObject$new()$fromJSON(jsonlite::toJSON(this_object$querySequence, auto_unbox = TRUE, digits = NA))
      self$`queryStart` <- this_object$`queryStart`
      self$`queryStarts` <- this_object$`queryStarts`
      self$`repMatches` <- this_object$`repMatches`
      self$`score` <- this_object$`score`
      self$`strand` <- this_object$`strand`
      self$`targetChromosomeName` <- this_object$`targetChromosomeName`
      self$`targetDatabase` <- this_object$`targetDatabase`
      self$`taxon` <- TaxonValueObject$new()$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
      self$`targetEnd` <- this_object$`targetEnd`
      self$`targetGapBases` <- this_object$`targetGapBases`
      self$`targetGapCount` <- this_object$`targetGapCount`
      self$`targetStart` <- this_object$`targetStart`
      self$`targetStarts` <- this_object$`targetStarts`
      self
    },
    #' Validate JSON input with respect to BlatResultValueObject
    #'
    #' @description
    #' Validate JSON input with respect to BlatResultValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of BlatResultValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
BlatResultValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
BlatResultValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
BlatResultValueObject$lock()


#' Create a new Characteristic
#'
#' @description
#' Characteristic Class
#'
#' @docType class
#' @title Characteristic
#' @description Characteristic Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field category  character optional
#' @field categoryUri  character optional
#' @field evidenceCode  \link{GOEvidenceCode} optional
#' @field originalValue  character optional
#' @field value  character optional
#' @field valueUri  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Characteristic <- R6::R6Class(
  "Characteristic",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `category` = NULL,
    `categoryUri` = NULL,
    `evidenceCode` = NULL,
    `originalValue` = NULL,
    `value` = NULL,
    `valueUri` = NULL,
    #' Initialize a new Characteristic class.
    #'
    #' @description
    #' Initialize a new Characteristic class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param category category
    #' @param categoryUri categoryUri
    #' @param evidenceCode evidenceCode
    #' @param originalValue originalValue
    #' @param value value
    #' @param valueUri valueUri
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `category` = NULL, `categoryUri` = NULL, `evidenceCode` = NULL, `originalValue` = NULL, `value` = NULL, `valueUri` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`category`)) {
        stopifnot(is.character(`category`), length(`category`) == 1)
        self$`category` <- `category`
      }
      if (!is.null(`categoryUri`)) {
        stopifnot(is.character(`categoryUri`), length(`categoryUri`) == 1)
        self$`categoryUri` <- `categoryUri`
      }
      if (!is.null(`evidenceCode`)) {
        stopifnot(R6::is.R6(`evidenceCode`))
        self$`evidenceCode` <- `evidenceCode`
      }
      if (!is.null(`originalValue`)) {
        stopifnot(is.character(`originalValue`), length(`originalValue`) == 1)
        self$`originalValue` <- `originalValue`
      }
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
      if (!is.null(`valueUri`)) {
        stopifnot(is.character(`valueUri`), length(`valueUri`) == 1)
        self$`valueUri` <- `valueUri`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Characteristic in JSON format
    #' @keywords internal
    toJSON = function() {
      CharacteristicObject <- list()
      if (!is.null(self$`name`)) {
        CharacteristicObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        CharacteristicObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        CharacteristicObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`category`)) {
        CharacteristicObject[["category"]] <-
          self$`category`
      }
      if (!is.null(self$`categoryUri`)) {
        CharacteristicObject[["categoryUri"]] <-
          self$`categoryUri`
      }
      if (!is.null(self$`evidenceCode`)) {
        CharacteristicObject[["evidenceCode"]] <-
          self$`evidenceCode`$toJSON()
      }
      if (!is.null(self$`originalValue`)) {
        CharacteristicObject[["originalValue"]] <-
          self$`originalValue`
      }
      if (!is.null(self$`value`)) {
        CharacteristicObject[["value"]] <-
          self$`value`
      }
      if (!is.null(self$`valueUri`)) {
        CharacteristicObject[["valueUri"]] <-
          self$`valueUri`
      }
      CharacteristicObject
    },
    #' Deserialize JSON string into an instance of Characteristic
    #'
    #' @description
    #' Deserialize JSON string into an instance of Characteristic
    #'
    #' @param input_json the JSON input
    #' @return the instance of Characteristic
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`category`)) {
        self$`category` <- this_object$`category`
      }
      if (!is.null(this_object$`categoryUri`)) {
        self$`categoryUri` <- this_object$`categoryUri`
      }
      if (!is.null(this_object$`evidenceCode`)) {
        evidencecode_object <- GOEvidenceCode$new()
        evidencecode_object$fromJSON(jsonlite::toJSON(this_object$evidenceCode, auto_unbox = TRUE, digits = NA))
        self$`evidenceCode` <- evidencecode_object
      }
      if (!is.null(this_object$`originalValue`)) {
        self$`originalValue` <- this_object$`originalValue`
      }
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      if (!is.null(this_object$`valueUri`)) {
        self$`valueUri` <- this_object$`valueUri`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Characteristic in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`category`)) {
          sprintf(
          '"category":
            "%s"
                    ',
          self$`category`
          )
        },
        if (!is.null(self$`categoryUri`)) {
          sprintf(
          '"categoryUri":
            "%s"
                    ',
          self$`categoryUri`
          )
        },
        if (!is.null(self$`evidenceCode`)) {
          sprintf(
          '"evidenceCode":
          %s
          ',
          jsonlite::toJSON(self$`evidenceCode`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`originalValue`)) {
          sprintf(
          '"originalValue":
            "%s"
                    ',
          self$`originalValue`
          )
        },
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        },
        if (!is.null(self$`valueUri`)) {
          sprintf(
          '"valueUri":
            "%s"
                    ',
          self$`valueUri`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Characteristic
    #'
    #' @description
    #' Deserialize JSON string into an instance of Characteristic
    #'
    #' @param input_json the JSON input
    #' @return the instance of Characteristic
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`category` <- this_object$`category`
      self$`categoryUri` <- this_object$`categoryUri`
      self$`evidenceCode` <- GOEvidenceCode$new()$fromJSON(jsonlite::toJSON(this_object$evidenceCode, auto_unbox = TRUE, digits = NA))
      self$`originalValue` <- this_object$`originalValue`
      self$`value` <- this_object$`value`
      self$`valueUri` <- this_object$`valueUri`
      self
    },
    #' Validate JSON input with respect to Characteristic
    #'
    #' @description
    #' Validate JSON input with respect to Characteristic and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Characteristic
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Characteristic$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Characteristic$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Characteristic$lock()


#' Create a new CharacteristicBasicValueObject
#'
#' @description
#' CharacteristicBasicValueObject Class
#'
#' @docType class
#' @title CharacteristicBasicValueObject
#' @description CharacteristicBasicValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field value  character optional
#' @field valueUri  character optional
#' @field category  character optional
#' @field categoryUri  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
CharacteristicBasicValueObject <- R6::R6Class(
  "CharacteristicBasicValueObject",
  public = list(
    `id` = NULL,
    `value` = NULL,
    `valueUri` = NULL,
    `category` = NULL,
    `categoryUri` = NULL,
    #' Initialize a new CharacteristicBasicValueObject class.
    #'
    #' @description
    #' Initialize a new CharacteristicBasicValueObject class.
    #'
    #' @param id id
    #' @param value value
    #' @param valueUri valueUri
    #' @param category category
    #' @param categoryUri categoryUri
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `value` = NULL, `valueUri` = NULL, `category` = NULL, `categoryUri` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
      if (!is.null(`valueUri`)) {
        stopifnot(is.character(`valueUri`), length(`valueUri`) == 1)
        self$`valueUri` <- `valueUri`
      }
      if (!is.null(`category`)) {
        stopifnot(is.character(`category`), length(`category`) == 1)
        self$`category` <- `category`
      }
      if (!is.null(`categoryUri`)) {
        stopifnot(is.character(`categoryUri`), length(`categoryUri`) == 1)
        self$`categoryUri` <- `categoryUri`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CharacteristicBasicValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      CharacteristicBasicValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        CharacteristicBasicValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`value`)) {
        CharacteristicBasicValueObjectObject[["value"]] <-
          self$`value`
      }
      if (!is.null(self$`valueUri`)) {
        CharacteristicBasicValueObjectObject[["valueUri"]] <-
          self$`valueUri`
      }
      if (!is.null(self$`category`)) {
        CharacteristicBasicValueObjectObject[["category"]] <-
          self$`category`
      }
      if (!is.null(self$`categoryUri`)) {
        CharacteristicBasicValueObjectObject[["categoryUri"]] <-
          self$`categoryUri`
      }
      CharacteristicBasicValueObjectObject
    },
    #' Deserialize JSON string into an instance of CharacteristicBasicValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of CharacteristicBasicValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of CharacteristicBasicValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      if (!is.null(this_object$`valueUri`)) {
        self$`valueUri` <- this_object$`valueUri`
      }
      if (!is.null(this_object$`category`)) {
        self$`category` <- this_object$`category`
      }
      if (!is.null(this_object$`categoryUri`)) {
        self$`categoryUri` <- this_object$`categoryUri`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CharacteristicBasicValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        },
        if (!is.null(self$`valueUri`)) {
          sprintf(
          '"valueUri":
            "%s"
                    ',
          self$`valueUri`
          )
        },
        if (!is.null(self$`category`)) {
          sprintf(
          '"category":
            "%s"
                    ',
          self$`category`
          )
        },
        if (!is.null(self$`categoryUri`)) {
          sprintf(
          '"categoryUri":
            "%s"
                    ',
          self$`categoryUri`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of CharacteristicBasicValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of CharacteristicBasicValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of CharacteristicBasicValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`value` <- this_object$`value`
      self$`valueUri` <- this_object$`valueUri`
      self$`category` <- this_object$`category`
      self$`categoryUri` <- this_object$`categoryUri`
      self
    },
    #' Validate JSON input with respect to CharacteristicBasicValueObject
    #'
    #' @description
    #' Validate JSON input with respect to CharacteristicBasicValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of CharacteristicBasicValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
CharacteristicBasicValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
CharacteristicBasicValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
CharacteristicBasicValueObject$lock()


#' Create a new CharacteristicValueObject
#'
#' @description
#' CharacteristicValueObject Class
#'
#' @docType class
#' @title CharacteristicValueObject
#' @description CharacteristicValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field urlId  character optional
#' @field alreadyPresentInDatabase  character optional
#' @field alreadyPresentOnGene  character optional
#' @field category  character optional
#' @field categoryUri  character optional
#' @field child  character optional
#' @field numTimesUsed  integer optional
#' @field ontologyUsed  character optional
#' @field privateGeneCount  integer optional
#' @field publicGeneCount  integer optional
#' @field root  character optional
#' @field taxon  character optional
#' @field value  character optional
#' @field valueUri  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
CharacteristicValueObject <- R6::R6Class(
  "CharacteristicValueObject",
  public = list(
    `id` = NULL,
    `urlId` = NULL,
    `alreadyPresentInDatabase` = NULL,
    `alreadyPresentOnGene` = NULL,
    `category` = NULL,
    `categoryUri` = NULL,
    `child` = NULL,
    `numTimesUsed` = NULL,
    `ontologyUsed` = NULL,
    `privateGeneCount` = NULL,
    `publicGeneCount` = NULL,
    `root` = NULL,
    `taxon` = NULL,
    `value` = NULL,
    `valueUri` = NULL,
    #' Initialize a new CharacteristicValueObject class.
    #'
    #' @description
    #' Initialize a new CharacteristicValueObject class.
    #'
    #' @param id id
    #' @param urlId urlId
    #' @param alreadyPresentInDatabase alreadyPresentInDatabase
    #' @param alreadyPresentOnGene alreadyPresentOnGene
    #' @param category category
    #' @param categoryUri categoryUri
    #' @param child child
    #' @param numTimesUsed numTimesUsed
    #' @param ontologyUsed ontologyUsed
    #' @param privateGeneCount privateGeneCount
    #' @param publicGeneCount publicGeneCount
    #' @param root root
    #' @param taxon taxon
    #' @param value value
    #' @param valueUri valueUri
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `urlId` = NULL, `alreadyPresentInDatabase` = NULL, `alreadyPresentOnGene` = NULL, `category` = NULL, `categoryUri` = NULL, `child` = NULL, `numTimesUsed` = NULL, `ontologyUsed` = NULL, `privateGeneCount` = NULL, `publicGeneCount` = NULL, `root` = NULL, `taxon` = NULL, `value` = NULL, `valueUri` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`urlId`)) {
        stopifnot(is.character(`urlId`), length(`urlId`) == 1)
        self$`urlId` <- `urlId`
      }
      if (!is.null(`alreadyPresentInDatabase`)) {
        stopifnot(is.logical(`alreadyPresentInDatabase`), length(`alreadyPresentInDatabase`) == 1)
        self$`alreadyPresentInDatabase` <- `alreadyPresentInDatabase`
      }
      if (!is.null(`alreadyPresentOnGene`)) {
        stopifnot(is.logical(`alreadyPresentOnGene`), length(`alreadyPresentOnGene`) == 1)
        self$`alreadyPresentOnGene` <- `alreadyPresentOnGene`
      }
      if (!is.null(`category`)) {
        stopifnot(is.character(`category`), length(`category`) == 1)
        self$`category` <- `category`
      }
      if (!is.null(`categoryUri`)) {
        stopifnot(is.character(`categoryUri`), length(`categoryUri`) == 1)
        self$`categoryUri` <- `categoryUri`
      }
      if (!is.null(`child`)) {
        stopifnot(is.logical(`child`), length(`child`) == 1)
        self$`child` <- `child`
      }
      if (!is.null(`numTimesUsed`)) {
        stopifnot(is.numeric(`numTimesUsed`), length(`numTimesUsed`) == 1)
        self$`numTimesUsed` <- `numTimesUsed`
      }
      if (!is.null(`ontologyUsed`)) {
        stopifnot(is.character(`ontologyUsed`), length(`ontologyUsed`) == 1)
        self$`ontologyUsed` <- `ontologyUsed`
      }
      if (!is.null(`privateGeneCount`)) {
        stopifnot(is.numeric(`privateGeneCount`), length(`privateGeneCount`) == 1)
        self$`privateGeneCount` <- `privateGeneCount`
      }
      if (!is.null(`publicGeneCount`)) {
        stopifnot(is.numeric(`publicGeneCount`), length(`publicGeneCount`) == 1)
        self$`publicGeneCount` <- `publicGeneCount`
      }
      if (!is.null(`root`)) {
        stopifnot(is.logical(`root`), length(`root`) == 1)
        self$`root` <- `root`
      }
      if (!is.null(`taxon`)) {
        stopifnot(is.character(`taxon`), length(`taxon`) == 1)
        self$`taxon` <- `taxon`
      }
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
      if (!is.null(`valueUri`)) {
        stopifnot(is.character(`valueUri`), length(`valueUri`) == 1)
        self$`valueUri` <- `valueUri`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CharacteristicValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      CharacteristicValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        CharacteristicValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`urlId`)) {
        CharacteristicValueObjectObject[["urlId"]] <-
          self$`urlId`
      }
      if (!is.null(self$`alreadyPresentInDatabase`)) {
        CharacteristicValueObjectObject[["alreadyPresentInDatabase"]] <-
          self$`alreadyPresentInDatabase`
      }
      if (!is.null(self$`alreadyPresentOnGene`)) {
        CharacteristicValueObjectObject[["alreadyPresentOnGene"]] <-
          self$`alreadyPresentOnGene`
      }
      if (!is.null(self$`category`)) {
        CharacteristicValueObjectObject[["category"]] <-
          self$`category`
      }
      if (!is.null(self$`categoryUri`)) {
        CharacteristicValueObjectObject[["categoryUri"]] <-
          self$`categoryUri`
      }
      if (!is.null(self$`child`)) {
        CharacteristicValueObjectObject[["child"]] <-
          self$`child`
      }
      if (!is.null(self$`numTimesUsed`)) {
        CharacteristicValueObjectObject[["numTimesUsed"]] <-
          self$`numTimesUsed`
      }
      if (!is.null(self$`ontologyUsed`)) {
        CharacteristicValueObjectObject[["ontologyUsed"]] <-
          self$`ontologyUsed`
      }
      if (!is.null(self$`privateGeneCount`)) {
        CharacteristicValueObjectObject[["privateGeneCount"]] <-
          self$`privateGeneCount`
      }
      if (!is.null(self$`publicGeneCount`)) {
        CharacteristicValueObjectObject[["publicGeneCount"]] <-
          self$`publicGeneCount`
      }
      if (!is.null(self$`root`)) {
        CharacteristicValueObjectObject[["root"]] <-
          self$`root`
      }
      if (!is.null(self$`taxon`)) {
        CharacteristicValueObjectObject[["taxon"]] <-
          self$`taxon`
      }
      if (!is.null(self$`value`)) {
        CharacteristicValueObjectObject[["value"]] <-
          self$`value`
      }
      if (!is.null(self$`valueUri`)) {
        CharacteristicValueObjectObject[["valueUri"]] <-
          self$`valueUri`
      }
      CharacteristicValueObjectObject
    },
    #' Deserialize JSON string into an instance of CharacteristicValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of CharacteristicValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of CharacteristicValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`urlId`)) {
        self$`urlId` <- this_object$`urlId`
      }
      if (!is.null(this_object$`alreadyPresentInDatabase`)) {
        self$`alreadyPresentInDatabase` <- this_object$`alreadyPresentInDatabase`
      }
      if (!is.null(this_object$`alreadyPresentOnGene`)) {
        self$`alreadyPresentOnGene` <- this_object$`alreadyPresentOnGene`
      }
      if (!is.null(this_object$`category`)) {
        self$`category` <- this_object$`category`
      }
      if (!is.null(this_object$`categoryUri`)) {
        self$`categoryUri` <- this_object$`categoryUri`
      }
      if (!is.null(this_object$`child`)) {
        self$`child` <- this_object$`child`
      }
      if (!is.null(this_object$`numTimesUsed`)) {
        self$`numTimesUsed` <- this_object$`numTimesUsed`
      }
      if (!is.null(this_object$`ontologyUsed`)) {
        self$`ontologyUsed` <- this_object$`ontologyUsed`
      }
      if (!is.null(this_object$`privateGeneCount`)) {
        self$`privateGeneCount` <- this_object$`privateGeneCount`
      }
      if (!is.null(this_object$`publicGeneCount`)) {
        self$`publicGeneCount` <- this_object$`publicGeneCount`
      }
      if (!is.null(this_object$`root`)) {
        self$`root` <- this_object$`root`
      }
      if (!is.null(this_object$`taxon`)) {
        self$`taxon` <- this_object$`taxon`
      }
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      if (!is.null(this_object$`valueUri`)) {
        self$`valueUri` <- this_object$`valueUri`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CharacteristicValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`urlId`)) {
          sprintf(
          '"urlId":
            "%s"
                    ',
          self$`urlId`
          )
        },
        if (!is.null(self$`alreadyPresentInDatabase`)) {
          sprintf(
          '"alreadyPresentInDatabase":
            %s
                    ',
          tolower(self$`alreadyPresentInDatabase`)
          )
        },
        if (!is.null(self$`alreadyPresentOnGene`)) {
          sprintf(
          '"alreadyPresentOnGene":
            %s
                    ',
          tolower(self$`alreadyPresentOnGene`)
          )
        },
        if (!is.null(self$`category`)) {
          sprintf(
          '"category":
            "%s"
                    ',
          self$`category`
          )
        },
        if (!is.null(self$`categoryUri`)) {
          sprintf(
          '"categoryUri":
            "%s"
                    ',
          self$`categoryUri`
          )
        },
        if (!is.null(self$`child`)) {
          sprintf(
          '"child":
            %s
                    ',
          tolower(self$`child`)
          )
        },
        if (!is.null(self$`numTimesUsed`)) {
          sprintf(
          '"numTimesUsed":
            %d
                    ',
          self$`numTimesUsed`
          )
        },
        if (!is.null(self$`ontologyUsed`)) {
          sprintf(
          '"ontologyUsed":
            "%s"
                    ',
          self$`ontologyUsed`
          )
        },
        if (!is.null(self$`privateGeneCount`)) {
          sprintf(
          '"privateGeneCount":
            %d
                    ',
          self$`privateGeneCount`
          )
        },
        if (!is.null(self$`publicGeneCount`)) {
          sprintf(
          '"publicGeneCount":
            %d
                    ',
          self$`publicGeneCount`
          )
        },
        if (!is.null(self$`root`)) {
          sprintf(
          '"root":
            %s
                    ',
          tolower(self$`root`)
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
            "%s"
                    ',
          self$`taxon`
          )
        },
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        },
        if (!is.null(self$`valueUri`)) {
          sprintf(
          '"valueUri":
            "%s"
                    ',
          self$`valueUri`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of CharacteristicValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of CharacteristicValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of CharacteristicValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`urlId` <- this_object$`urlId`
      self$`alreadyPresentInDatabase` <- this_object$`alreadyPresentInDatabase`
      self$`alreadyPresentOnGene` <- this_object$`alreadyPresentOnGene`
      self$`category` <- this_object$`category`
      self$`categoryUri` <- this_object$`categoryUri`
      self$`child` <- this_object$`child`
      self$`numTimesUsed` <- this_object$`numTimesUsed`
      self$`ontologyUsed` <- this_object$`ontologyUsed`
      self$`privateGeneCount` <- this_object$`privateGeneCount`
      self$`publicGeneCount` <- this_object$`publicGeneCount`
      self$`root` <- this_object$`root`
      self$`taxon` <- this_object$`taxon`
      self$`value` <- this_object$`value`
      self$`valueUri` <- this_object$`valueUri`
      self
    },
    #' Validate JSON input with respect to CharacteristicValueObject
    #'
    #' @description
    #' Validate JSON input with respect to CharacteristicValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of CharacteristicValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
CharacteristicValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
CharacteristicValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
CharacteristicValueObject$lock()


#' Create a new Chromosome
#'
#' @description
#' Chromosome Class
#'
#' @docType class
#' @title Chromosome
#' @description Chromosome Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field assemblyDatabase  \link{ExternalDatabase} optional
#' @field sequence  \link{BioSequence} optional
#' @field taxon  \link{Taxon} optional
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Chromosome <- R6::R6Class(
  "Chromosome",
  public = list(
    `name` = NULL,
    `assemblyDatabase` = NULL,
    `sequence` = NULL,
    `taxon` = NULL,
    `id` = NULL,
    #' Initialize a new Chromosome class.
    #'
    #' @description
    #' Initialize a new Chromosome class.
    #'
    #' @param name name
    #' @param assemblyDatabase assemblyDatabase
    #' @param sequence sequence
    #' @param taxon taxon
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `assemblyDatabase` = NULL, `sequence` = NULL, `taxon` = NULL, `id` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`assemblyDatabase`)) {
        stopifnot(R6::is.R6(`assemblyDatabase`))
        self$`assemblyDatabase` <- `assemblyDatabase`
      }
      if (!is.null(`sequence`)) {
        stopifnot(R6::is.R6(`sequence`))
        self$`sequence` <- `sequence`
      }
      if (!is.null(`taxon`)) {
        stopifnot(R6::is.R6(`taxon`))
        self$`taxon` <- `taxon`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Chromosome in JSON format
    #' @keywords internal
    toJSON = function() {
      ChromosomeObject <- list()
      if (!is.null(self$`name`)) {
        ChromosomeObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`assemblyDatabase`)) {
        ChromosomeObject[["assemblyDatabase"]] <-
          self$`assemblyDatabase`$toJSON()
      }
      if (!is.null(self$`sequence`)) {
        ChromosomeObject[["sequence"]] <-
          self$`sequence`$toJSON()
      }
      if (!is.null(self$`taxon`)) {
        ChromosomeObject[["taxon"]] <-
          self$`taxon`$toJSON()
      }
      if (!is.null(self$`id`)) {
        ChromosomeObject[["id"]] <-
          self$`id`
      }
      ChromosomeObject
    },
    #' Deserialize JSON string into an instance of Chromosome
    #'
    #' @description
    #' Deserialize JSON string into an instance of Chromosome
    #'
    #' @param input_json the JSON input
    #' @return the instance of Chromosome
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`assemblyDatabase`)) {
        assemblydatabase_object <- ExternalDatabase$new()
        assemblydatabase_object$fromJSON(jsonlite::toJSON(this_object$assemblyDatabase, auto_unbox = TRUE, digits = NA))
        self$`assemblyDatabase` <- assemblydatabase_object
      }
      if (!is.null(this_object$`sequence`)) {
        sequence_object <- BioSequence$new()
        sequence_object$fromJSON(jsonlite::toJSON(this_object$sequence, auto_unbox = TRUE, digits = NA))
        self$`sequence` <- sequence_object
      }
      if (!is.null(this_object$`taxon`)) {
        taxon_object <- Taxon$new()
        taxon_object$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
        self$`taxon` <- taxon_object
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Chromosome in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`assemblyDatabase`)) {
          sprintf(
          '"assemblyDatabase":
          %s
          ',
          jsonlite::toJSON(self$`assemblyDatabase`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`sequence`)) {
          sprintf(
          '"sequence":
          %s
          ',
          jsonlite::toJSON(self$`sequence`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
          %s
          ',
          jsonlite::toJSON(self$`taxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Chromosome
    #'
    #' @description
    #' Deserialize JSON string into an instance of Chromosome
    #'
    #' @param input_json the JSON input
    #' @return the instance of Chromosome
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`assemblyDatabase` <- ExternalDatabase$new()$fromJSON(jsonlite::toJSON(this_object$assemblyDatabase, auto_unbox = TRUE, digits = NA))
      self$`sequence` <- BioSequence$new()$fromJSON(jsonlite::toJSON(this_object$sequence, auto_unbox = TRUE, digits = NA))
      self$`taxon` <- Taxon$new()$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to Chromosome
    #'
    #' @description
    #' Validate JSON input with respect to Chromosome and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Chromosome
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Chromosome$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Chromosome$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Chromosome$lock()


#' Create a new CoexpressionValueObjectExt
#'
#' @description
#' CoexpressionValueObjectExt Class
#'
#' @docType class
#' @title CoexpressionValueObjectExt
#' @description CoexpressionValueObjectExt Class
#' @format An \code{R6Class} generator object
#' @field containsMyData  character optional
#' @field foundGene  \link{GeneValueObject} optional
#' @field foundGeneNodeDegree  integer optional
#' @field foundGeneNodeDegreeRank  numeric optional
#' @field negSupp  integer optional
#' @field numTestedIn  integer optional
#' @field posSupp  integer optional
#' @field queryGene  \link{GeneValueObject} optional
#' @field queryGeneNodeDegree  integer optional
#' @field queryGeneNodeDegreeRank  numeric optional
#' @field sortKey  character optional
#' @field supportingExperiments  list(integer) optional
#' @field support  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
CoexpressionValueObjectExt <- R6::R6Class(
  "CoexpressionValueObjectExt",
  public = list(
    `containsMyData` = NULL,
    `foundGene` = NULL,
    `foundGeneNodeDegree` = NULL,
    `foundGeneNodeDegreeRank` = NULL,
    `negSupp` = NULL,
    `numTestedIn` = NULL,
    `posSupp` = NULL,
    `queryGene` = NULL,
    `queryGeneNodeDegree` = NULL,
    `queryGeneNodeDegreeRank` = NULL,
    `sortKey` = NULL,
    `supportingExperiments` = NULL,
    `support` = NULL,
    #' Initialize a new CoexpressionValueObjectExt class.
    #'
    #' @description
    #' Initialize a new CoexpressionValueObjectExt class.
    #'
    #' @param containsMyData containsMyData
    #' @param foundGene foundGene
    #' @param foundGeneNodeDegree foundGeneNodeDegree
    #' @param foundGeneNodeDegreeRank foundGeneNodeDegreeRank
    #' @param negSupp negSupp
    #' @param numTestedIn numTestedIn
    #' @param posSupp posSupp
    #' @param queryGene queryGene
    #' @param queryGeneNodeDegree queryGeneNodeDegree
    #' @param queryGeneNodeDegreeRank queryGeneNodeDegreeRank
    #' @param sortKey sortKey
    #' @param supportingExperiments supportingExperiments
    #' @param support support
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `containsMyData` = NULL, `foundGene` = NULL, `foundGeneNodeDegree` = NULL, `foundGeneNodeDegreeRank` = NULL, `negSupp` = NULL, `numTestedIn` = NULL, `posSupp` = NULL, `queryGene` = NULL, `queryGeneNodeDegree` = NULL, `queryGeneNodeDegreeRank` = NULL, `sortKey` = NULL, `supportingExperiments` = NULL, `support` = NULL, ...
    ) {
      if (!is.null(`containsMyData`)) {
        stopifnot(is.logical(`containsMyData`), length(`containsMyData`) == 1)
        self$`containsMyData` <- `containsMyData`
      }
      if (!is.null(`foundGene`)) {
        stopifnot(R6::is.R6(`foundGene`))
        self$`foundGene` <- `foundGene`
      }
      if (!is.null(`foundGeneNodeDegree`)) {
        stopifnot(is.numeric(`foundGeneNodeDegree`), length(`foundGeneNodeDegree`) == 1)
        self$`foundGeneNodeDegree` <- `foundGeneNodeDegree`
      }
      if (!is.null(`foundGeneNodeDegreeRank`)) {
        stopifnot(is.numeric(`foundGeneNodeDegreeRank`), length(`foundGeneNodeDegreeRank`) == 1)
        self$`foundGeneNodeDegreeRank` <- `foundGeneNodeDegreeRank`
      }
      if (!is.null(`negSupp`)) {
        stopifnot(is.numeric(`negSupp`), length(`negSupp`) == 1)
        self$`negSupp` <- `negSupp`
      }
      if (!is.null(`numTestedIn`)) {
        stopifnot(is.numeric(`numTestedIn`), length(`numTestedIn`) == 1)
        self$`numTestedIn` <- `numTestedIn`
      }
      if (!is.null(`posSupp`)) {
        stopifnot(is.numeric(`posSupp`), length(`posSupp`) == 1)
        self$`posSupp` <- `posSupp`
      }
      if (!is.null(`queryGene`)) {
        stopifnot(R6::is.R6(`queryGene`))
        self$`queryGene` <- `queryGene`
      }
      if (!is.null(`queryGeneNodeDegree`)) {
        stopifnot(is.numeric(`queryGeneNodeDegree`), length(`queryGeneNodeDegree`) == 1)
        self$`queryGeneNodeDegree` <- `queryGeneNodeDegree`
      }
      if (!is.null(`queryGeneNodeDegreeRank`)) {
        stopifnot(is.numeric(`queryGeneNodeDegreeRank`), length(`queryGeneNodeDegreeRank`) == 1)
        self$`queryGeneNodeDegreeRank` <- `queryGeneNodeDegreeRank`
      }
      if (!is.null(`sortKey`)) {
        stopifnot(is.character(`sortKey`), length(`sortKey`) == 1)
        self$`sortKey` <- `sortKey`
      }
      if (!is.null(`supportingExperiments`)) {
        stopifnot(is.vector(`supportingExperiments`), length(`supportingExperiments`) != 0)
        sapply(`supportingExperiments`, function(x) stopifnot(is.character(x)))
        self$`supportingExperiments` <- `supportingExperiments`
      }
      if (!is.null(`support`)) {
        stopifnot(is.numeric(`support`), length(`support`) == 1)
        self$`support` <- `support`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CoexpressionValueObjectExt in JSON format
    #' @keywords internal
    toJSON = function() {
      CoexpressionValueObjectExtObject <- list()
      if (!is.null(self$`containsMyData`)) {
        CoexpressionValueObjectExtObject[["containsMyData"]] <-
          self$`containsMyData`
      }
      if (!is.null(self$`foundGene`)) {
        CoexpressionValueObjectExtObject[["foundGene"]] <-
          self$`foundGene`$toJSON()
      }
      if (!is.null(self$`foundGeneNodeDegree`)) {
        CoexpressionValueObjectExtObject[["foundGeneNodeDegree"]] <-
          self$`foundGeneNodeDegree`
      }
      if (!is.null(self$`foundGeneNodeDegreeRank`)) {
        CoexpressionValueObjectExtObject[["foundGeneNodeDegreeRank"]] <-
          self$`foundGeneNodeDegreeRank`
      }
      if (!is.null(self$`negSupp`)) {
        CoexpressionValueObjectExtObject[["negSupp"]] <-
          self$`negSupp`
      }
      if (!is.null(self$`numTestedIn`)) {
        CoexpressionValueObjectExtObject[["numTestedIn"]] <-
          self$`numTestedIn`
      }
      if (!is.null(self$`posSupp`)) {
        CoexpressionValueObjectExtObject[["posSupp"]] <-
          self$`posSupp`
      }
      if (!is.null(self$`queryGene`)) {
        CoexpressionValueObjectExtObject[["queryGene"]] <-
          self$`queryGene`$toJSON()
      }
      if (!is.null(self$`queryGeneNodeDegree`)) {
        CoexpressionValueObjectExtObject[["queryGeneNodeDegree"]] <-
          self$`queryGeneNodeDegree`
      }
      if (!is.null(self$`queryGeneNodeDegreeRank`)) {
        CoexpressionValueObjectExtObject[["queryGeneNodeDegreeRank"]] <-
          self$`queryGeneNodeDegreeRank`
      }
      if (!is.null(self$`sortKey`)) {
        CoexpressionValueObjectExtObject[["sortKey"]] <-
          self$`sortKey`
      }
      if (!is.null(self$`supportingExperiments`)) {
        CoexpressionValueObjectExtObject[["supportingExperiments"]] <-
          self$`supportingExperiments`
      }
      if (!is.null(self$`support`)) {
        CoexpressionValueObjectExtObject[["support"]] <-
          self$`support`
      }
      CoexpressionValueObjectExtObject
    },
    #' Deserialize JSON string into an instance of CoexpressionValueObjectExt
    #'
    #' @description
    #' Deserialize JSON string into an instance of CoexpressionValueObjectExt
    #'
    #' @param input_json the JSON input
    #' @return the instance of CoexpressionValueObjectExt
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`containsMyData`)) {
        self$`containsMyData` <- this_object$`containsMyData`
      }
      if (!is.null(this_object$`foundGene`)) {
        foundgene_object <- GeneValueObject$new()
        foundgene_object$fromJSON(jsonlite::toJSON(this_object$foundGene, auto_unbox = TRUE, digits = NA))
        self$`foundGene` <- foundgene_object
      }
      if (!is.null(this_object$`foundGeneNodeDegree`)) {
        self$`foundGeneNodeDegree` <- this_object$`foundGeneNodeDegree`
      }
      if (!is.null(this_object$`foundGeneNodeDegreeRank`)) {
        self$`foundGeneNodeDegreeRank` <- this_object$`foundGeneNodeDegreeRank`
      }
      if (!is.null(this_object$`negSupp`)) {
        self$`negSupp` <- this_object$`negSupp`
      }
      if (!is.null(this_object$`numTestedIn`)) {
        self$`numTestedIn` <- this_object$`numTestedIn`
      }
      if (!is.null(this_object$`posSupp`)) {
        self$`posSupp` <- this_object$`posSupp`
      }
      if (!is.null(this_object$`queryGene`)) {
        querygene_object <- GeneValueObject$new()
        querygene_object$fromJSON(jsonlite::toJSON(this_object$queryGene, auto_unbox = TRUE, digits = NA))
        self$`queryGene` <- querygene_object
      }
      if (!is.null(this_object$`queryGeneNodeDegree`)) {
        self$`queryGeneNodeDegree` <- this_object$`queryGeneNodeDegree`
      }
      if (!is.null(this_object$`queryGeneNodeDegreeRank`)) {
        self$`queryGeneNodeDegreeRank` <- this_object$`queryGeneNodeDegreeRank`
      }
      if (!is.null(this_object$`sortKey`)) {
        self$`sortKey` <- this_object$`sortKey`
      }
      if (!is.null(this_object$`supportingExperiments`)) {
        self$`supportingExperiments` <- ApiClient$new()$deserializeObj(this_object$`supportingExperiments`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`support`)) {
        self$`support` <- this_object$`support`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CoexpressionValueObjectExt in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`containsMyData`)) {
          sprintf(
          '"containsMyData":
            %s
                    ',
          tolower(self$`containsMyData`)
          )
        },
        if (!is.null(self$`foundGene`)) {
          sprintf(
          '"foundGene":
          %s
          ',
          jsonlite::toJSON(self$`foundGene`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`foundGeneNodeDegree`)) {
          sprintf(
          '"foundGeneNodeDegree":
            %d
                    ',
          self$`foundGeneNodeDegree`
          )
        },
        if (!is.null(self$`foundGeneNodeDegreeRank`)) {
          sprintf(
          '"foundGeneNodeDegreeRank":
            %d
                    ',
          self$`foundGeneNodeDegreeRank`
          )
        },
        if (!is.null(self$`negSupp`)) {
          sprintf(
          '"negSupp":
            %d
                    ',
          self$`negSupp`
          )
        },
        if (!is.null(self$`numTestedIn`)) {
          sprintf(
          '"numTestedIn":
            %d
                    ',
          self$`numTestedIn`
          )
        },
        if (!is.null(self$`posSupp`)) {
          sprintf(
          '"posSupp":
            %d
                    ',
          self$`posSupp`
          )
        },
        if (!is.null(self$`queryGene`)) {
          sprintf(
          '"queryGene":
          %s
          ',
          jsonlite::toJSON(self$`queryGene`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`queryGeneNodeDegree`)) {
          sprintf(
          '"queryGeneNodeDegree":
            %d
                    ',
          self$`queryGeneNodeDegree`
          )
        },
        if (!is.null(self$`queryGeneNodeDegreeRank`)) {
          sprintf(
          '"queryGeneNodeDegreeRank":
            %d
                    ',
          self$`queryGeneNodeDegreeRank`
          )
        },
        if (!is.null(self$`sortKey`)) {
          sprintf(
          '"sortKey":
            "%s"
                    ',
          self$`sortKey`
          )
        },
        if (!is.null(self$`supportingExperiments`)) {
          sprintf(
          '"supportingExperiments":
             [%s]
          ',
          paste(unlist(lapply(self$`supportingExperiments`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`support`)) {
          sprintf(
          '"support":
            %d
                    ',
          self$`support`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of CoexpressionValueObjectExt
    #'
    #' @description
    #' Deserialize JSON string into an instance of CoexpressionValueObjectExt
    #'
    #' @param input_json the JSON input
    #' @return the instance of CoexpressionValueObjectExt
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`containsMyData` <- this_object$`containsMyData`
      self$`foundGene` <- GeneValueObject$new()$fromJSON(jsonlite::toJSON(this_object$foundGene, auto_unbox = TRUE, digits = NA))
      self$`foundGeneNodeDegree` <- this_object$`foundGeneNodeDegree`
      self$`foundGeneNodeDegreeRank` <- this_object$`foundGeneNodeDegreeRank`
      self$`negSupp` <- this_object$`negSupp`
      self$`numTestedIn` <- this_object$`numTestedIn`
      self$`posSupp` <- this_object$`posSupp`
      self$`queryGene` <- GeneValueObject$new()$fromJSON(jsonlite::toJSON(this_object$queryGene, auto_unbox = TRUE, digits = NA))
      self$`queryGeneNodeDegree` <- this_object$`queryGeneNodeDegree`
      self$`queryGeneNodeDegreeRank` <- this_object$`queryGeneNodeDegreeRank`
      self$`sortKey` <- this_object$`sortKey`
      self$`supportingExperiments` <- ApiClient$new()$deserializeObj(this_object$`supportingExperiments`, "array[integer]", loadNamespace("gemma.R"))
      self$`support` <- this_object$`support`
      self
    },
    #' Validate JSON input with respect to CoexpressionValueObjectExt
    #'
    #' @description
    #' Validate JSON input with respect to CoexpressionValueObjectExt and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of CoexpressionValueObjectExt
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
CoexpressionValueObjectExt$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
CoexpressionValueObjectExt$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
CoexpressionValueObjectExt$lock()


#' Create a new CompositeSequence
#'
#' @description
#' CompositeSequence Class
#'
#' @docType class
#' @title CompositeSequence
#' @description CompositeSequence Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field biologicalCharacteristic  \link{BioSequence} optional
#' @field arrayDesign  \link{ArrayDesign} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
CompositeSequence <- R6::R6Class(
  "CompositeSequence",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `biologicalCharacteristic` = NULL,
    `arrayDesign` = NULL,
    #' Initialize a new CompositeSequence class.
    #'
    #' @description
    #' Initialize a new CompositeSequence class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param biologicalCharacteristic biologicalCharacteristic
    #' @param arrayDesign arrayDesign
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `biologicalCharacteristic` = NULL, `arrayDesign` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`biologicalCharacteristic`)) {
        stopifnot(R6::is.R6(`biologicalCharacteristic`))
        self$`biologicalCharacteristic` <- `biologicalCharacteristic`
      }
      if (!is.null(`arrayDesign`)) {
        stopifnot(R6::is.R6(`arrayDesign`))
        self$`arrayDesign` <- `arrayDesign`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CompositeSequence in JSON format
    #' @keywords internal
    toJSON = function() {
      CompositeSequenceObject <- list()
      if (!is.null(self$`name`)) {
        CompositeSequenceObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        CompositeSequenceObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        CompositeSequenceObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`biologicalCharacteristic`)) {
        CompositeSequenceObject[["biologicalCharacteristic"]] <-
          self$`biologicalCharacteristic`$toJSON()
      }
      if (!is.null(self$`arrayDesign`)) {
        CompositeSequenceObject[["arrayDesign"]] <-
          self$`arrayDesign`$toJSON()
      }
      CompositeSequenceObject
    },
    #' Deserialize JSON string into an instance of CompositeSequence
    #'
    #' @description
    #' Deserialize JSON string into an instance of CompositeSequence
    #'
    #' @param input_json the JSON input
    #' @return the instance of CompositeSequence
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`biologicalCharacteristic`)) {
        biologicalcharacteristic_object <- BioSequence$new()
        biologicalcharacteristic_object$fromJSON(jsonlite::toJSON(this_object$biologicalCharacteristic, auto_unbox = TRUE, digits = NA))
        self$`biologicalCharacteristic` <- biologicalcharacteristic_object
      }
      if (!is.null(this_object$`arrayDesign`)) {
        arraydesign_object <- ArrayDesign$new()
        arraydesign_object$fromJSON(jsonlite::toJSON(this_object$arrayDesign, auto_unbox = TRUE, digits = NA))
        self$`arrayDesign` <- arraydesign_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CompositeSequence in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`biologicalCharacteristic`)) {
          sprintf(
          '"biologicalCharacteristic":
          %s
          ',
          jsonlite::toJSON(self$`biologicalCharacteristic`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`arrayDesign`)) {
          sprintf(
          '"arrayDesign":
          %s
          ',
          jsonlite::toJSON(self$`arrayDesign`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of CompositeSequence
    #'
    #' @description
    #' Deserialize JSON string into an instance of CompositeSequence
    #'
    #' @param input_json the JSON input
    #' @return the instance of CompositeSequence
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`biologicalCharacteristic` <- BioSequence$new()$fromJSON(jsonlite::toJSON(this_object$biologicalCharacteristic, auto_unbox = TRUE, digits = NA))
      self$`arrayDesign` <- ArrayDesign$new()$fromJSON(jsonlite::toJSON(this_object$arrayDesign, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to CompositeSequence
    #'
    #' @description
    #' Validate JSON input with respect to CompositeSequence and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of CompositeSequence
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
CompositeSequence$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
CompositeSequence$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
CompositeSequence$lock()


#' @docType class
#' @title CompositeSequenceArg
#'
#' @description CompositeSequenceArg Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
CompositeSequenceArg <- R6::R6Class(
  "CompositeSequenceArg",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new CompositeSequenceArg.
    #'
    #' @description
    #' Initialize a new CompositeSequenceArg.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize CompositeSequenceArg with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of CompositeSequenceArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of CompositeSequenceArg.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of CompositeSequenceArg.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of CompositeSequenceArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of CompositeSequenceArg.
    #'
    #' @param input The input JSON.
    #' @return An instance of CompositeSequenceArg.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into CompositeSequenceArg with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into CompositeSequenceArg with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize CompositeSequenceArg to JSON string.
    #'
    #' @description
    #' Serialize CompositeSequenceArg to JSON string.
    #'
    #' @return JSON string representation of the CompositeSequenceArg.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize CompositeSequenceArg to JSON.
    #'
    #' @description
    #' Serialize CompositeSequenceArg to JSON.
    #'
    #' @return JSON representation of the CompositeSequenceArg.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to CompositeSequenceArg.
    #'
    #' @description
    #' Validate the input JSON with respect to CompositeSequenceArg and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
CompositeSequenceArg$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
CompositeSequenceArg$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
CompositeSequenceArg$lock()


#' Create a new CompositeSequenceValueObject
#'
#' @description
#' CompositeSequenceValueObject Class
#'
#' @docType class
#' @title CompositeSequenceValueObject
#' @description CompositeSequenceValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field name  character optional
#' @field description  character optional
#' @field arrayDesign  \link{ArrayDesignValueObject} optional
#' @field geneMappingSummaries  list(\link{GeneMappingSummary}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
CompositeSequenceValueObject <- R6::R6Class(
  "CompositeSequenceValueObject",
  public = list(
    `id` = NULL,
    `name` = NULL,
    `description` = NULL,
    `arrayDesign` = NULL,
    `geneMappingSummaries` = NULL,
    #' Initialize a new CompositeSequenceValueObject class.
    #'
    #' @description
    #' Initialize a new CompositeSequenceValueObject class.
    #'
    #' @param id id
    #' @param name name
    #' @param description description
    #' @param arrayDesign arrayDesign
    #' @param geneMappingSummaries geneMappingSummaries
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `name` = NULL, `description` = NULL, `arrayDesign` = NULL, `geneMappingSummaries` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`arrayDesign`)) {
        stopifnot(R6::is.R6(`arrayDesign`))
        self$`arrayDesign` <- `arrayDesign`
      }
      if (!is.null(`geneMappingSummaries`)) {
        stopifnot(is.vector(`geneMappingSummaries`), length(`geneMappingSummaries`) != 0)
        sapply(`geneMappingSummaries`, function(x) stopifnot(R6::is.R6(x)))
        self$`geneMappingSummaries` <- `geneMappingSummaries`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CompositeSequenceValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      CompositeSequenceValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        CompositeSequenceValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`name`)) {
        CompositeSequenceValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        CompositeSequenceValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`arrayDesign`)) {
        CompositeSequenceValueObjectObject[["arrayDesign"]] <-
          self$`arrayDesign`$toJSON()
      }
      if (!is.null(self$`geneMappingSummaries`)) {
        CompositeSequenceValueObjectObject[["geneMappingSummaries"]] <-
          lapply(self$`geneMappingSummaries`, function(x) x$toJSON())
      }
      CompositeSequenceValueObjectObject
    },
    #' Deserialize JSON string into an instance of CompositeSequenceValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of CompositeSequenceValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of CompositeSequenceValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`arrayDesign`)) {
        arraydesign_object <- ArrayDesignValueObject$new()
        arraydesign_object$fromJSON(jsonlite::toJSON(this_object$arrayDesign, auto_unbox = TRUE, digits = NA))
        self$`arrayDesign` <- arraydesign_object
      }
      if (!is.null(this_object$`geneMappingSummaries`)) {
        self$`geneMappingSummaries` <- ApiClient$new()$deserializeObj(this_object$`geneMappingSummaries`, "array[GeneMappingSummary]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CompositeSequenceValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`arrayDesign`)) {
          sprintf(
          '"arrayDesign":
          %s
          ',
          jsonlite::toJSON(self$`arrayDesign`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`geneMappingSummaries`)) {
          sprintf(
          '"geneMappingSummaries":
          [%s]
',
          paste(sapply(self$`geneMappingSummaries`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of CompositeSequenceValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of CompositeSequenceValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of CompositeSequenceValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`arrayDesign` <- ArrayDesignValueObject$new()$fromJSON(jsonlite::toJSON(this_object$arrayDesign, auto_unbox = TRUE, digits = NA))
      self$`geneMappingSummaries` <- ApiClient$new()$deserializeObj(this_object$`geneMappingSummaries`, "array[GeneMappingSummary]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to CompositeSequenceValueObject
    #'
    #' @description
    #' Validate JSON input with respect to CompositeSequenceValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of CompositeSequenceValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
CompositeSequenceValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
CompositeSequenceValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
CompositeSequenceValueObject$lock()


#' Create a new Compound
#'
#' @description
#' Compound Class
#'
#' @docType class
#' @title Compound
#' @description Compound Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field registryNumber  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Compound <- R6::R6Class(
  "Compound",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `registryNumber` = NULL,
    #' Initialize a new Compound class.
    #'
    #' @description
    #' Initialize a new Compound class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param registryNumber registryNumber
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `registryNumber` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`registryNumber`)) {
        stopifnot(is.character(`registryNumber`), length(`registryNumber`) == 1)
        self$`registryNumber` <- `registryNumber`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Compound in JSON format
    #' @keywords internal
    toJSON = function() {
      CompoundObject <- list()
      if (!is.null(self$`name`)) {
        CompoundObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        CompoundObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        CompoundObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`registryNumber`)) {
        CompoundObject[["registryNumber"]] <-
          self$`registryNumber`
      }
      CompoundObject
    },
    #' Deserialize JSON string into an instance of Compound
    #'
    #' @description
    #' Deserialize JSON string into an instance of Compound
    #'
    #' @param input_json the JSON input
    #' @return the instance of Compound
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`registryNumber`)) {
        self$`registryNumber` <- this_object$`registryNumber`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Compound in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`registryNumber`)) {
          sprintf(
          '"registryNumber":
            "%s"
                    ',
          self$`registryNumber`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Compound
    #'
    #' @description
    #' Deserialize JSON string into an instance of Compound
    #'
    #' @param input_json the JSON input
    #' @return the instance of Compound
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`registryNumber` <- this_object$`registryNumber`
      self
    },
    #' Validate JSON input with respect to Compound
    #'
    #' @description
    #' Validate JSON input with respect to Compound and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Compound
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Compound$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Compound$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Compound$lock()


#' Create a new Contact
#'
#' @description
#' Contact Class
#'
#' @docType class
#' @title Contact
#' @description Contact Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field email  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Contact <- R6::R6Class(
  "Contact",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `email` = NULL,
    #' Initialize a new Contact class.
    #'
    #' @description
    #' Initialize a new Contact class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param email email
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `email` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`email`)) {
        stopifnot(is.character(`email`), length(`email`) == 1)
        self$`email` <- `email`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Contact in JSON format
    #' @keywords internal
    toJSON = function() {
      ContactObject <- list()
      if (!is.null(self$`name`)) {
        ContactObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        ContactObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        ContactObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`email`)) {
        ContactObject[["email"]] <-
          self$`email`
      }
      ContactObject
    },
    #' Deserialize JSON string into an instance of Contact
    #'
    #' @description
    #' Deserialize JSON string into an instance of Contact
    #'
    #' @param input_json the JSON input
    #' @return the instance of Contact
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`email`)) {
        self$`email` <- this_object$`email`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Contact in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`email`)) {
          sprintf(
          '"email":
            "%s"
                    ',
          self$`email`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Contact
    #'
    #' @description
    #' Deserialize JSON string into an instance of Contact
    #'
    #' @param input_json the JSON input
    #' @return the instance of Contact
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`email` <- this_object$`email`
      self
    },
    #' Validate JSON input with respect to Contact
    #'
    #' @description
    #' Validate JSON input with respect to Contact and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Contact
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Contact$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Contact$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Contact$lock()


#' Create a new ContrastResultValueObject
#'
#' @description
#' ContrastResultValueObject Class
#'
#' @docType class
#' @title ContrastResultValueObject
#' @description ContrastResultValueObject Class
#' @format An \code{R6Class} generator object
#' @field pvalue  numeric optional
#' @field coefficient  numeric optional
#' @field logFoldChange  numeric optional
#' @field factorValue  \link{FactorValueBasicValueObject} optional
#' @field secondFactorValue  \link{FactorValueBasicValueObject} optional
#' @field tstat  numeric optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ContrastResultValueObject <- R6::R6Class(
  "ContrastResultValueObject",
  public = list(
    `pvalue` = NULL,
    `coefficient` = NULL,
    `logFoldChange` = NULL,
    `factorValue` = NULL,
    `secondFactorValue` = NULL,
    `tstat` = NULL,
    #' Initialize a new ContrastResultValueObject class.
    #'
    #' @description
    #' Initialize a new ContrastResultValueObject class.
    #'
    #' @param pvalue pvalue
    #' @param coefficient coefficient
    #' @param logFoldChange logFoldChange
    #' @param factorValue factorValue
    #' @param secondFactorValue secondFactorValue
    #' @param tstat tstat
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `pvalue` = NULL, `coefficient` = NULL, `logFoldChange` = NULL, `factorValue` = NULL, `secondFactorValue` = NULL, `tstat` = NULL, ...
    ) {
      if (!is.null(`pvalue`)) {
        stopifnot(is.numeric(`pvalue`), length(`pvalue`) == 1)
        self$`pvalue` <- `pvalue`
      }
      if (!is.null(`coefficient`)) {
        stopifnot(is.numeric(`coefficient`), length(`coefficient`) == 1)
        self$`coefficient` <- `coefficient`
      }
      if (!is.null(`logFoldChange`)) {
        stopifnot(is.numeric(`logFoldChange`), length(`logFoldChange`) == 1)
        self$`logFoldChange` <- `logFoldChange`
      }
      if (!is.null(`factorValue`)) {
        stopifnot(R6::is.R6(`factorValue`))
        self$`factorValue` <- `factorValue`
      }
      if (!is.null(`secondFactorValue`)) {
        stopifnot(R6::is.R6(`secondFactorValue`))
        self$`secondFactorValue` <- `secondFactorValue`
      }
      if (!is.null(`tstat`)) {
        stopifnot(is.numeric(`tstat`), length(`tstat`) == 1)
        self$`tstat` <- `tstat`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ContrastResultValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ContrastResultValueObjectObject <- list()
      if (!is.null(self$`pvalue`)) {
        ContrastResultValueObjectObject[["pvalue"]] <-
          self$`pvalue`
      }
      if (!is.null(self$`coefficient`)) {
        ContrastResultValueObjectObject[["coefficient"]] <-
          self$`coefficient`
      }
      if (!is.null(self$`logFoldChange`)) {
        ContrastResultValueObjectObject[["logFoldChange"]] <-
          self$`logFoldChange`
      }
      if (!is.null(self$`factorValue`)) {
        ContrastResultValueObjectObject[["factorValue"]] <-
          self$`factorValue`$toJSON()
      }
      if (!is.null(self$`secondFactorValue`)) {
        ContrastResultValueObjectObject[["secondFactorValue"]] <-
          self$`secondFactorValue`$toJSON()
      }
      if (!is.null(self$`tstat`)) {
        ContrastResultValueObjectObject[["tstat"]] <-
          self$`tstat`
      }
      ContrastResultValueObjectObject
    },
    #' Deserialize JSON string into an instance of ContrastResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ContrastResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ContrastResultValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`pvalue`)) {
        self$`pvalue` <- this_object$`pvalue`
      }
      if (!is.null(this_object$`coefficient`)) {
        self$`coefficient` <- this_object$`coefficient`
      }
      if (!is.null(this_object$`logFoldChange`)) {
        self$`logFoldChange` <- this_object$`logFoldChange`
      }
      if (!is.null(this_object$`factorValue`)) {
        factorvalue_object <- FactorValueBasicValueObject$new()
        factorvalue_object$fromJSON(jsonlite::toJSON(this_object$factorValue, auto_unbox = TRUE, digits = NA))
        self$`factorValue` <- factorvalue_object
      }
      if (!is.null(this_object$`secondFactorValue`)) {
        secondfactorvalue_object <- FactorValueBasicValueObject$new()
        secondfactorvalue_object$fromJSON(jsonlite::toJSON(this_object$secondFactorValue, auto_unbox = TRUE, digits = NA))
        self$`secondFactorValue` <- secondfactorvalue_object
      }
      if (!is.null(this_object$`tstat`)) {
        self$`tstat` <- this_object$`tstat`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ContrastResultValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`pvalue`)) {
          sprintf(
          '"pvalue":
            %d
                    ',
          self$`pvalue`
          )
        },
        if (!is.null(self$`coefficient`)) {
          sprintf(
          '"coefficient":
            %d
                    ',
          self$`coefficient`
          )
        },
        if (!is.null(self$`logFoldChange`)) {
          sprintf(
          '"logFoldChange":
            %d
                    ',
          self$`logFoldChange`
          )
        },
        if (!is.null(self$`factorValue`)) {
          sprintf(
          '"factorValue":
          %s
          ',
          jsonlite::toJSON(self$`factorValue`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`secondFactorValue`)) {
          sprintf(
          '"secondFactorValue":
          %s
          ',
          jsonlite::toJSON(self$`secondFactorValue`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`tstat`)) {
          sprintf(
          '"tstat":
            %d
                    ',
          self$`tstat`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ContrastResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ContrastResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ContrastResultValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`pvalue` <- this_object$`pvalue`
      self$`coefficient` <- this_object$`coefficient`
      self$`logFoldChange` <- this_object$`logFoldChange`
      self$`factorValue` <- FactorValueBasicValueObject$new()$fromJSON(jsonlite::toJSON(this_object$factorValue, auto_unbox = TRUE, digits = NA))
      self$`secondFactorValue` <- FactorValueBasicValueObject$new()$fromJSON(jsonlite::toJSON(this_object$secondFactorValue, auto_unbox = TRUE, digits = NA))
      self$`tstat` <- this_object$`tstat`
      self
    },
    #' Validate JSON input with respect to ContrastResultValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ContrastResultValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ContrastResultValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ContrastResultValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ContrastResultValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ContrastResultValueObject$lock()


#' Create a new CurationDetails
#'
#' @description
#' CurationDetails Class
#'
#' @docType class
#' @title CurationDetails
#' @description CurationDetails Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field lastUpdated  character optional
#' @field lastNeedsAttentionEvent  \link{AuditEvent} optional
#' @field needsAttention  character optional
#' @field lastTroubledEvent  \link{AuditEvent} optional
#' @field troubled  character optional
#' @field lastNoteUpdateEvent  \link{AuditEvent} optional
#' @field curationNote  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
CurationDetails <- R6::R6Class(
  "CurationDetails",
  public = list(
    `id` = NULL,
    `lastUpdated` = NULL,
    `lastNeedsAttentionEvent` = NULL,
    `needsAttention` = NULL,
    `lastTroubledEvent` = NULL,
    `troubled` = NULL,
    `lastNoteUpdateEvent` = NULL,
    `curationNote` = NULL,
    #' Initialize a new CurationDetails class.
    #'
    #' @description
    #' Initialize a new CurationDetails class.
    #'
    #' @param id id
    #' @param lastUpdated lastUpdated
    #' @param lastNeedsAttentionEvent lastNeedsAttentionEvent
    #' @param needsAttention needsAttention
    #' @param lastTroubledEvent lastTroubledEvent
    #' @param troubled troubled
    #' @param lastNoteUpdateEvent lastNoteUpdateEvent
    #' @param curationNote curationNote
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `lastUpdated` = NULL, `lastNeedsAttentionEvent` = NULL, `needsAttention` = NULL, `lastTroubledEvent` = NULL, `troubled` = NULL, `lastNoteUpdateEvent` = NULL, `curationNote` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`lastUpdated`)) {
        stopifnot(is.character(`lastUpdated`), length(`lastUpdated`) == 1)
        self$`lastUpdated` <- `lastUpdated`
      }
      if (!is.null(`lastNeedsAttentionEvent`)) {
        stopifnot(R6::is.R6(`lastNeedsAttentionEvent`))
        self$`lastNeedsAttentionEvent` <- `lastNeedsAttentionEvent`
      }
      if (!is.null(`needsAttention`)) {
        stopifnot(is.logical(`needsAttention`), length(`needsAttention`) == 1)
        self$`needsAttention` <- `needsAttention`
      }
      if (!is.null(`lastTroubledEvent`)) {
        stopifnot(R6::is.R6(`lastTroubledEvent`))
        self$`lastTroubledEvent` <- `lastTroubledEvent`
      }
      if (!is.null(`troubled`)) {
        stopifnot(is.logical(`troubled`), length(`troubled`) == 1)
        self$`troubled` <- `troubled`
      }
      if (!is.null(`lastNoteUpdateEvent`)) {
        stopifnot(R6::is.R6(`lastNoteUpdateEvent`))
        self$`lastNoteUpdateEvent` <- `lastNoteUpdateEvent`
      }
      if (!is.null(`curationNote`)) {
        stopifnot(is.character(`curationNote`), length(`curationNote`) == 1)
        self$`curationNote` <- `curationNote`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CurationDetails in JSON format
    #' @keywords internal
    toJSON = function() {
      CurationDetailsObject <- list()
      if (!is.null(self$`id`)) {
        CurationDetailsObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`lastUpdated`)) {
        CurationDetailsObject[["lastUpdated"]] <-
          self$`lastUpdated`
      }
      if (!is.null(self$`lastNeedsAttentionEvent`)) {
        CurationDetailsObject[["lastNeedsAttentionEvent"]] <-
          self$`lastNeedsAttentionEvent`$toJSON()
      }
      if (!is.null(self$`needsAttention`)) {
        CurationDetailsObject[["needsAttention"]] <-
          self$`needsAttention`
      }
      if (!is.null(self$`lastTroubledEvent`)) {
        CurationDetailsObject[["lastTroubledEvent"]] <-
          self$`lastTroubledEvent`$toJSON()
      }
      if (!is.null(self$`troubled`)) {
        CurationDetailsObject[["troubled"]] <-
          self$`troubled`
      }
      if (!is.null(self$`lastNoteUpdateEvent`)) {
        CurationDetailsObject[["lastNoteUpdateEvent"]] <-
          self$`lastNoteUpdateEvent`$toJSON()
      }
      if (!is.null(self$`curationNote`)) {
        CurationDetailsObject[["curationNote"]] <-
          self$`curationNote`
      }
      CurationDetailsObject
    },
    #' Deserialize JSON string into an instance of CurationDetails
    #'
    #' @description
    #' Deserialize JSON string into an instance of CurationDetails
    #'
    #' @param input_json the JSON input
    #' @return the instance of CurationDetails
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`lastUpdated`)) {
        self$`lastUpdated` <- this_object$`lastUpdated`
      }
      if (!is.null(this_object$`lastNeedsAttentionEvent`)) {
        lastneedsattentionevent_object <- AuditEvent$new()
        lastneedsattentionevent_object$fromJSON(jsonlite::toJSON(this_object$lastNeedsAttentionEvent, auto_unbox = TRUE, digits = NA))
        self$`lastNeedsAttentionEvent` <- lastneedsattentionevent_object
      }
      if (!is.null(this_object$`needsAttention`)) {
        self$`needsAttention` <- this_object$`needsAttention`
      }
      if (!is.null(this_object$`lastTroubledEvent`)) {
        lasttroubledevent_object <- AuditEvent$new()
        lasttroubledevent_object$fromJSON(jsonlite::toJSON(this_object$lastTroubledEvent, auto_unbox = TRUE, digits = NA))
        self$`lastTroubledEvent` <- lasttroubledevent_object
      }
      if (!is.null(this_object$`troubled`)) {
        self$`troubled` <- this_object$`troubled`
      }
      if (!is.null(this_object$`lastNoteUpdateEvent`)) {
        lastnoteupdateevent_object <- AuditEvent$new()
        lastnoteupdateevent_object$fromJSON(jsonlite::toJSON(this_object$lastNoteUpdateEvent, auto_unbox = TRUE, digits = NA))
        self$`lastNoteUpdateEvent` <- lastnoteupdateevent_object
      }
      if (!is.null(this_object$`curationNote`)) {
        self$`curationNote` <- this_object$`curationNote`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return CurationDetails in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`lastUpdated`)) {
          sprintf(
          '"lastUpdated":
            "%s"
                    ',
          self$`lastUpdated`
          )
        },
        if (!is.null(self$`lastNeedsAttentionEvent`)) {
          sprintf(
          '"lastNeedsAttentionEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastNeedsAttentionEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`needsAttention`)) {
          sprintf(
          '"needsAttention":
            %s
                    ',
          tolower(self$`needsAttention`)
          )
        },
        if (!is.null(self$`lastTroubledEvent`)) {
          sprintf(
          '"lastTroubledEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastTroubledEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`troubled`)) {
          sprintf(
          '"troubled":
            %s
                    ',
          tolower(self$`troubled`)
          )
        },
        if (!is.null(self$`lastNoteUpdateEvent`)) {
          sprintf(
          '"lastNoteUpdateEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastNoteUpdateEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`curationNote`)) {
          sprintf(
          '"curationNote":
            "%s"
                    ',
          self$`curationNote`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of CurationDetails
    #'
    #' @description
    #' Deserialize JSON string into an instance of CurationDetails
    #'
    #' @param input_json the JSON input
    #' @return the instance of CurationDetails
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`lastUpdated` <- this_object$`lastUpdated`
      self$`lastNeedsAttentionEvent` <- AuditEvent$new()$fromJSON(jsonlite::toJSON(this_object$lastNeedsAttentionEvent, auto_unbox = TRUE, digits = NA))
      self$`needsAttention` <- this_object$`needsAttention`
      self$`lastTroubledEvent` <- AuditEvent$new()$fromJSON(jsonlite::toJSON(this_object$lastTroubledEvent, auto_unbox = TRUE, digits = NA))
      self$`troubled` <- this_object$`troubled`
      self$`lastNoteUpdateEvent` <- AuditEvent$new()$fromJSON(jsonlite::toJSON(this_object$lastNoteUpdateEvent, auto_unbox = TRUE, digits = NA))
      self$`curationNote` <- this_object$`curationNote`
      self
    },
    #' Validate JSON input with respect to CurationDetails
    #'
    #' @description
    #' Validate JSON input with respect to CurationDetails and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of CurationDetails
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
CurationDetails$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
CurationDetails$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
CurationDetails$lock()


#' Create a new DatabaseEntry
#'
#' @description
#' DatabaseEntry Class
#'
#' @docType class
#' @title DatabaseEntry
#' @description DatabaseEntry Class
#' @format An \code{R6Class} generator object
#' @field accession  character optional
#' @field accessionVersion  character optional
#' @field id  integer optional
#' @field externalDatabase  \link{ExternalDatabase} optional
#' @field uri  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DatabaseEntry <- R6::R6Class(
  "DatabaseEntry",
  public = list(
    `accession` = NULL,
    `accessionVersion` = NULL,
    `id` = NULL,
    `externalDatabase` = NULL,
    `uri` = NULL,
    #' Initialize a new DatabaseEntry class.
    #'
    #' @description
    #' Initialize a new DatabaseEntry class.
    #'
    #' @param accession accession
    #' @param accessionVersion accessionVersion
    #' @param id id
    #' @param externalDatabase externalDatabase
    #' @param uri uri
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `accession` = NULL, `accessionVersion` = NULL, `id` = NULL, `externalDatabase` = NULL, `uri` = NULL, ...
    ) {
      if (!is.null(`accession`)) {
        stopifnot(is.character(`accession`), length(`accession`) == 1)
        self$`accession` <- `accession`
      }
      if (!is.null(`accessionVersion`)) {
        stopifnot(is.character(`accessionVersion`), length(`accessionVersion`) == 1)
        self$`accessionVersion` <- `accessionVersion`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`externalDatabase`)) {
        stopifnot(R6::is.R6(`externalDatabase`))
        self$`externalDatabase` <- `externalDatabase`
      }
      if (!is.null(`uri`)) {
        stopifnot(is.character(`uri`), length(`uri`) == 1)
        self$`uri` <- `uri`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DatabaseEntry in JSON format
    #' @keywords internal
    toJSON = function() {
      DatabaseEntryObject <- list()
      if (!is.null(self$`accession`)) {
        DatabaseEntryObject[["accession"]] <-
          self$`accession`
      }
      if (!is.null(self$`accessionVersion`)) {
        DatabaseEntryObject[["accessionVersion"]] <-
          self$`accessionVersion`
      }
      if (!is.null(self$`id`)) {
        DatabaseEntryObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`externalDatabase`)) {
        DatabaseEntryObject[["externalDatabase"]] <-
          self$`externalDatabase`$toJSON()
      }
      if (!is.null(self$`uri`)) {
        DatabaseEntryObject[["uri"]] <-
          self$`uri`
      }
      DatabaseEntryObject
    },
    #' Deserialize JSON string into an instance of DatabaseEntry
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseEntry
    #'
    #' @param input_json the JSON input
    #' @return the instance of DatabaseEntry
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`accession`)) {
        self$`accession` <- this_object$`accession`
      }
      if (!is.null(this_object$`accessionVersion`)) {
        self$`accessionVersion` <- this_object$`accessionVersion`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`externalDatabase`)) {
        externaldatabase_object <- ExternalDatabase$new()
        externaldatabase_object$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
        self$`externalDatabase` <- externaldatabase_object
      }
      if (!is.null(this_object$`uri`)) {
        self$`uri` <- this_object$`uri`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DatabaseEntry in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`accession`)) {
          sprintf(
          '"accession":
            "%s"
                    ',
          self$`accession`
          )
        },
        if (!is.null(self$`accessionVersion`)) {
          sprintf(
          '"accessionVersion":
            "%s"
                    ',
          self$`accessionVersion`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`externalDatabase`)) {
          sprintf(
          '"externalDatabase":
          %s
          ',
          jsonlite::toJSON(self$`externalDatabase`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`uri`)) {
          sprintf(
          '"uri":
            "%s"
                    ',
          self$`uri`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of DatabaseEntry
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseEntry
    #'
    #' @param input_json the JSON input
    #' @return the instance of DatabaseEntry
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`accession` <- this_object$`accession`
      self$`accessionVersion` <- this_object$`accessionVersion`
      self$`id` <- this_object$`id`
      self$`externalDatabase` <- ExternalDatabase$new()$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
      self$`uri` <- this_object$`uri`
      self
    },
    #' Validate JSON input with respect to DatabaseEntry
    #'
    #' @description
    #' Validate JSON input with respect to DatabaseEntry and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of DatabaseEntry
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DatabaseEntry$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DatabaseEntry$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DatabaseEntry$lock()


#' @docType class
#' @title DatabaseEntryArg
#'
#' @description DatabaseEntryArg Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DatabaseEntryArg <- R6::R6Class(
  "DatabaseEntryArg",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new DatabaseEntryArg.
    #'
    #' @description
    #' Initialize a new DatabaseEntryArg.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize DatabaseEntryArg with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of DatabaseEntryArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseEntryArg.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of DatabaseEntryArg.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of DatabaseEntryArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseEntryArg.
    #'
    #' @param input The input JSON.
    #' @return An instance of DatabaseEntryArg.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into DatabaseEntryArg with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into DatabaseEntryArg with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize DatabaseEntryArg to JSON string.
    #'
    #' @description
    #' Serialize DatabaseEntryArg to JSON string.
    #'
    #' @return JSON string representation of the DatabaseEntryArg.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize DatabaseEntryArg to JSON.
    #'
    #' @description
    #' Serialize DatabaseEntryArg to JSON.
    #'
    #' @return JSON representation of the DatabaseEntryArg.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to DatabaseEntryArg.
    #'
    #' @description
    #' Validate the input JSON with respect to DatabaseEntryArg and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DatabaseEntryArg$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DatabaseEntryArg$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DatabaseEntryArg$lock()


#' Create a new DatabaseEntryValueObject
#'
#' @description
#' DatabaseEntryValueObject Class
#'
#' @docType class
#' @title DatabaseEntryValueObject
#' @description DatabaseEntryValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field accession  character optional
#' @field externalDatabase  \link{ExternalDatabaseValueObject} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DatabaseEntryValueObject <- R6::R6Class(
  "DatabaseEntryValueObject",
  public = list(
    `id` = NULL,
    `accession` = NULL,
    `externalDatabase` = NULL,
    #' Initialize a new DatabaseEntryValueObject class.
    #'
    #' @description
    #' Initialize a new DatabaseEntryValueObject class.
    #'
    #' @param id id
    #' @param accession accession
    #' @param externalDatabase externalDatabase
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `accession` = NULL, `externalDatabase` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`accession`)) {
        stopifnot(is.character(`accession`), length(`accession`) == 1)
        self$`accession` <- `accession`
      }
      if (!is.null(`externalDatabase`)) {
        stopifnot(R6::is.R6(`externalDatabase`))
        self$`externalDatabase` <- `externalDatabase`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DatabaseEntryValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      DatabaseEntryValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        DatabaseEntryValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`accession`)) {
        DatabaseEntryValueObjectObject[["accession"]] <-
          self$`accession`
      }
      if (!is.null(self$`externalDatabase`)) {
        DatabaseEntryValueObjectObject[["externalDatabase"]] <-
          self$`externalDatabase`$toJSON()
      }
      DatabaseEntryValueObjectObject
    },
    #' Deserialize JSON string into an instance of DatabaseEntryValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseEntryValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DatabaseEntryValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`accession`)) {
        self$`accession` <- this_object$`accession`
      }
      if (!is.null(this_object$`externalDatabase`)) {
        externaldatabase_object <- ExternalDatabaseValueObject$new()
        externaldatabase_object$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
        self$`externalDatabase` <- externaldatabase_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DatabaseEntryValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`accession`)) {
          sprintf(
          '"accession":
            "%s"
                    ',
          self$`accession`
          )
        },
        if (!is.null(self$`externalDatabase`)) {
          sprintf(
          '"externalDatabase":
          %s
          ',
          jsonlite::toJSON(self$`externalDatabase`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of DatabaseEntryValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseEntryValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DatabaseEntryValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`accession` <- this_object$`accession`
      self$`externalDatabase` <- ExternalDatabaseValueObject$new()$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to DatabaseEntryValueObject
    #'
    #' @description
    #' Validate JSON input with respect to DatabaseEntryValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of DatabaseEntryValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DatabaseEntryValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DatabaseEntryValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DatabaseEntryValueObject$lock()


#' Create a new DatabaseType
#'
#' @description
#' DatabaseType Class
#'
#' @docType class
#' @title DatabaseType
#' @description DatabaseType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DatabaseType <- R6::R6Class(
  "DatabaseType",
  public = list(
    `value` = NULL,
    #' Initialize a new DatabaseType class.
    #'
    #' @description
    #' Initialize a new DatabaseType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DatabaseType in JSON format
    #' @keywords internal
    toJSON = function() {
      DatabaseTypeObject <- list()
      if (!is.null(self$`value`)) {
        DatabaseTypeObject[["value"]] <-
          self$`value`
      }
      DatabaseTypeObject
    },
    #' Deserialize JSON string into an instance of DatabaseType
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseType
    #'
    #' @param input_json the JSON input
    #' @return the instance of DatabaseType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DatabaseType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of DatabaseType
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatabaseType
    #'
    #' @param input_json the JSON input
    #' @return the instance of DatabaseType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to DatabaseType
    #'
    #' @description
    #' Validate JSON input with respect to DatabaseType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of DatabaseType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DatabaseType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DatabaseType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DatabaseType$lock()


#' @docType class
#' @title DatasetArg
#'
#' @description DatasetArg Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DatasetArg <- R6::R6Class(
  "DatasetArg",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new DatasetArg.
    #'
    #' @description
    #' Initialize a new DatasetArg.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize DatasetArg with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of DatasetArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatasetArg.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of DatasetArg.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of DatasetArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of DatasetArg.
    #'
    #' @param input The input JSON.
    #' @return An instance of DatasetArg.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into DatasetArg with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into DatasetArg with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize DatasetArg to JSON string.
    #'
    #' @description
    #' Serialize DatasetArg to JSON string.
    #'
    #' @return JSON string representation of the DatasetArg.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize DatasetArg to JSON.
    #'
    #' @description
    #' Serialize DatasetArg to JSON.
    #'
    #' @return JSON representation of the DatasetArg.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to DatasetArg.
    #'
    #' @description
    #' Validate the input JSON with respect to DatasetArg and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DatasetArg$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DatasetArg$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DatasetArg$lock()


#' Gemma RESTful API
#'
#' This website documents the usage of the Gemma REST API(https://gemma.msl.ubc.ca/rest/v2/). Here you can find example script usage of the API, as well as graphical interface for each endpoint, with description of its parameters and the endpoint URL.  The documentation of the underlying java code can be found here(https://gemma.msl.ubc.ca/resources/apidocs/ubic/gemma/web/services/rest/package-summary.html). See the links section(https://gemma.msl.ubc.ca/resources/restapidocs/#footer) in the footer of this page for other relevant links.  Use of this webpage and Gemma web services, including the REST API, is subject to these terms and conditions(https://pavlidislab.github.io/Gemma/terms.html). Please read these in full before continuing to use this webpage or any other part of the Gemma system. 
#'
#' The version of the OpenAPI document: 2.4.1
#' Contact: pavlab-support@msl.ubc.ca
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Default operations
#' @description 
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ get_api_info } \emph{ Retrieve an object with basic API information }
#'
#' \itemize{
#' \item \emph{ @returnType } \link{ResponseDataObjectApiInfoValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectApiInfoValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_annotations } \emph{ Retrieve the annotations analysis of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectSetAnnotationValueObject} \cr
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : ResponseDataObjectSetAnnotationValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_design } \emph{ Retrieve the design of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : data.frame
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_differential_expression } \emph{ Retrieve the expression levels of a set of datasets subject to a threshold on their differential expressions }
#'
#' \itemize{
#' \item \emph{ @param } datasets list( \link{GetResultSetsDatasetsParameterInner} )
#' \item \emph{ @param } diff_ex_set integer
#' \item \emph{ @param } threshold numeric
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } keep_non_specific character
#' \item \emph{ @param } consolidate Enum < pickmax, pickvar, average >
#' \item \emph{ @returnType } \link{ResponseDataObjectListExperimentExpressionLevelsValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListExperimentExpressionLevelsValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_differential_expression_analyses } \emph{ Retrieve the differential analyses of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @returnType } \link{ResponseDataObjectListDifferentialExpressionAnalysisValueObject} \cr
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : ResponseDataObjectListDifferentialExpressionAnalysisValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_differential_expression_analyses_result_sets } \emph{ Retrieve the result sets of all differential analyses of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#'
#'
#' \item status code : 302 | If the dataset is found, a redirection to the corresponding getResultSets operation.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_expression } \emph{ Retrieve the expression data of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#' \item \emph{ @param } filter character
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : data.frame
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 204 | The dataset expression matrix is empty.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_expression_for_genes } \emph{ Retrieve the expression data matrix of a set of datasets and genes }
#'
#' \itemize{
#' \item \emph{ @param } datasets list( \link{GetResultSetsDatasetsParameterInner} )
#' \item \emph{ @param } genes list( \link{GetDatasetExpressionForGenesGenesParameterInner} )
#' \item \emph{ @param } keep_non_specific character
#' \item \emph{ @param } consolidate Enum < pickmax, pickvar, average >
#' \item \emph{ @returnType } \link{ResponseDataObjectListExperimentExpressionLevelsValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListExperimentExpressionLevelsValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_expression_pca } \emph{ Retrieve the principal components (PCA) of a set of datasets }
#'
#' \itemize{
#' \item \emph{ @param } datasets list( \link{GetResultSetsDatasetsParameterInner} )
#' \item \emph{ @param } component integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } keep_non_specific character
#' \item \emph{ @param } consolidate Enum < pickmax, pickvar, average >
#' \item \emph{ @returnType } \link{ResponseDataObjectListExperimentExpressionLevelsValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListExperimentExpressionLevelsValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_platforms } \emph{ Retrieve the platform of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectListArrayDesignValueObject} \cr
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : ResponseDataObjectListArrayDesignValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_raw_expression } \emph{ Retrieve raw expression data of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : data.frame
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_samples } \emph{ Retrieve the samples of a dataset }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectListBioAssayValueObject} \cr
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : ResponseDataObjectListBioAssayValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_dataset_svd } \emph{ Retrieve the singular value decomposition (SVD) of a dataset expression data }
#'
#' \itemize{
#' \item \emph{ @param } dataset \link{GetResultSetsDatasetsParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectSimpleSVDValueObject} \cr
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : ResponseDataObjectSimpleSVDValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The dataset does not exist.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_datasets } \emph{ Retrieve all datasets }
#'
#' \itemize{
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectExpressionExperimentValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectExpressionExperimentValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_datasets_by_ids } \emph{ Retrieve datasets by their identifiers }
#'
#' \itemize{
#' \item \emph{ @param } dataset list( \link{GetResultSetsDatasetsParameterInner} )
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectExpressionExperimentValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectExpressionExperimentValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_gene_gene_coexpression } \emph{ Retrieve the coexpression of two given genes }
#'
#' \itemize{
#' \item \emph{ @param } gene \link{GetDatasetExpressionForGenesGenesParameterInner}
#' \item \emph{ @param } with \link{GetDatasetExpressionForGenesGenesParameterInner}
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } stringency integer
#' \item \emph{ @returnType } \link{ResponseDataObjectListCoexpressionValueObjectExt} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListCoexpressionValueObjectExt
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_gene_go_terms } \emph{ Retrieve the GO terms associated to a gene }
#'
#' \itemize{
#' \item \emph{ @param } gene \link{GetDatasetExpressionForGenesGenesParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectListGeneOntologyTermValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListGeneOntologyTermValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_gene_locations } \emph{ Retrieve the physical locations of a given gene }
#'
#' \itemize{
#' \item \emph{ @param } gene \link{GetDatasetExpressionForGenesGenesParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectListPhysicalLocationValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListPhysicalLocationValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_gene_locations_in_taxon } \emph{ Retrieve physical locations for a given gene and taxon }
#'
#' \itemize{
#' \item \emph{ @param } taxon \link{SearchTaxonDatasetsTaxonParameter}
#' \item \emph{ @param } gene \link{GetDatasetExpressionForGenesGenesParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectListPhysicalLocationValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListPhysicalLocationValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_gene_probes } \emph{ Retrieve the probes associated to a genes }
#'
#' \itemize{
#' \item \emph{ @param } gene \link{GetDatasetExpressionForGenesGenesParameterInner}
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectCompositeSequenceValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectCompositeSequenceValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_genes } \emph{ Retrieve genes matching a gene identifier }
#'
#' \itemize{
#' \item \emph{ @param } genes list( \link{GetDatasetExpressionForGenesGenesParameterInner} )
#' \item \emph{ @returnType } \link{ResponseDataObjectListGeneValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListGeneValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_platform_annotations } \emph{ Retrieve the annotations of a given platform }
#'
#' \itemize{
#' \item \emph{ @param } platform \link{GetPlatformAnnotationsPlatformParameter}
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : data.frame
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_platform_datasets } \emph{ Retrieve all experiments within a given platform }
#'
#' \itemize{
#' \item \emph{ @param } platform \link{GetPlatformAnnotationsPlatformParameter}
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectExpressionExperimentValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectExpressionExperimentValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_platform_element } \emph{ Retrieve the selected composite sequences for a given platform }
#'
#' \itemize{
#' \item \emph{ @param } platform \link{GetPlatformAnnotationsPlatformParameter}
#' \item \emph{ @param } probes list( \link{GetPlatformElementProbesParameterInner} )
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectCompositeSequenceValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectCompositeSequenceValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_platform_element_genes } \emph{ Retrieve the genes associated to a probe in a given platform }
#'
#' \itemize{
#' \item \emph{ @param } platform \link{GetPlatformAnnotationsPlatformParameter}
#' \item \emph{ @param } probe \link{GetPlatformElementProbesParameterInner}
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectGeneValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectGeneValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_platform_elements } \emph{ Retrieve the composite sequences for a given platform }
#'
#' \itemize{
#' \item \emph{ @param } platform \link{GetPlatformAnnotationsPlatformParameter}
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectCompositeSequenceValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectCompositeSequenceValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_platforms } \emph{ Retrieve all platforms }
#'
#' \itemize{
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectArrayDesignValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectArrayDesignValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_platforms_by_ids } \emph{ Retrieve all platforms matching a set of platform identifiers }
#'
#' \itemize{
#' \item \emph{ @param } platform list( \link{GetPlatformAnnotationsPlatformParameter} )
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectArrayDesignValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectArrayDesignValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_result_set } \emph{ Retrieve a single analysis result set by its identifier }
#'
#' \itemize{
#' \item \emph{ @param } result_set integer
#' \item \emph{ @returnType } \link{ResponseDataObjectExpressionAnalysisResultSetValueObject} \cr
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : ResponseDataObjectExpressionAnalysisResultSetValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The analysis result set could not be found.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_result_set_as_tsv } \emph{ Retrieve a single analysis result set by its identifier as a tab-separated values }
#'
#' \itemize{
#' \item \emph{ @param } result_set_ integer
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : data.frame
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | The analysis result set could not be found.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_result_sets } \emph{ Retrieve all result sets matching the provided criteria }
#'
#' \itemize{
#' \item \emph{ @param } datasets list( \link{GetResultSetsDatasetsParameterInner} )
#' \item \emph{ @param } database_entries list( \link{GetResultSetsDatabaseEntriesParameterInner} )
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_taxa } \emph{ Retrieve all available taxa }
#'
#' \itemize{
#' \item \emph{ @returnType } \link{ResponseDataObjectListTaxonValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListTaxonValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_taxa_by_ids } \emph{ Retrieve taxa by their identifiers }
#'
#' \itemize{
#' \item \emph{ @param } taxa list( \link{SearchTaxonDatasetsTaxonParameter} )
#' \item \emph{ @returnType } \link{ResponseDataObjectListTaxonValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListTaxonValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_taxon_datasets } \emph{ Retrieve the datasets for a given taxon }
#'
#' \itemize{
#' \item \emph{ @param } taxon \link{SearchTaxonDatasetsTaxonParameter}
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectExpressionExperimentValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectExpressionExperimentValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_taxon_genes } \emph{ Retrieve all genes in a given taxon }
#'
#' \itemize{
#' \item \emph{ @param } taxon \link{SearchTaxonDatasetsTaxonParameter}
#' \item \emph{ @param } gene \link{GetDatasetExpressionForGenesGenesParameterInner}
#' \item \emph{ @returnType } \link{ResponseDataObjectListGeneValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListGeneValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ get_taxon_genes_overlapping_chromosome } \emph{ Retrieve genes overlapping a given region in a taxon }
#'
#' \itemize{
#' \item \emph{ @param } taxon \link{SearchTaxonDatasetsTaxonParameter}
#' \item \emph{ @param } chromosome character
#' \item \emph{ @param } strand character
#' \item \emph{ @param } start integer
#' \item \emph{ @param } size integer
#' \item \emph{ @returnType } \link{ResponseDataObjectListGeneValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : ResponseDataObjectListGeneValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ search } \emph{ Search everything in Gemma. }
#'
#' \itemize{
#' \item \emph{ @param } query character
#' \item \emph{ @param } taxon \link{SearchTaxonDatasetsTaxonParameter}
#' \item \emph{ @param } platform \link{GetPlatformAnnotationsPlatformParameter}
#' \item \emph{ @param } result_types Enum < ubic.gemma.model.common.description.BibliographicReference, ubic.gemma.model.analysis.expression.ExpressionExperimentSet, ubic.gemma.model.genome.gene.GeneSet, ubic.gemma.model.genome.Gene, ubic.gemma.model.expression.experiment.ExpressionExperiment, ubic.gemma.model.genome.biosequence.BioSequence, ubic.gemma.model.association.phenotype.PhenotypeAssociation, ubic.gemma.model.expression.arrayDesign.ArrayDesign, ubic.gemma.model.expression.designElement.CompositeSequence >
#' \item \emph{ @param } limit integer
#' \item \emph{ @returnType } \link{SearchResultsResponseDataObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : SearchResultsResponseDataObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ search_annotations } \emph{ Search for annotation tags }
#'
#' \itemize{
#' \item \emph{ @param } query list( character )
#' \item \emph{ @returnType } \link{ResponseDataObjectListAnnotationSearchResultValueObject} \cr
#'
#'
#' \item status code : 200 | 
#'
#' \item return type : ResponseDataObjectListAnnotationSearchResultValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | The search query is empty.
#'
#' \item return type : ResponseErrorObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ search_datasets } \emph{ Retrieve datasets associated to an annotation tags search }
#'
#' \itemize{
#' \item \emph{ @param } query list( character )
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectExpressionExperimentValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectExpressionExperimentValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ search_taxon_datasets } \emph{ Retrieve datasets within a given taxa associated to an annotation tags search }
#'
#' \itemize{
#' \item \emph{ @param } taxon \link{SearchTaxonDatasetsTaxonParameter}
#' \item \emph{ @param } query list( character )
#' \item \emph{ @param } filter character
#' \item \emph{ @param } offset integer
#' \item \emph{ @param } limit integer
#' \item \emph{ @param } sort character
#' \item \emph{ @returnType } \link{PaginatedResponseDataObjectExpressionExperimentValueObject} \cr
#'
#'
#' \item status code : 0 | default response
#'
#' \item return type : PaginatedResponseDataObjectExpressionExperimentValueObject
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  get_api_info  ####################
#'
#' library(gemma.R)
#'
#' #Retrieve an object with basic API information
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_api_info(data_file = "result.txt")
#' result <- api_instance$get_api_info()
#' dput(result)
#'
#'
#' ####################  get_dataset_annotations  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#'
#' #Retrieve the annotations analysis of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_annotations(var_datasetdata_file = "result.txt")
#' result <- api_instance$get_dataset_annotations(var_dataset)
#' dput(result)
#'
#'
#' ####################  get_dataset_design  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#'
#' #Retrieve the design of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_design(var_datasetdata_file = "result.txt")
#' result <- api_instance$get_dataset_design(var_dataset)
#' dput(result)
#'
#'
#' ####################  get_dataset_differential_expression  ####################
#'
#' library(gemma.R)
#' var_datasets <- GetResultSetsDatasetsParameterInner$new() # arrayGetResultSetsDatasetsParameterInner | 
#' var_diff_ex_set <- 56 # integer | 
#' var_threshold <- 1.0 # numeric | 
#' var_limit <- 100 # integer | 
#' var_keep_non_specific <- FALSE # character | 
#' var_consolidate <- "consolidate_example" # character | 
#'
#' #Retrieve the expression levels of a set of datasets subject to a threshold on their differential expressions
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_differential_expression(var_datasets, diff_ex_set = var_diff_ex_set, threshold = var_threshold, limit = var_limit, keep_non_specific = var_keep_non_specific, consolidate = var_consolidatedata_file = "result.txt")
#' result <- api_instance$get_dataset_differential_expression(var_datasets, diff_ex_set = var_diff_ex_set, threshold = var_threshold, limit = var_limit, keep_non_specific = var_keep_non_specific, consolidate = var_consolidate)
#' dput(result)
#'
#'
#' ####################  get_dataset_differential_expression_analyses  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#'
#' #Retrieve the differential analyses of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_differential_expression_analyses(var_dataset, offset = var_offset, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$get_dataset_differential_expression_analyses(var_dataset, offset = var_offset, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  get_dataset_differential_expression_analyses_result_sets  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#'
#' #Retrieve the result sets of all differential analyses of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' api_instance$get_dataset_differential_expression_analyses_result_sets(var_dataset)
#'
#'
#' ####################  get_dataset_expression  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#' var_filter <- FALSE # character | 
#'
#' #Retrieve the expression data of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_expression(var_dataset, filter = var_filterdata_file = "result.txt")
#' result <- api_instance$get_dataset_expression(var_dataset, filter = var_filter)
#' dput(result)
#'
#'
#' ####################  get_dataset_expression_for_genes  ####################
#'
#' library(gemma.R)
#' var_datasets <- GetResultSetsDatasetsParameterInner$new() # arrayGetResultSetsDatasetsParameterInner | 
#' var_genes <- GetDatasetExpressionForGenesGenesParameterInner$new() # arrayGetDatasetExpressionForGenesGenesParameterInner | 
#' var_keep_non_specific <- FALSE # character | 
#' var_consolidate <- "consolidate_example" # character | 
#'
#' #Retrieve the expression data matrix of a set of datasets and genes
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_expression_for_genes(var_datasets, var_genes, keep_non_specific = var_keep_non_specific, consolidate = var_consolidatedata_file = "result.txt")
#' result <- api_instance$get_dataset_expression_for_genes(var_datasets, var_genes, keep_non_specific = var_keep_non_specific, consolidate = var_consolidate)
#' dput(result)
#'
#'
#' ####################  get_dataset_expression_pca  ####################
#'
#' library(gemma.R)
#' var_datasets <- GetResultSetsDatasetsParameterInner$new() # arrayGetResultSetsDatasetsParameterInner | 
#' var_component <- 1 # integer | 
#' var_limit <- 100 # integer | 
#' var_keep_non_specific <- FALSE # character | 
#' var_consolidate <- "consolidate_example" # character | 
#'
#' #Retrieve the principal components (PCA) of a set of datasets
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_expression_pca(var_datasets, component = var_component, limit = var_limit, keep_non_specific = var_keep_non_specific, consolidate = var_consolidatedata_file = "result.txt")
#' result <- api_instance$get_dataset_expression_pca(var_datasets, component = var_component, limit = var_limit, keep_non_specific = var_keep_non_specific, consolidate = var_consolidate)
#' dput(result)
#'
#'
#' ####################  get_dataset_platforms  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#'
#' #Retrieve the platform of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_platforms(var_datasetdata_file = "result.txt")
#' result <- api_instance$get_dataset_platforms(var_dataset)
#' dput(result)
#'
#'
#' ####################  get_dataset_raw_expression  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#'
#' #Retrieve raw expression data of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_raw_expression(var_datasetdata_file = "result.txt")
#' result <- api_instance$get_dataset_raw_expression(var_dataset)
#' dput(result)
#'
#'
#' ####################  get_dataset_samples  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#'
#' #Retrieve the samples of a dataset
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_samples(var_datasetdata_file = "result.txt")
#' result <- api_instance$get_dataset_samples(var_dataset)
#' dput(result)
#'
#'
#' ####################  get_dataset_svd  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # GetResultSetsDatasetsParameterInner | 
#'
#' #Retrieve the singular value decomposition (SVD) of a dataset expression data
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_dataset_svd(var_datasetdata_file = "result.txt")
#' result <- api_instance$get_dataset_svd(var_dataset)
#' dput(result)
#'
#'
#' ####################  get_datasets  ####################
#'
#' library(gemma.R)
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve all datasets
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_datasets(filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$get_datasets(filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  get_datasets_by_ids  ####################
#'
#' library(gemma.R)
#' var_dataset <- GetResultSetsDatasetsParameterInner$new() # arrayGetResultSetsDatasetsParameterInner | 
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve datasets by their identifiers
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_datasets_by_ids(var_dataset, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$get_datasets_by_ids(var_dataset, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  get_gene_gene_coexpression  ####################
#'
#' library(gemma.R)
#' var_gene <- GetDatasetExpressionForGenesGenesParameterInner$new() # GetDatasetExpressionForGenesGenesParameterInner | 
#' var_with <- GetDatasetExpressionForGenesGenesParameterInner$new() # GetDatasetExpressionForGenesGenesParameterInner | 
#' var_limit <- 100 # integer | 
#' var_stringency <- 1 # integer | 
#'
#' #Retrieve the coexpression of two given genes
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_gene_gene_coexpression(var_gene, with = var_with, limit = var_limit, stringency = var_stringencydata_file = "result.txt")
#' result <- api_instance$get_gene_gene_coexpression(var_gene, with = var_with, limit = var_limit, stringency = var_stringency)
#' dput(result)
#'
#'
#' ####################  get_gene_go_terms  ####################
#'
#' library(gemma.R)
#' var_gene <- GetDatasetExpressionForGenesGenesParameterInner$new() # GetDatasetExpressionForGenesGenesParameterInner | 
#'
#' #Retrieve the GO terms associated to a gene
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_gene_go_terms(var_genedata_file = "result.txt")
#' result <- api_instance$get_gene_go_terms(var_gene)
#' dput(result)
#'
#'
#' ####################  get_gene_locations  ####################
#'
#' library(gemma.R)
#' var_gene <- GetDatasetExpressionForGenesGenesParameterInner$new() # GetDatasetExpressionForGenesGenesParameterInner | 
#'
#' #Retrieve the physical locations of a given gene
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_gene_locations(var_genedata_file = "result.txt")
#' result <- api_instance$get_gene_locations(var_gene)
#' dput(result)
#'
#'
#' ####################  get_gene_locations_in_taxon  ####################
#'
#' library(gemma.R)
#' var_taxon <- SearchTaxonDatasetsTaxonParameter$new() # SearchTaxonDatasetsTaxonParameter | 
#' var_gene <- GetDatasetExpressionForGenesGenesParameterInner$new() # GetDatasetExpressionForGenesGenesParameterInner | 
#'
#' #Retrieve physical locations for a given gene and taxon
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_gene_locations_in_taxon(var_taxon, var_genedata_file = "result.txt")
#' result <- api_instance$get_gene_locations_in_taxon(var_taxon, var_gene)
#' dput(result)
#'
#'
#' ####################  get_gene_probes  ####################
#'
#' library(gemma.R)
#' var_gene <- GetDatasetExpressionForGenesGenesParameterInner$new() # GetDatasetExpressionForGenesGenesParameterInner | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#'
#' #Retrieve the probes associated to a genes
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_gene_probes(var_gene, offset = var_offset, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$get_gene_probes(var_gene, offset = var_offset, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  get_genes  ####################
#'
#' library(gemma.R)
#' var_genes <- GetDatasetExpressionForGenesGenesParameterInner$new() # arrayGetDatasetExpressionForGenesGenesParameterInner | 
#'
#' #Retrieve genes matching a gene identifier
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_genes(var_genesdata_file = "result.txt")
#' result <- api_instance$get_genes(var_genes)
#' dput(result)
#'
#'
#' ####################  get_platform_annotations  ####################
#'
#' library(gemma.R)
#' var_platform <- GetPlatformAnnotationsPlatformParameter$new() # GetPlatformAnnotationsPlatformParameter | 
#'
#' #Retrieve the annotations of a given platform
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_platform_annotations(var_platformdata_file = "result.txt")
#' result <- api_instance$get_platform_annotations(var_platform)
#' dput(result)
#'
#'
#' ####################  get_platform_datasets  ####################
#'
#' library(gemma.R)
#' var_platform <- GetPlatformAnnotationsPlatformParameter$new() # GetPlatformAnnotationsPlatformParameter | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#'
#' #Retrieve all experiments within a given platform
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_platform_datasets(var_platform, offset = var_offset, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$get_platform_datasets(var_platform, offset = var_offset, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  get_platform_element  ####################
#'
#' library(gemma.R)
#' var_platform <- GetPlatformAnnotationsPlatformParameter$new() # GetPlatformAnnotationsPlatformParameter | 
#' var_probes <- GetPlatformElementProbesParameterInner$new() # arrayGetPlatformElementProbesParameterInner | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#'
#' #Retrieve the selected composite sequences for a given platform
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_platform_element(var_platform, var_probes, offset = var_offset, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$get_platform_element(var_platform, var_probes, offset = var_offset, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  get_platform_element_genes  ####################
#'
#' library(gemma.R)
#' var_platform <- GetPlatformAnnotationsPlatformParameter$new() # GetPlatformAnnotationsPlatformParameter | 
#' var_probe <- GetPlatformElementProbesParameterInner$new() # GetPlatformElementProbesParameterInner | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#'
#' #Retrieve the genes associated to a probe in a given platform
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_platform_element_genes(var_platform, var_probe, offset = var_offset, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$get_platform_element_genes(var_platform, var_probe, offset = var_offset, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  get_platform_elements  ####################
#'
#' library(gemma.R)
#' var_platform <- GetPlatformAnnotationsPlatformParameter$new() # GetPlatformAnnotationsPlatformParameter | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#'
#' #Retrieve the composite sequences for a given platform
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_platform_elements(var_platform, offset = var_offset, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$get_platform_elements(var_platform, offset = var_offset, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  get_platforms  ####################
#'
#' library(gemma.R)
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve all platforms
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_platforms(filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$get_platforms(filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  get_platforms_by_ids  ####################
#'
#' library(gemma.R)
#' var_platform <- GetPlatformAnnotationsPlatformParameter$new() # arrayGetPlatformAnnotationsPlatformParameter | 
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve all platforms matching a set of platform identifiers
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_platforms_by_ids(var_platform, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$get_platforms_by_ids(var_platform, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  get_result_set  ####################
#'
#' library(gemma.R)
#' var_result_set <- 56 # integer | 
#'
#' #Retrieve a single analysis result set by its identifier
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_result_set(var_result_setdata_file = "result.txt")
#' result <- api_instance$get_result_set(var_result_set)
#' dput(result)
#'
#'
#' ####################  get_result_set_as_tsv  ####################
#'
#' library(gemma.R)
#' var_result_set_ <- 56 # integer | 
#'
#' #Retrieve a single analysis result set by its identifier as a tab-separated values
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_result_set_as_tsv(var_result_set_data_file = "result.txt")
#' result <- api_instance$get_result_set_as_tsv(var_result_set_)
#' dput(result)
#'
#'
#' ####################  get_result_sets  ####################
#'
#' library(gemma.R)
#' var_datasets <- GetResultSetsDatasetsParameterInner$new() # arrayGetResultSetsDatasetsParameterInner | 
#' var_database_entries <- GetResultSetsDatabaseEntriesParameterInner$new() # arrayGetResultSetsDatabaseEntriesParameterInner | 
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve all result sets matching the provided criteria
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_result_sets(datasets = var_datasets, database_entries = var_database_entries, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$get_result_sets(datasets = var_datasets, database_entries = var_database_entries, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  get_taxa  ####################
#'
#' library(gemma.R)
#'
#' #Retrieve all available taxa
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_taxa(data_file = "result.txt")
#' result <- api_instance$get_taxa()
#' dput(result)
#'
#'
#' ####################  get_taxa_by_ids  ####################
#'
#' library(gemma.R)
#' var_taxa <- SearchTaxonDatasetsTaxonParameter$new() # arraySearchTaxonDatasetsTaxonParameter | 
#'
#' #Retrieve taxa by their identifiers
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_taxa_by_ids(var_taxadata_file = "result.txt")
#' result <- api_instance$get_taxa_by_ids(var_taxa)
#' dput(result)
#'
#'
#' ####################  get_taxon_datasets  ####################
#'
#' library(gemma.R)
#' var_taxon <- SearchTaxonDatasetsTaxonParameter$new() # SearchTaxonDatasetsTaxonParameter | 
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve the datasets for a given taxon
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_taxon_datasets(var_taxon, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$get_taxon_datasets(var_taxon, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  get_taxon_genes  ####################
#'
#' library(gemma.R)
#' var_taxon <- SearchTaxonDatasetsTaxonParameter$new() # SearchTaxonDatasetsTaxonParameter | 
#' var_gene <- GetDatasetExpressionForGenesGenesParameterInner$new() # GetDatasetExpressionForGenesGenesParameterInner | 
#'
#' #Retrieve all genes in a given taxon
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_taxon_genes(var_taxon, var_genedata_file = "result.txt")
#' result <- api_instance$get_taxon_genes(var_taxon, var_gene)
#' dput(result)
#'
#'
#' ####################  get_taxon_genes_overlapping_chromosome  ####################
#'
#' library(gemma.R)
#' var_taxon <- SearchTaxonDatasetsTaxonParameter$new() # SearchTaxonDatasetsTaxonParameter | 
#' var_chromosome <- "chromosome_example" # character | 
#' var_strand <- "+" # character | 
#' var_start <- 56 # integer | 
#' var_size <- 56 # integer | 
#'
#' #Retrieve genes overlapping a given region in a taxon
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$get_taxon_genes_overlapping_chromosome(var_taxon, var_chromosome, strand = var_strand, start = var_start, size = var_sizedata_file = "result.txt")
#' result <- api_instance$get_taxon_genes_overlapping_chromosome(var_taxon, var_chromosome, strand = var_strand, start = var_start, size = var_size)
#' dput(result)
#'
#'
#' ####################  search  ####################
#'
#' library(gemma.R)
#' var_query <- "query_example" # character | 
#' var_taxon <- SearchTaxonDatasetsTaxonParameter$new() # SearchTaxonDatasetsTaxonParameter | 
#' var_platform <- GetPlatformAnnotationsPlatformParameter$new() # GetPlatformAnnotationsPlatformParameter | 
#' var_result_types <- "result_types_example" # arraycharacter | 
#' var_limit <- 20 # integer | 
#'
#' #Search everything in Gemma.
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$search(query = var_query, taxon = var_taxon, platform = var_platform, result_types = var_result_types, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$search(query = var_query, taxon = var_taxon, platform = var_platform, result_types = var_result_types, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  search_annotations  ####################
#'
#' library(gemma.R)
#' var_query <- "query_example" # arraycharacter | 
#'
#' #Search for annotation tags
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$search_annotations(var_querydata_file = "result.txt")
#' result <- api_instance$search_annotations(var_query)
#' dput(result)
#'
#'
#' ####################  search_datasets  ####################
#'
#' library(gemma.R)
#' var_query <- "query_example" # arraycharacter | 
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve datasets associated to an annotation tags search
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$search_datasets(var_query, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$search_datasets(var_query, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  search_taxon_datasets  ####################
#'
#' library(gemma.R)
#' var_taxon <- SearchTaxonDatasetsTaxonParameter$new() # SearchTaxonDatasetsTaxonParameter | 
#' var_query <- "query_example" # arraycharacter | 
#' var_filter <- "" # character | 
#' var_offset <- 0 # integer | 
#' var_limit <- 20 # integer | 
#' var_sort <- "+id" # character | 
#'
#' #Retrieve datasets within a given taxa associated to an annotation tags search
#' api_instance <- DefaultApi$new()
#'
#' # Configure HTTP basic authorization: basicAuth
#' api_instance$api_client$username <- Sys.getenv("USERNAME")
#' api_instance$api_client$password <- Sys.getenv("PASSWORD")
#'
#' # Configure API key authorization: cookieAuth
#' api_instance$api_client$api_keys"JSESSIONID" <- Sys.getenv("API_KEY")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$search_taxon_datasets(var_taxon, var_query, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$search_taxon_datasets(var_taxon, var_query, filter = var_filter, offset = var_offset, limit = var_limit, sort = var_sort)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @keywords internal
DefaultApi <- R6::R6Class(
  "DefaultApi",
  public = list(
    api_client = NULL,
    #' Initialize a new DefaultApi.
    #'
    #' @description
    #' Initialize a new DefaultApi.
    #'
    #' @param api_client An instance of API client.
    #' @keywords internal
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    #' Retrieve an object with basic API information
    #'
    #' @description
    #' Retrieve an object with basic API information
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectApiInfoValueObject
    #' @keywords internal
    get_api_info = function(data_file = NULL, ...) {
      local_var_response <- self$get_api_info_with_http_info(data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve an object with basic API information
    #'
    #' @description
    #' Retrieve an object with basic API information
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectApiInfoValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_api_info_with_http_info = function(data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      local_var_url_path <- "/"
      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectApiInfoValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the annotations analysis of a dataset
    #'
    #' @description
    #' Retrieve the annotations analysis of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectSetAnnotationValueObject
    #' @keywords internal
    get_dataset_annotations = function(dataset, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_annotations_with_http_info(dataset, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the annotations analysis of a dataset
    #'
    #' @description
    #' Retrieve the annotations analysis of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectSetAnnotationValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_annotations_with_http_info = function(dataset, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      local_var_url_path <- "/datasets/{dataset}/annotations"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectSetAnnotationValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the design of a dataset
    #'
    #' @description
    #' Retrieve the design of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return data.frame
    #' @keywords internal
    get_dataset_design = function(dataset, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_design_with_http_info(dataset, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the design of a dataset
    #'
    #' @description
    #' Retrieve the design of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_design_with_http_info = function(dataset, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      local_var_url_path <- "/datasets/{dataset}/design"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("text/tab-separated-values; charset=UTF-8", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "data.frame", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the expression levels of a set of datasets subject to a threshold on their differential expressions
    #'
    #' @description
    #' Retrieve the expression levels of a set of datasets subject to a threshold on their differential expressions
    #'
    #' @param datasets 
    #' @param diff_ex_set (optional) No description
    #' @param threshold (optional) No description (default value: 1.0)
    #' @param limit (optional) No description (default value: 100)
    #' @param keep_non_specific (optional) No description (default value: FALSE)
    #' @param consolidate (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListExperimentExpressionLevelsValueObject
    #' @keywords internal
    get_dataset_differential_expression = function(datasets, diff_ex_set = NULL, threshold = 1.0, limit = 100, keep_non_specific = FALSE, consolidate = NULL, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_differential_expression_with_http_info(datasets, diff_ex_set, threshold, limit, keep_non_specific, consolidate, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the expression levels of a set of datasets subject to a threshold on their differential expressions
    #'
    #' @description
    #' Retrieve the expression levels of a set of datasets subject to a threshold on their differential expressions
    #'
    #' @param datasets 
    #' @param diff_ex_set (optional) No description
    #' @param threshold (optional) No description (default value: 1.0)
    #' @param limit (optional) No description (default value: 100)
    #' @param keep_non_specific (optional) No description (default value: FALSE)
    #' @param consolidate (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListExperimentExpressionLevelsValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_differential_expression_with_http_info = function(datasets, diff_ex_set = NULL, threshold = 1.0, limit = 100, keep_non_specific = FALSE, consolidate = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`datasets`)) {
        stop("Missing required parameter `datasets`.")
      }




      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_dataset_differential_expression, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_dataset_differential_expression, must be bigger than or equal to 1.")
      }



      query_params["diffExSet"] <- `diff_ex_set`

      query_params["threshold"] <- `threshold`

      query_params["limit"] <- `limit`

      query_params["keepNonSpecific"] <- `keep_non_specific`

      query_params["consolidate"] <- `consolidate`

      local_var_url_path <- "/datasets/{datasets}/expressions/differential"
      if (!missing(`datasets`)) {
        local_var_url_path <- gsub(paste0("\\{", "datasets", "\\}"), URLencode(as.character(`datasets`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListExperimentExpressionLevelsValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the differential analyses of a dataset
    #'
    #' @description
    #' Retrieve the differential analyses of a dataset
    #'
    #' @param dataset 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #' @keywords internal
    get_dataset_differential_expression_analyses = function(dataset, offset = 0, limit = 20, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_differential_expression_analyses_with_http_info(dataset, offset, limit, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the differential analyses of a dataset
    #'
    #' @description
    #' Retrieve the differential analyses of a dataset
    #'
    #' @param dataset 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListDifferentialExpressionAnalysisValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_differential_expression_analyses_with_http_info = function(dataset, offset = 0, limit = 20, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_dataset_differential_expression_analyses, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_dataset_differential_expression_analyses, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_dataset_differential_expression_analyses, must be bigger than or equal to 1.")
      }

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      local_var_url_path <- "/datasets/{dataset}/analyses/differential"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListDifferentialExpressionAnalysisValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the result sets of all differential analyses of a dataset
    #'
    #' @description
    #' Retrieve the result sets of all differential analyses of a dataset
    #'
    #' @param dataset 
    #' @param ... Other optional arguments
    #' @return void
    #' @keywords internal
    get_dataset_differential_expression_analyses_result_sets = function(dataset, ...) {
      local_var_response <- self$get_dataset_differential_expression_analyses_result_sets_with_http_info(dataset, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the result sets of all differential analyses of a dataset
    #'
    #' @description
    #' Retrieve the result sets of all differential analyses of a dataset
    #'
    #' @param dataset 
    #' @param ... Other optional arguments
    #' @return API response (void) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_differential_expression_analyses_result_sets_with_http_info = function(dataset, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      local_var_url_path <- "/datasets/{dataset}/analyses/differential/resultSets"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        local_var_resp$content <- NULL
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the expression data of a dataset
    #'
    #' @description
    #' Retrieve the expression data of a dataset
    #'
    #' @param dataset 
    #' @param filter (optional) No description (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return data.frame
    #' @keywords internal
    get_dataset_expression = function(dataset, filter = FALSE, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_expression_with_http_info(dataset, filter, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the expression data of a dataset
    #'
    #' @description
    #' Retrieve the expression data of a dataset
    #'
    #' @param dataset 
    #' @param filter (optional) No description (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_expression_with_http_info = function(dataset, filter = FALSE, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }



      query_params["filter"] <- `filter`

      local_var_url_path <- "/datasets/{dataset}/data"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("text/tab-separated-values; charset=UTF-8", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "data.frame", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the expression data matrix of a set of datasets and genes
    #'
    #' @description
    #' Retrieve the expression data matrix of a set of datasets and genes
    #'
    #' @param datasets 
    #' @param genes 
    #' @param keep_non_specific (optional) No description (default value: FALSE)
    #' @param consolidate (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListExperimentExpressionLevelsValueObject
    #' @keywords internal
    get_dataset_expression_for_genes = function(datasets, genes, keep_non_specific = FALSE, consolidate = NULL, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_expression_for_genes_with_http_info(datasets, genes, keep_non_specific, consolidate, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the expression data matrix of a set of datasets and genes
    #'
    #' @description
    #' Retrieve the expression data matrix of a set of datasets and genes
    #'
    #' @param datasets 
    #' @param genes 
    #' @param keep_non_specific (optional) No description (default value: FALSE)
    #' @param consolidate (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListExperimentExpressionLevelsValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_expression_for_genes_with_http_info = function(datasets, genes, keep_non_specific = FALSE, consolidate = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`datasets`)) {
        stop("Missing required parameter `datasets`.")
      }

      if (missing(`genes`)) {
        stop("Missing required parameter `genes`.")
      }





      query_params["keepNonSpecific"] <- `keep_non_specific`

      query_params["consolidate"] <- `consolidate`

      local_var_url_path <- "/datasets/{datasets}/expressions/genes/{genes}"
      if (!missing(`datasets`)) {
        local_var_url_path <- gsub(paste0("\\{", "datasets", "\\}"), URLencode(as.character(`datasets`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`genes`)) {
        local_var_url_path <- gsub(paste0("\\{", "genes", "\\}"), URLencode(as.character(`genes`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListExperimentExpressionLevelsValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the principal components (PCA) of a set of datasets
    #'
    #' @description
    #' Retrieve the principal components (PCA) of a set of datasets
    #'
    #' @param datasets 
    #' @param component (optional) No description (default value: 1)
    #' @param limit (optional) No description (default value: 100)
    #' @param keep_non_specific (optional) No description (default value: FALSE)
    #' @param consolidate (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListExperimentExpressionLevelsValueObject
    #' @keywords internal
    get_dataset_expression_pca = function(datasets, component = 1, limit = 100, keep_non_specific = FALSE, consolidate = NULL, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_expression_pca_with_http_info(datasets, component, limit, keep_non_specific, consolidate, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the principal components (PCA) of a set of datasets
    #'
    #' @description
    #' Retrieve the principal components (PCA) of a set of datasets
    #'
    #' @param datasets 
    #' @param component (optional) No description (default value: 1)
    #' @param limit (optional) No description (default value: 100)
    #' @param keep_non_specific (optional) No description (default value: FALSE)
    #' @param consolidate (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListExperimentExpressionLevelsValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_expression_pca_with_http_info = function(datasets, component = 1, limit = 100, keep_non_specific = FALSE, consolidate = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`datasets`)) {
        stop("Missing required parameter `datasets`.")
      }



      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_dataset_expression_pca, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_dataset_expression_pca, must be bigger than or equal to 1.")
      }



      query_params["component"] <- `component`

      query_params["limit"] <- `limit`

      query_params["keepNonSpecific"] <- `keep_non_specific`

      query_params["consolidate"] <- `consolidate`

      local_var_url_path <- "/datasets/{datasets}/expressions/pca"
      if (!missing(`datasets`)) {
        local_var_url_path <- gsub(paste0("\\{", "datasets", "\\}"), URLencode(as.character(`datasets`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListExperimentExpressionLevelsValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the platform of a dataset
    #'
    #' @description
    #' Retrieve the platform of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListArrayDesignValueObject
    #' @keywords internal
    get_dataset_platforms = function(dataset, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_platforms_with_http_info(dataset, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the platform of a dataset
    #'
    #' @description
    #' Retrieve the platform of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListArrayDesignValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_platforms_with_http_info = function(dataset, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      local_var_url_path <- "/datasets/{dataset}/platforms"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListArrayDesignValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve raw expression data of a dataset
    #'
    #' @description
    #' Retrieve raw expression data of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return data.frame
    #' @keywords internal
    get_dataset_raw_expression = function(dataset, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_raw_expression_with_http_info(dataset, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve raw expression data of a dataset
    #'
    #' @description
    #' Retrieve raw expression data of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_raw_expression_with_http_info = function(dataset, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      local_var_url_path <- "/datasets/{dataset}/data/raw"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("text/tab-separated-values; charset=UTF-8", "application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "data.frame", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the samples of a dataset
    #'
    #' @description
    #' Retrieve the samples of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListBioAssayValueObject
    #' @keywords internal
    get_dataset_samples = function(dataset, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_samples_with_http_info(dataset, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the samples of a dataset
    #'
    #' @description
    #' Retrieve the samples of a dataset
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListBioAssayValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_samples_with_http_info = function(dataset, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      local_var_url_path <- "/datasets/{dataset}/samples"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListBioAssayValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the singular value decomposition (SVD) of a dataset expression data
    #'
    #' @description
    #' Retrieve the singular value decomposition (SVD) of a dataset expression data
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectSimpleSVDValueObject
    #' @keywords internal
    get_dataset_svd = function(dataset, data_file = NULL, ...) {
      local_var_response <- self$get_dataset_svd_with_http_info(dataset, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the singular value decomposition (SVD) of a dataset expression data
    #'
    #' @description
    #' Retrieve the singular value decomposition (SVD) of a dataset expression data
    #'
    #' @param dataset 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectSimpleSVDValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_dataset_svd_with_http_info = function(dataset, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }


      local_var_url_path <- "/datasets/{dataset}/svd"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectSimpleSVDValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve all datasets
    #'
    #' @description
    #' Retrieve all datasets
    #'
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    get_datasets = function(filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$get_datasets_with_http_info(filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve all datasets
    #'
    #' @description
    #' Retrieve all datasets
    #'
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectExpressionExperimentValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_datasets_with_http_info = function(filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE


      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_datasets, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_datasets, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_datasets, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$get_datasets, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/datasets"
      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectExpressionExperimentValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve datasets by their identifiers
    #'
    #' @description
    #' Retrieve datasets by their identifiers
    #'
    #' @param dataset 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    get_datasets_by_ids = function(dataset, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$get_datasets_by_ids_with_http_info(dataset, filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve datasets by their identifiers
    #'
    #' @description
    #' Retrieve datasets by their identifiers
    #'
    #' @param dataset 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectExpressionExperimentValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_datasets_by_ids_with_http_info = function(dataset, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }



      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_datasets_by_ids, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_datasets_by_ids, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_datasets_by_ids, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$get_datasets_by_ids, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/datasets/{dataset}"
      if (!missing(`dataset`)) {
        local_var_url_path <- gsub(paste0("\\{", "dataset", "\\}"), URLencode(as.character(`dataset`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectExpressionExperimentValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the coexpression of two given genes
    #'
    #' @description
    #' Retrieve the coexpression of two given genes
    #'
    #' @param gene 
    #' @param with (optional) No description
    #' @param limit (optional) No description (default value: 100)
    #' @param stringency (optional) No description (default value: 1)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListCoexpressionValueObjectExt
    #' @keywords internal
    get_gene_gene_coexpression = function(gene, with = NULL, limit = 100, stringency = 1, data_file = NULL, ...) {
      local_var_response <- self$get_gene_gene_coexpression_with_http_info(gene, with, limit, stringency, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the coexpression of two given genes
    #'
    #' @description
    #' Retrieve the coexpression of two given genes
    #'
    #' @param gene 
    #' @param with (optional) No description
    #' @param limit (optional) No description (default value: 100)
    #' @param stringency (optional) No description (default value: 1)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListCoexpressionValueObjectExt) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_gene_gene_coexpression_with_http_info = function(gene, with = NULL, limit = 100, stringency = 1, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`gene`)) {
        stop("Missing required parameter `gene`.")
      }



      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_gene_gene_coexpression, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_gene_gene_coexpression, must be bigger than or equal to 1.")
      }


      query_params["with"] <- `with`

      query_params["limit"] <- `limit`

      query_params["stringency"] <- `stringency`

      local_var_url_path <- "/genes/{gene}/coexpression"
      if (!missing(`gene`)) {
        local_var_url_path <- gsub(paste0("\\{", "gene", "\\}"), URLencode(as.character(`gene`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListCoexpressionValueObjectExt", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the GO terms associated to a gene
    #'
    #' @description
    #' Retrieve the GO terms associated to a gene
    #'
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListGeneOntologyTermValueObject
    #' @keywords internal
    get_gene_go_terms = function(gene, data_file = NULL, ...) {
      local_var_response <- self$get_gene_go_terms_with_http_info(gene, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the GO terms associated to a gene
    #'
    #' @description
    #' Retrieve the GO terms associated to a gene
    #'
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListGeneOntologyTermValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_gene_go_terms_with_http_info = function(gene, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`gene`)) {
        stop("Missing required parameter `gene`.")
      }


      local_var_url_path <- "/genes/{gene}/goTerms"
      if (!missing(`gene`)) {
        local_var_url_path <- gsub(paste0("\\{", "gene", "\\}"), URLencode(as.character(`gene`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListGeneOntologyTermValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the physical locations of a given gene
    #'
    #' @description
    #' Retrieve the physical locations of a given gene
    #'
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListPhysicalLocationValueObject
    #' @keywords internal
    get_gene_locations = function(gene, data_file = NULL, ...) {
      local_var_response <- self$get_gene_locations_with_http_info(gene, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the physical locations of a given gene
    #'
    #' @description
    #' Retrieve the physical locations of a given gene
    #'
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListPhysicalLocationValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_gene_locations_with_http_info = function(gene, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`gene`)) {
        stop("Missing required parameter `gene`.")
      }


      local_var_url_path <- "/genes/{gene}/locations"
      if (!missing(`gene`)) {
        local_var_url_path <- gsub(paste0("\\{", "gene", "\\}"), URLencode(as.character(`gene`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListPhysicalLocationValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve physical locations for a given gene and taxon
    #'
    #' @description
    #' Retrieve physical locations for a given gene and taxon
    #'
    #' @param taxon 
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListPhysicalLocationValueObject
    #' @keywords internal
    get_gene_locations_in_taxon = function(taxon, gene, data_file = NULL, ...) {
      local_var_response <- self$get_gene_locations_in_taxon_with_http_info(taxon, gene, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve physical locations for a given gene and taxon
    #'
    #' @description
    #' Retrieve physical locations for a given gene and taxon
    #'
    #' @param taxon 
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListPhysicalLocationValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_gene_locations_in_taxon_with_http_info = function(taxon, gene, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }

      if (missing(`gene`)) {
        stop("Missing required parameter `gene`.")
      }



      local_var_url_path <- "/taxa/{taxon}/genes/{gene}/locations"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub(paste0("\\{", "taxon", "\\}"), URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`gene`)) {
        local_var_url_path <- gsub(paste0("\\{", "gene", "\\}"), URLencode(as.character(`gene`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListPhysicalLocationValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the probes associated to a genes
    #'
    #' @description
    #' Retrieve the probes associated to a genes
    #'
    #' @param gene 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectCompositeSequenceValueObject
    #' @keywords internal
    get_gene_probes = function(gene, offset = 0, limit = 20, data_file = NULL, ...) {
      local_var_response <- self$get_gene_probes_with_http_info(gene, offset, limit, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the probes associated to a genes
    #'
    #' @description
    #' Retrieve the probes associated to a genes
    #'
    #' @param gene 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectCompositeSequenceValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_gene_probes_with_http_info = function(gene, offset = 0, limit = 20, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`gene`)) {
        stop("Missing required parameter `gene`.")
      }


      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_gene_probes, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_gene_probes, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_gene_probes, must be bigger than or equal to 1.")
      }

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      local_var_url_path <- "/genes/{gene}/probes"
      if (!missing(`gene`)) {
        local_var_url_path <- gsub(paste0("\\{", "gene", "\\}"), URLencode(as.character(`gene`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectCompositeSequenceValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve genes matching a gene identifier
    #'
    #' @description
    #' Retrieve genes matching a gene identifier
    #'
    #' @param genes 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListGeneValueObject
    #' @keywords internal
    get_genes = function(genes, data_file = NULL, ...) {
      local_var_response <- self$get_genes_with_http_info(genes, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve genes matching a gene identifier
    #'
    #' @description
    #' Retrieve genes matching a gene identifier
    #'
    #' @param genes 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListGeneValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_genes_with_http_info = function(genes, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`genes`)) {
        stop("Missing required parameter `genes`.")
      }


      local_var_url_path <- "/genes/{genes}"
      if (!missing(`genes`)) {
        local_var_url_path <- gsub(paste0("\\{", "genes", "\\}"), URLencode(as.character(`genes`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListGeneValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the annotations of a given platform
    #'
    #' @description
    #' Retrieve the annotations of a given platform
    #'
    #' @param platform 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return data.frame
    #' @keywords internal
    get_platform_annotations = function(platform, data_file = NULL, ...) {
      local_var_response <- self$get_platform_annotations_with_http_info(platform, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the annotations of a given platform
    #'
    #' @description
    #' Retrieve the annotations of a given platform
    #'
    #' @param platform 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_platform_annotations_with_http_info = function(platform, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`platform`)) {
        stop("Missing required parameter `platform`.")
      }


      local_var_url_path <- "/platforms/{platform}/annotations"
      if (!missing(`platform`)) {
        local_var_url_path <- gsub(paste0("\\{", "platform", "\\}"), URLencode(as.character(`platform`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("text/tab-separated-values; charset=UTF-8")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "data.frame", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve all experiments within a given platform
    #'
    #' @description
    #' Retrieve all experiments within a given platform
    #'
    #' @param platform 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    get_platform_datasets = function(platform, offset = 0, limit = 20, data_file = NULL, ...) {
      local_var_response <- self$get_platform_datasets_with_http_info(platform, offset, limit, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve all experiments within a given platform
    #'
    #' @description
    #' Retrieve all experiments within a given platform
    #'
    #' @param platform 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectExpressionExperimentValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_platform_datasets_with_http_info = function(platform, offset = 0, limit = 20, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`platform`)) {
        stop("Missing required parameter `platform`.")
      }


      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_platform_datasets, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_datasets, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_datasets, must be bigger than or equal to 1.")
      }

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      local_var_url_path <- "/platforms/{platform}/datasets"
      if (!missing(`platform`)) {
        local_var_url_path <- gsub(paste0("\\{", "platform", "\\}"), URLencode(as.character(`platform`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectExpressionExperimentValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the selected composite sequences for a given platform
    #'
    #' @description
    #' Retrieve the selected composite sequences for a given platform
    #'
    #' @param platform 
    #' @param probes 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectCompositeSequenceValueObject
    #' @keywords internal
    get_platform_element = function(platform, probes, offset = 0, limit = 20, data_file = NULL, ...) {
      local_var_response <- self$get_platform_element_with_http_info(platform, probes, offset, limit, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the selected composite sequences for a given platform
    #'
    #' @description
    #' Retrieve the selected composite sequences for a given platform
    #'
    #' @param platform 
    #' @param probes 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectCompositeSequenceValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_platform_element_with_http_info = function(platform, probes, offset = 0, limit = 20, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`platform`)) {
        stop("Missing required parameter `platform`.")
      }

      if (missing(`probes`)) {
        stop("Missing required parameter `probes`.")
      }



      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_platform_element, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_element, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_element, must be bigger than or equal to 1.")
      }

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      local_var_url_path <- "/platforms/{platform}/elements/{probes}"
      if (!missing(`platform`)) {
        local_var_url_path <- gsub(paste0("\\{", "platform", "\\}"), URLencode(as.character(`platform`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`probes`)) {
        local_var_url_path <- gsub(paste0("\\{", "probes", "\\}"), URLencode(as.character(`probes`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectCompositeSequenceValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the genes associated to a probe in a given platform
    #'
    #' @description
    #' Retrieve the genes associated to a probe in a given platform
    #'
    #' @param platform 
    #' @param probe 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectGeneValueObject
    #' @keywords internal
    get_platform_element_genes = function(platform, probe, offset = 0, limit = 20, data_file = NULL, ...) {
      local_var_response <- self$get_platform_element_genes_with_http_info(platform, probe, offset, limit, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the genes associated to a probe in a given platform
    #'
    #' @description
    #' Retrieve the genes associated to a probe in a given platform
    #'
    #' @param platform 
    #' @param probe 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectGeneValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_platform_element_genes_with_http_info = function(platform, probe, offset = 0, limit = 20, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`platform`)) {
        stop("Missing required parameter `platform`.")
      }

      if (missing(`probe`)) {
        stop("Missing required parameter `probe`.")
      }



      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_platform_element_genes, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_element_genes, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_element_genes, must be bigger than or equal to 1.")
      }

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      local_var_url_path <- "/platforms/{platform}/elements/{probe}/genes"
      if (!missing(`platform`)) {
        local_var_url_path <- gsub(paste0("\\{", "platform", "\\}"), URLencode(as.character(`platform`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`probe`)) {
        local_var_url_path <- gsub(paste0("\\{", "probe", "\\}"), URLencode(as.character(`probe`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectGeneValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the composite sequences for a given platform
    #'
    #' @description
    #' Retrieve the composite sequences for a given platform
    #'
    #' @param platform 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectCompositeSequenceValueObject
    #' @keywords internal
    get_platform_elements = function(platform, offset = 0, limit = 20, data_file = NULL, ...) {
      local_var_response <- self$get_platform_elements_with_http_info(platform, offset, limit, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the composite sequences for a given platform
    #'
    #' @description
    #' Retrieve the composite sequences for a given platform
    #'
    #' @param platform 
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectCompositeSequenceValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_platform_elements_with_http_info = function(platform, offset = 0, limit = 20, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`platform`)) {
        stop("Missing required parameter `platform`.")
      }


      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_platform_elements, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_elements, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platform_elements, must be bigger than or equal to 1.")
      }

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      local_var_url_path <- "/platforms/{platform}/elements"
      if (!missing(`platform`)) {
        local_var_url_path <- gsub(paste0("\\{", "platform", "\\}"), URLencode(as.character(`platform`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectCompositeSequenceValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve all platforms
    #'
    #' @description
    #' Retrieve all platforms
    #'
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectArrayDesignValueObject
    #' @keywords internal
    get_platforms = function(filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$get_platforms_with_http_info(filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve all platforms
    #'
    #' @description
    #' Retrieve all platforms
    #'
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectArrayDesignValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_platforms_with_http_info = function(filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE


      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_platforms, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platforms, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platforms, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$get_platforms, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/platforms"
      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectArrayDesignValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve all platforms matching a set of platform identifiers
    #'
    #' @description
    #' Retrieve all platforms matching a set of platform identifiers
    #'
    #' @param platform 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectArrayDesignValueObject
    #' @keywords internal
    get_platforms_by_ids = function(platform, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$get_platforms_by_ids_with_http_info(platform, filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve all platforms matching a set of platform identifiers
    #'
    #' @description
    #' Retrieve all platforms matching a set of platform identifiers
    #'
    #' @param platform 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectArrayDesignValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_platforms_by_ids_with_http_info = function(platform, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`platform`)) {
        stop("Missing required parameter `platform`.")
      }



      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_platforms_by_ids, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platforms_by_ids, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_platforms_by_ids, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$get_platforms_by_ids, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/platforms/{platform}"
      if (!missing(`platform`)) {
        local_var_url_path <- gsub(paste0("\\{", "platform", "\\}"), URLencode(as.character(`platform`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectArrayDesignValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve a single analysis result set by its identifier
    #'
    #' @description
    #' Retrieve a single analysis result set by its identifier
    #'
    #' @param result_set 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    get_result_set = function(result_set, data_file = NULL, ...) {
      local_var_response <- self$get_result_set_with_http_info(result_set, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve a single analysis result set by its identifier
    #'
    #' @description
    #' Retrieve a single analysis result set by its identifier
    #'
    #' @param result_set 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectExpressionAnalysisResultSetValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_result_set_with_http_info = function(result_set, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`result_set`)) {
        stop("Missing required parameter `result_set`.")
      }


      local_var_url_path <- "/resultSets/{resultSet}"
      if (!missing(`result_set`)) {
        local_var_url_path <- gsub(paste0("\\{", "resultSet", "\\}"), URLencode(as.character(`result_set`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectExpressionAnalysisResultSetValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve a single analysis result set by its identifier as a tab-separated values
    #'
    #' @description
    #' Retrieve a single analysis result set by its identifier as a tab-separated values
    #'
    #' @param result_set_ 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return data.frame
    #' @keywords internal
    get_result_set_as_tsv = function(result_set_, data_file = NULL, ...) {
      local_var_response <- self$get_result_set_as_tsv_with_http_info(result_set_, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve a single analysis result set by its identifier as a tab-separated values
    #'
    #' @description
    #' Retrieve a single analysis result set by its identifier as a tab-separated values
    #'
    #' @param result_set_ 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_result_set_as_tsv_with_http_info = function(result_set_, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`result_set_`)) {
        stop("Missing required parameter `result_set_`.")
      }


      local_var_url_path <- "/resultSets/{resultSet_}"
      if (!missing(`result_set_`)) {
        local_var_url_path <- gsub(paste0("\\{", "resultSet_", "\\}"), URLencode(as.character(`result_set_`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("text/tab-separated-values; charset=UTF-8")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "data.frame", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve all result sets matching the provided criteria
    #'
    #' @description
    #' Retrieve all result sets matching the provided criteria
    #'
    #' @param datasets (optional) No description
    #' @param database_entries (optional) No description
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    get_result_sets = function(datasets = NULL, database_entries = NULL, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$get_result_sets_with_http_info(datasets, database_entries, filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve all result sets matching the provided criteria
    #'
    #' @description
    #' Retrieve all result sets matching the provided criteria
    #'
    #' @param datasets (optional) No description
    #' @param database_entries (optional) No description
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_result_sets_with_http_info = function(datasets = NULL, database_entries = NULL, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE




      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_result_sets, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_result_sets, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_result_sets, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$get_result_sets, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["datasets"] <- `datasets`

      query_params["databaseEntries"] <- `database_entries`

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/resultSets"
      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve all available taxa
    #'
    #' @description
    #' Retrieve all available taxa
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListTaxonValueObject
    #' @keywords internal
    get_taxa = function(data_file = NULL, ...) {
      local_var_response <- self$get_taxa_with_http_info(data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve all available taxa
    #'
    #' @description
    #' Retrieve all available taxa
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListTaxonValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_taxa_with_http_info = function(data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      local_var_url_path <- "/taxa"
      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListTaxonValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve taxa by their identifiers
    #'
    #' @description
    #' Retrieve taxa by their identifiers
    #'
    #' @param taxa 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListTaxonValueObject
    #' @keywords internal
    get_taxa_by_ids = function(taxa, data_file = NULL, ...) {
      local_var_response <- self$get_taxa_by_ids_with_http_info(taxa, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve taxa by their identifiers
    #'
    #' @description
    #' Retrieve taxa by their identifiers
    #'
    #' @param taxa 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListTaxonValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_taxa_by_ids_with_http_info = function(taxa, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxa`)) {
        stop("Missing required parameter `taxa`.")
      }


      local_var_url_path <- "/taxa/{taxa}"
      if (!missing(`taxa`)) {
        local_var_url_path <- gsub(paste0("\\{", "taxa", "\\}"), URLencode(as.character(`taxa`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListTaxonValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve the datasets for a given taxon
    #'
    #' @description
    #' Retrieve the datasets for a given taxon
    #'
    #' @param taxon 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    get_taxon_datasets = function(taxon, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$get_taxon_datasets_with_http_info(taxon, filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve the datasets for a given taxon
    #'
    #' @description
    #' Retrieve the datasets for a given taxon
    #'
    #' @param taxon 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectExpressionExperimentValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_taxon_datasets_with_http_info = function(taxon, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }



      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$get_taxon_datasets, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$get_taxon_datasets, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$get_taxon_datasets, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$get_taxon_datasets, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/taxa/{taxon}/datasets"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub(paste0("\\{", "taxon", "\\}"), URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectExpressionExperimentValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve all genes in a given taxon
    #'
    #' @description
    #' Retrieve all genes in a given taxon
    #'
    #' @param taxon 
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListGeneValueObject
    #' @keywords internal
    get_taxon_genes = function(taxon, gene, data_file = NULL, ...) {
      local_var_response <- self$get_taxon_genes_with_http_info(taxon, gene, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve all genes in a given taxon
    #'
    #' @description
    #' Retrieve all genes in a given taxon
    #'
    #' @param taxon 
    #' @param gene 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListGeneValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_taxon_genes_with_http_info = function(taxon, gene, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }

      if (missing(`gene`)) {
        stop("Missing required parameter `gene`.")
      }



      local_var_url_path <- "/taxa/{taxon}/genes/{gene}"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub(paste0("\\{", "taxon", "\\}"), URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`gene`)) {
        local_var_url_path <- gsub(paste0("\\{", "gene", "\\}"), URLencode(as.character(`gene`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListGeneValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve genes overlapping a given region in a taxon
    #'
    #' @description
    #' Retrieve genes overlapping a given region in a taxon
    #'
    #' @param taxon 
    #' @param chromosome 
    #' @param strand (optional) No description (default value: "+")
    #' @param start (optional) No description
    #' @param size (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListGeneValueObject
    #' @keywords internal
    get_taxon_genes_overlapping_chromosome = function(taxon, chromosome, strand = "+", start = NULL, size = NULL, data_file = NULL, ...) {
      local_var_response <- self$get_taxon_genes_overlapping_chromosome_with_http_info(taxon, chromosome, strand, start, size, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve genes overlapping a given region in a taxon
    #'
    #' @description
    #' Retrieve genes overlapping a given region in a taxon
    #'
    #' @param taxon 
    #' @param chromosome 
    #' @param strand (optional) No description (default value: "+")
    #' @param start (optional) No description
    #' @param size (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListGeneValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    get_taxon_genes_overlapping_chromosome_with_http_info = function(taxon, chromosome, strand = "+", start = NULL, size = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }

      if (missing(`chromosome`)) {
        stop("Missing required parameter `chromosome`.")
      }






      query_params["strand"] <- `strand`

      query_params["start"] <- `start`

      query_params["size"] <- `size`

      local_var_url_path <- "/taxa/{taxon}/chromosomes/{chromosome}/genes"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub(paste0("\\{", "taxon", "\\}"), URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`chromosome`)) {
        local_var_url_path <- gsub(paste0("\\{", "chromosome", "\\}"), URLencode(as.character(`chromosome`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListGeneValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Search everything in Gemma.
    #'
    #' @description
    #' Search everything in Gemma.
    #'
    #' @param query (optional) No description
    #' @param taxon (optional) No description
    #' @param platform (optional) No description
    #' @param result_types (optional) No description
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return SearchResultsResponseDataObject
    #' @keywords internal
    search = function(query = NULL, taxon = NULL, platform = NULL, result_types = NULL, limit = 20, data_file = NULL, ...) {
      local_var_response <- self$search_with_http_info(query, taxon, platform, result_types, limit, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Search everything in Gemma.
    #'
    #' @description
    #' Search everything in Gemma.
    #'
    #' @param query (optional) No description
    #' @param taxon (optional) No description
    #' @param platform (optional) No description
    #' @param result_types (optional) No description
    #' @param limit (optional) No description (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (SearchResultsResponseDataObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    search_with_http_info = function(query = NULL, taxon = NULL, platform = NULL, result_types = NULL, limit = 20, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE





      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$search, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$search, must be bigger than or equal to 1.")
      }

      query_params["query"] <- `query`

      query_params["taxon"] <- `taxon`

      query_params["platform"] <- `platform`

      query_params["resultTypes"] <- `result_types`

      query_params["limit"] <- `limit`

      local_var_url_path <- "/search"
      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "SearchResultsResponseDataObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Search for annotation tags
    #'
    #' @description
    #' Search for annotation tags
    #'
    #' @param query 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ResponseDataObjectListAnnotationSearchResultValueObject
    #' @keywords internal
    search_annotations = function(query, data_file = NULL, ...) {
      local_var_response <- self$search_annotations_with_http_info(query, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Search for annotation tags
    #'
    #' @description
    #' Search for annotation tags
    #'
    #' @param query 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ResponseDataObjectListAnnotationSearchResultValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    search_annotations_with_http_info = function(query, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`query`)) {
        stop("Missing required parameter `query`.")
      }


      local_var_url_path <- "/annotations/search/{query}"
      if (!missing(`query`)) {
        local_var_url_path <- gsub(paste0("\\{", "query", "\\}"), URLencode(as.character(`query`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ResponseDataObjectListAnnotationSearchResultValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve datasets associated to an annotation tags search
    #'
    #' @description
    #' Retrieve datasets associated to an annotation tags search
    #'
    #' @param query 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    search_datasets = function(query, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$search_datasets_with_http_info(query, filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve datasets associated to an annotation tags search
    #'
    #' @description
    #' Retrieve datasets associated to an annotation tags search
    #'
    #' @param query 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectExpressionExperimentValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    search_datasets_with_http_info = function(query, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`query`)) {
        stop("Missing required parameter `query`.")
      }



      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$search_datasets, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$search_datasets, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$search_datasets, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$search_datasets, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/annotations/search/{query}/datasets"
      if (!missing(`query`)) {
        local_var_url_path <- gsub(paste0("\\{", "query", "\\}"), URLencode(as.character(`query`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectExpressionExperimentValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Retrieve datasets within a given taxa associated to an annotation tags search
    #'
    #' @description
    #' Retrieve datasets within a given taxa associated to an annotation tags search
    #'
    #' @param taxon 
    #' @param query 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    search_taxon_datasets = function(taxon, query, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      local_var_response <- self$search_taxon_datasets_with_http_info(taxon, query, filter, offset, limit, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Retrieve datasets within a given taxa associated to an annotation tags search
    #'
    #' @description
    #' Retrieve datasets within a given taxa associated to an annotation tags search
    #'
    #' @param taxon 
    #' @param query 
    #' @param filter (optional) No description (default value: "")
    #' @param offset (optional) No description (default value: 0)
    #' @param limit (optional) No description (default value: 20)
    #' @param sort (optional) No description (default value: "+id")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (PaginatedResponseDataObjectExpressionExperimentValueObject) with additional information such as HTTP status code, headers
    #' @keywords internal
    search_taxon_datasets_with_http_info = function(taxon, query, filter = "", offset = 0, limit = 20, sort = "+id", data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`taxon`)) {
        stop("Missing required parameter `taxon`.")
      }

      if (missing(`query`)) {
        stop("Missing required parameter `query`.")
      }




      if (`offset` < 0) {
        stop("Invalid value for `offset` when calling DefaultApi$search_taxon_datasets, must be bigger than or equal to 0.")
      }

      if (`limit` > 100) {
        stop("Invalid value for `limit` when calling DefaultApi$search_taxon_datasets, must be smaller than or equal to 100.")
      }
      if (`limit` < 1) {
        stop("Invalid value for `limit` when calling DefaultApi$search_taxon_datasets, must be bigger than or equal to 1.")
      }

      if (!str_detect(`sort`, "^(\\+|-?)(\\w+)$")) {
        stop("Invalid value for `sort` when calling DefaultApi$search_taxon_datasets, must conform to the pattern ^(\\+|-?)(\\w+)$.")
      }

      query_params["filter"] <- `filter`

      query_params["offset"] <- `offset`

      query_params["limit"] <- `limit`

      query_params["sort"] <- `sort`

      local_var_url_path <- "/annotations/{taxon}/search/{query}/datasets"
      if (!missing(`taxon`)) {
        local_var_url_path <- gsub(paste0("\\{", "taxon", "\\}"), URLencode(as.character(`taxon`), reserved = TRUE), local_var_url_path)
      }

      if (!missing(`query`)) {
        local_var_url_path <- gsub(paste0("\\{", "query", "\\}"), URLencode(as.character(`query`), reserved = TRUE), local_var_url_path)
      }

      # HTTP basic auth
      if (!is.null(self$api_client$username) || !is.null(self$api_client$password)) {
        header_params["Authorization"] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$api_client$username, self$api_client$password, sep = ":"))))
      }
      # API key authentication

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
            write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "PaginatedResponseDataObjectExpressionExperimentValueObject", loadNamespace("gemma.R")),
          error = function(e) {
             stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)

#' Create a new DiffExResultSetSummaryValueObject
#'
#' @description
#' DiffExResultSetSummaryValueObject Class
#'
#' @docType class
#' @title DiffExResultSetSummaryValueObject
#' @description DiffExResultSetSummaryValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field analysisId  integer optional
#' @field arrayDesignsUsed  list(integer) optional
#' @field baselineGroup  \link{FactorValueValueObject} optional
#' @field downregulatedCount  integer optional
#' @field experimentalFactors  list(\link{ExperimentalFactorValueObject}) optional
#' @field factorIds  list(integer) optional
#' @field numberOfDiffExpressedProbes  integer optional
#' @field numberOfGenesAnalyzed  integer optional
#' @field numberOfProbesAnalyzed  integer optional
#' @field threshold  numeric optional
#' @field upregulatedCount  integer optional
#' @field bioAssaySetAnalyzedId  integer optional
#' @field resultSetId  integer optional
#' @field qvalue  numeric optional
#' @field experimentalFactorsByValueObject  list(\link{ExperimentalFactorValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DiffExResultSetSummaryValueObject <- R6::R6Class(
  "DiffExResultSetSummaryValueObject",
  public = list(
    `id` = NULL,
    `analysisId` = NULL,
    `arrayDesignsUsed` = NULL,
    `baselineGroup` = NULL,
    `downregulatedCount` = NULL,
    `experimentalFactors` = NULL,
    `factorIds` = NULL,
    `numberOfDiffExpressedProbes` = NULL,
    `numberOfGenesAnalyzed` = NULL,
    `numberOfProbesAnalyzed` = NULL,
    `threshold` = NULL,
    `upregulatedCount` = NULL,
    `bioAssaySetAnalyzedId` = NULL,
    `resultSetId` = NULL,
    `qvalue` = NULL,
    `experimentalFactorsByValueObject` = NULL,
    #' Initialize a new DiffExResultSetSummaryValueObject class.
    #'
    #' @description
    #' Initialize a new DiffExResultSetSummaryValueObject class.
    #'
    #' @param id id
    #' @param analysisId analysisId
    #' @param arrayDesignsUsed arrayDesignsUsed
    #' @param baselineGroup baselineGroup
    #' @param downregulatedCount downregulatedCount
    #' @param experimentalFactors experimentalFactors
    #' @param factorIds factorIds
    #' @param numberOfDiffExpressedProbes numberOfDiffExpressedProbes
    #' @param numberOfGenesAnalyzed numberOfGenesAnalyzed
    #' @param numberOfProbesAnalyzed numberOfProbesAnalyzed
    #' @param threshold threshold
    #' @param upregulatedCount upregulatedCount
    #' @param bioAssaySetAnalyzedId bioAssaySetAnalyzedId
    #' @param resultSetId resultSetId
    #' @param qvalue qvalue
    #' @param experimentalFactorsByValueObject experimentalFactorsByValueObject
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `analysisId` = NULL, `arrayDesignsUsed` = NULL, `baselineGroup` = NULL, `downregulatedCount` = NULL, `experimentalFactors` = NULL, `factorIds` = NULL, `numberOfDiffExpressedProbes` = NULL, `numberOfGenesAnalyzed` = NULL, `numberOfProbesAnalyzed` = NULL, `threshold` = NULL, `upregulatedCount` = NULL, `bioAssaySetAnalyzedId` = NULL, `resultSetId` = NULL, `qvalue` = NULL, `experimentalFactorsByValueObject` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`analysisId`)) {
        stopifnot(is.numeric(`analysisId`), length(`analysisId`) == 1)
        self$`analysisId` <- `analysisId`
      }
      if (!is.null(`arrayDesignsUsed`)) {
        stopifnot(is.vector(`arrayDesignsUsed`), length(`arrayDesignsUsed`) != 0)
        sapply(`arrayDesignsUsed`, function(x) stopifnot(is.character(x)))
        self$`arrayDesignsUsed` <- `arrayDesignsUsed`
      }
      if (!is.null(`baselineGroup`)) {
        stopifnot(R6::is.R6(`baselineGroup`))
        self$`baselineGroup` <- `baselineGroup`
      }
      if (!is.null(`downregulatedCount`)) {
        stopifnot(is.numeric(`downregulatedCount`), length(`downregulatedCount`) == 1)
        self$`downregulatedCount` <- `downregulatedCount`
      }
      if (!is.null(`experimentalFactors`)) {
        stopifnot(is.vector(`experimentalFactors`), length(`experimentalFactors`) != 0)
        sapply(`experimentalFactors`, function(x) stopifnot(R6::is.R6(x)))
        self$`experimentalFactors` <- `experimentalFactors`
      }
      if (!is.null(`factorIds`)) {
        stopifnot(is.vector(`factorIds`), length(`factorIds`) != 0)
        sapply(`factorIds`, function(x) stopifnot(is.character(x)))
        self$`factorIds` <- `factorIds`
      }
      if (!is.null(`numberOfDiffExpressedProbes`)) {
        stopifnot(is.numeric(`numberOfDiffExpressedProbes`), length(`numberOfDiffExpressedProbes`) == 1)
        self$`numberOfDiffExpressedProbes` <- `numberOfDiffExpressedProbes`
      }
      if (!is.null(`numberOfGenesAnalyzed`)) {
        stopifnot(is.numeric(`numberOfGenesAnalyzed`), length(`numberOfGenesAnalyzed`) == 1)
        self$`numberOfGenesAnalyzed` <- `numberOfGenesAnalyzed`
      }
      if (!is.null(`numberOfProbesAnalyzed`)) {
        stopifnot(is.numeric(`numberOfProbesAnalyzed`), length(`numberOfProbesAnalyzed`) == 1)
        self$`numberOfProbesAnalyzed` <- `numberOfProbesAnalyzed`
      }
      if (!is.null(`threshold`)) {
        stopifnot(is.numeric(`threshold`), length(`threshold`) == 1)
        self$`threshold` <- `threshold`
      }
      if (!is.null(`upregulatedCount`)) {
        stopifnot(is.numeric(`upregulatedCount`), length(`upregulatedCount`) == 1)
        self$`upregulatedCount` <- `upregulatedCount`
      }
      if (!is.null(`bioAssaySetAnalyzedId`)) {
        stopifnot(is.numeric(`bioAssaySetAnalyzedId`), length(`bioAssaySetAnalyzedId`) == 1)
        self$`bioAssaySetAnalyzedId` <- `bioAssaySetAnalyzedId`
      }
      if (!is.null(`resultSetId`)) {
        stopifnot(is.numeric(`resultSetId`), length(`resultSetId`) == 1)
        self$`resultSetId` <- `resultSetId`
      }
      if (!is.null(`qvalue`)) {
        stopifnot(is.numeric(`qvalue`), length(`qvalue`) == 1)
        self$`qvalue` <- `qvalue`
      }
      if (!is.null(`experimentalFactorsByValueObject`)) {
        stopifnot(is.vector(`experimentalFactorsByValueObject`), length(`experimentalFactorsByValueObject`) != 0)
        sapply(`experimentalFactorsByValueObject`, function(x) stopifnot(R6::is.R6(x)))
        self$`experimentalFactorsByValueObject` <- `experimentalFactorsByValueObject`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DiffExResultSetSummaryValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      DiffExResultSetSummaryValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        DiffExResultSetSummaryValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`analysisId`)) {
        DiffExResultSetSummaryValueObjectObject[["analysisId"]] <-
          self$`analysisId`
      }
      if (!is.null(self$`arrayDesignsUsed`)) {
        DiffExResultSetSummaryValueObjectObject[["arrayDesignsUsed"]] <-
          self$`arrayDesignsUsed`
      }
      if (!is.null(self$`baselineGroup`)) {
        DiffExResultSetSummaryValueObjectObject[["baselineGroup"]] <-
          self$`baselineGroup`$toJSON()
      }
      if (!is.null(self$`downregulatedCount`)) {
        DiffExResultSetSummaryValueObjectObject[["downregulatedCount"]] <-
          self$`downregulatedCount`
      }
      if (!is.null(self$`experimentalFactors`)) {
        DiffExResultSetSummaryValueObjectObject[["experimentalFactors"]] <-
          lapply(self$`experimentalFactors`, function(x) x$toJSON())
      }
      if (!is.null(self$`factorIds`)) {
        DiffExResultSetSummaryValueObjectObject[["factorIds"]] <-
          self$`factorIds`
      }
      if (!is.null(self$`numberOfDiffExpressedProbes`)) {
        DiffExResultSetSummaryValueObjectObject[["numberOfDiffExpressedProbes"]] <-
          self$`numberOfDiffExpressedProbes`
      }
      if (!is.null(self$`numberOfGenesAnalyzed`)) {
        DiffExResultSetSummaryValueObjectObject[["numberOfGenesAnalyzed"]] <-
          self$`numberOfGenesAnalyzed`
      }
      if (!is.null(self$`numberOfProbesAnalyzed`)) {
        DiffExResultSetSummaryValueObjectObject[["numberOfProbesAnalyzed"]] <-
          self$`numberOfProbesAnalyzed`
      }
      if (!is.null(self$`threshold`)) {
        DiffExResultSetSummaryValueObjectObject[["threshold"]] <-
          self$`threshold`
      }
      if (!is.null(self$`upregulatedCount`)) {
        DiffExResultSetSummaryValueObjectObject[["upregulatedCount"]] <-
          self$`upregulatedCount`
      }
      if (!is.null(self$`bioAssaySetAnalyzedId`)) {
        DiffExResultSetSummaryValueObjectObject[["bioAssaySetAnalyzedId"]] <-
          self$`bioAssaySetAnalyzedId`
      }
      if (!is.null(self$`resultSetId`)) {
        DiffExResultSetSummaryValueObjectObject[["resultSetId"]] <-
          self$`resultSetId`
      }
      if (!is.null(self$`qvalue`)) {
        DiffExResultSetSummaryValueObjectObject[["qvalue"]] <-
          self$`qvalue`
      }
      if (!is.null(self$`experimentalFactorsByValueObject`)) {
        DiffExResultSetSummaryValueObjectObject[["experimentalFactorsByValueObject"]] <-
          lapply(self$`experimentalFactorsByValueObject`, function(x) x$toJSON())
      }
      DiffExResultSetSummaryValueObjectObject
    },
    #' Deserialize JSON string into an instance of DiffExResultSetSummaryValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DiffExResultSetSummaryValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DiffExResultSetSummaryValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`analysisId`)) {
        self$`analysisId` <- this_object$`analysisId`
      }
      if (!is.null(this_object$`arrayDesignsUsed`)) {
        self$`arrayDesignsUsed` <- ApiClient$new()$deserializeObj(this_object$`arrayDesignsUsed`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`baselineGroup`)) {
        baselinegroup_object <- FactorValueValueObject$new()
        baselinegroup_object$fromJSON(jsonlite::toJSON(this_object$baselineGroup, auto_unbox = TRUE, digits = NA))
        self$`baselineGroup` <- baselinegroup_object
      }
      if (!is.null(this_object$`downregulatedCount`)) {
        self$`downregulatedCount` <- this_object$`downregulatedCount`
      }
      if (!is.null(this_object$`experimentalFactors`)) {
        self$`experimentalFactors` <- ApiClient$new()$deserializeObj(this_object$`experimentalFactors`, "array[ExperimentalFactorValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`factorIds`)) {
        self$`factorIds` <- ApiClient$new()$deserializeObj(this_object$`factorIds`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`numberOfDiffExpressedProbes`)) {
        self$`numberOfDiffExpressedProbes` <- this_object$`numberOfDiffExpressedProbes`
      }
      if (!is.null(this_object$`numberOfGenesAnalyzed`)) {
        self$`numberOfGenesAnalyzed` <- this_object$`numberOfGenesAnalyzed`
      }
      if (!is.null(this_object$`numberOfProbesAnalyzed`)) {
        self$`numberOfProbesAnalyzed` <- this_object$`numberOfProbesAnalyzed`
      }
      if (!is.null(this_object$`threshold`)) {
        self$`threshold` <- this_object$`threshold`
      }
      if (!is.null(this_object$`upregulatedCount`)) {
        self$`upregulatedCount` <- this_object$`upregulatedCount`
      }
      if (!is.null(this_object$`bioAssaySetAnalyzedId`)) {
        self$`bioAssaySetAnalyzedId` <- this_object$`bioAssaySetAnalyzedId`
      }
      if (!is.null(this_object$`resultSetId`)) {
        self$`resultSetId` <- this_object$`resultSetId`
      }
      if (!is.null(this_object$`qvalue`)) {
        self$`qvalue` <- this_object$`qvalue`
      }
      if (!is.null(this_object$`experimentalFactorsByValueObject`)) {
        self$`experimentalFactorsByValueObject` <- ApiClient$new()$deserializeObj(this_object$`experimentalFactorsByValueObject`, "array[ExperimentalFactorValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DiffExResultSetSummaryValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`analysisId`)) {
          sprintf(
          '"analysisId":
            %d
                    ',
          self$`analysisId`
          )
        },
        if (!is.null(self$`arrayDesignsUsed`)) {
          sprintf(
          '"arrayDesignsUsed":
             [%s]
          ',
          paste(unlist(lapply(self$`arrayDesignsUsed`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`baselineGroup`)) {
          sprintf(
          '"baselineGroup":
          %s
          ',
          jsonlite::toJSON(self$`baselineGroup`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`downregulatedCount`)) {
          sprintf(
          '"downregulatedCount":
            %d
                    ',
          self$`downregulatedCount`
          )
        },
        if (!is.null(self$`experimentalFactors`)) {
          sprintf(
          '"experimentalFactors":
          [%s]
',
          paste(sapply(self$`experimentalFactors`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`factorIds`)) {
          sprintf(
          '"factorIds":
             [%s]
          ',
          paste(unlist(lapply(self$`factorIds`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`numberOfDiffExpressedProbes`)) {
          sprintf(
          '"numberOfDiffExpressedProbes":
            %d
                    ',
          self$`numberOfDiffExpressedProbes`
          )
        },
        if (!is.null(self$`numberOfGenesAnalyzed`)) {
          sprintf(
          '"numberOfGenesAnalyzed":
            %d
                    ',
          self$`numberOfGenesAnalyzed`
          )
        },
        if (!is.null(self$`numberOfProbesAnalyzed`)) {
          sprintf(
          '"numberOfProbesAnalyzed":
            %d
                    ',
          self$`numberOfProbesAnalyzed`
          )
        },
        if (!is.null(self$`threshold`)) {
          sprintf(
          '"threshold":
            %d
                    ',
          self$`threshold`
          )
        },
        if (!is.null(self$`upregulatedCount`)) {
          sprintf(
          '"upregulatedCount":
            %d
                    ',
          self$`upregulatedCount`
          )
        },
        if (!is.null(self$`bioAssaySetAnalyzedId`)) {
          sprintf(
          '"bioAssaySetAnalyzedId":
            %d
                    ',
          self$`bioAssaySetAnalyzedId`
          )
        },
        if (!is.null(self$`resultSetId`)) {
          sprintf(
          '"resultSetId":
            %d
                    ',
          self$`resultSetId`
          )
        },
        if (!is.null(self$`qvalue`)) {
          sprintf(
          '"qvalue":
            %d
                    ',
          self$`qvalue`
          )
        },
        if (!is.null(self$`experimentalFactorsByValueObject`)) {
          sprintf(
          '"experimentalFactorsByValueObject":
          [%s]
',
          paste(sapply(self$`experimentalFactorsByValueObject`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of DiffExResultSetSummaryValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DiffExResultSetSummaryValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DiffExResultSetSummaryValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`analysisId` <- this_object$`analysisId`
      self$`arrayDesignsUsed` <- ApiClient$new()$deserializeObj(this_object$`arrayDesignsUsed`, "array[integer]", loadNamespace("gemma.R"))
      self$`baselineGroup` <- FactorValueValueObject$new()$fromJSON(jsonlite::toJSON(this_object$baselineGroup, auto_unbox = TRUE, digits = NA))
      self$`downregulatedCount` <- this_object$`downregulatedCount`
      self$`experimentalFactors` <- ApiClient$new()$deserializeObj(this_object$`experimentalFactors`, "array[ExperimentalFactorValueObject]", loadNamespace("gemma.R"))
      self$`factorIds` <- ApiClient$new()$deserializeObj(this_object$`factorIds`, "array[integer]", loadNamespace("gemma.R"))
      self$`numberOfDiffExpressedProbes` <- this_object$`numberOfDiffExpressedProbes`
      self$`numberOfGenesAnalyzed` <- this_object$`numberOfGenesAnalyzed`
      self$`numberOfProbesAnalyzed` <- this_object$`numberOfProbesAnalyzed`
      self$`threshold` <- this_object$`threshold`
      self$`upregulatedCount` <- this_object$`upregulatedCount`
      self$`bioAssaySetAnalyzedId` <- this_object$`bioAssaySetAnalyzedId`
      self$`resultSetId` <- this_object$`resultSetId`
      self$`qvalue` <- this_object$`qvalue`
      self$`experimentalFactorsByValueObject` <- ApiClient$new()$deserializeObj(this_object$`experimentalFactorsByValueObject`, "array[ExperimentalFactorValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to DiffExResultSetSummaryValueObject
    #'
    #' @description
    #' Validate JSON input with respect to DiffExResultSetSummaryValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of DiffExResultSetSummaryValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DiffExResultSetSummaryValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DiffExResultSetSummaryValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DiffExResultSetSummaryValueObject$lock()


#' Create a new DifferentialExpressionAnalysisResultValueObject
#'
#' @description
#' DifferentialExpressionAnalysisResultValueObject Class
#'
#' @docType class
#' @title DifferentialExpressionAnalysisResultValueObject
#' @description DifferentialExpressionAnalysisResultValueObject Class
#' @format An \code{R6Class} generator object
#' @field probeId  integer optional
#' @field probeName  character optional
#' @field genes  list(\link{GeneValueObject}) optional
#' @field correctedPvalue  numeric optional
#' @field rank  numeric optional
#' @field contrasts  list(\link{ContrastResultValueObject}) optional
#' @field pvalue  numeric optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DifferentialExpressionAnalysisResultValueObject <- R6::R6Class(
  "DifferentialExpressionAnalysisResultValueObject",
  public = list(
    `probeId` = NULL,
    `probeName` = NULL,
    `genes` = NULL,
    `correctedPvalue` = NULL,
    `rank` = NULL,
    `contrasts` = NULL,
    `pvalue` = NULL,
    #' Initialize a new DifferentialExpressionAnalysisResultValueObject class.
    #'
    #' @description
    #' Initialize a new DifferentialExpressionAnalysisResultValueObject class.
    #'
    #' @param probeId probeId
    #' @param probeName probeName
    #' @param genes genes
    #' @param correctedPvalue correctedPvalue
    #' @param rank rank
    #' @param contrasts contrasts
    #' @param pvalue pvalue
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `probeId` = NULL, `probeName` = NULL, `genes` = NULL, `correctedPvalue` = NULL, `rank` = NULL, `contrasts` = NULL, `pvalue` = NULL, ...
    ) {
      if (!is.null(`probeId`)) {
        stopifnot(is.numeric(`probeId`), length(`probeId`) == 1)
        self$`probeId` <- `probeId`
      }
      if (!is.null(`probeName`)) {
        stopifnot(is.character(`probeName`), length(`probeName`) == 1)
        self$`probeName` <- `probeName`
      }
      if (!is.null(`genes`)) {
        stopifnot(is.vector(`genes`), length(`genes`) != 0)
        sapply(`genes`, function(x) stopifnot(R6::is.R6(x)))
        self$`genes` <- `genes`
      }
      if (!is.null(`correctedPvalue`)) {
        stopifnot(is.numeric(`correctedPvalue`), length(`correctedPvalue`) == 1)
        self$`correctedPvalue` <- `correctedPvalue`
      }
      if (!is.null(`rank`)) {
        stopifnot(is.numeric(`rank`), length(`rank`) == 1)
        self$`rank` <- `rank`
      }
      if (!is.null(`contrasts`)) {
        stopifnot(is.vector(`contrasts`), length(`contrasts`) != 0)
        sapply(`contrasts`, function(x) stopifnot(R6::is.R6(x)))
        self$`contrasts` <- `contrasts`
      }
      if (!is.null(`pvalue`)) {
        stopifnot(is.numeric(`pvalue`), length(`pvalue`) == 1)
        self$`pvalue` <- `pvalue`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DifferentialExpressionAnalysisResultValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      DifferentialExpressionAnalysisResultValueObjectObject <- list()
      if (!is.null(self$`probeId`)) {
        DifferentialExpressionAnalysisResultValueObjectObject[["probeId"]] <-
          self$`probeId`
      }
      if (!is.null(self$`probeName`)) {
        DifferentialExpressionAnalysisResultValueObjectObject[["probeName"]] <-
          self$`probeName`
      }
      if (!is.null(self$`genes`)) {
        DifferentialExpressionAnalysisResultValueObjectObject[["genes"]] <-
          lapply(self$`genes`, function(x) x$toJSON())
      }
      if (!is.null(self$`correctedPvalue`)) {
        DifferentialExpressionAnalysisResultValueObjectObject[["correctedPvalue"]] <-
          self$`correctedPvalue`
      }
      if (!is.null(self$`rank`)) {
        DifferentialExpressionAnalysisResultValueObjectObject[["rank"]] <-
          self$`rank`
      }
      if (!is.null(self$`contrasts`)) {
        DifferentialExpressionAnalysisResultValueObjectObject[["contrasts"]] <-
          lapply(self$`contrasts`, function(x) x$toJSON())
      }
      if (!is.null(self$`pvalue`)) {
        DifferentialExpressionAnalysisResultValueObjectObject[["pvalue"]] <-
          self$`pvalue`
      }
      DifferentialExpressionAnalysisResultValueObjectObject
    },
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DifferentialExpressionAnalysisResultValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`probeId`)) {
        self$`probeId` <- this_object$`probeId`
      }
      if (!is.null(this_object$`probeName`)) {
        self$`probeName` <- this_object$`probeName`
      }
      if (!is.null(this_object$`genes`)) {
        self$`genes` <- ApiClient$new()$deserializeObj(this_object$`genes`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`correctedPvalue`)) {
        self$`correctedPvalue` <- this_object$`correctedPvalue`
      }
      if (!is.null(this_object$`rank`)) {
        self$`rank` <- this_object$`rank`
      }
      if (!is.null(this_object$`contrasts`)) {
        self$`contrasts` <- ApiClient$new()$deserializeObj(this_object$`contrasts`, "array[ContrastResultValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`pvalue`)) {
        self$`pvalue` <- this_object$`pvalue`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DifferentialExpressionAnalysisResultValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`probeId`)) {
          sprintf(
          '"probeId":
            %d
                    ',
          self$`probeId`
          )
        },
        if (!is.null(self$`probeName`)) {
          sprintf(
          '"probeName":
            "%s"
                    ',
          self$`probeName`
          )
        },
        if (!is.null(self$`genes`)) {
          sprintf(
          '"genes":
          [%s]
',
          paste(sapply(self$`genes`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`correctedPvalue`)) {
          sprintf(
          '"correctedPvalue":
            %d
                    ',
          self$`correctedPvalue`
          )
        },
        if (!is.null(self$`rank`)) {
          sprintf(
          '"rank":
            %d
                    ',
          self$`rank`
          )
        },
        if (!is.null(self$`contrasts`)) {
          sprintf(
          '"contrasts":
          [%s]
',
          paste(sapply(self$`contrasts`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`pvalue`)) {
          sprintf(
          '"pvalue":
            %d
                    ',
          self$`pvalue`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DifferentialExpressionAnalysisResultValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`probeId` <- this_object$`probeId`
      self$`probeName` <- this_object$`probeName`
      self$`genes` <- ApiClient$new()$deserializeObj(this_object$`genes`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      self$`correctedPvalue` <- this_object$`correctedPvalue`
      self$`rank` <- this_object$`rank`
      self$`contrasts` <- ApiClient$new()$deserializeObj(this_object$`contrasts`, "array[ContrastResultValueObject]", loadNamespace("gemma.R"))
      self$`pvalue` <- this_object$`pvalue`
      self
    },
    #' Validate JSON input with respect to DifferentialExpressionAnalysisResultValueObject
    #'
    #' @description
    #' Validate JSON input with respect to DifferentialExpressionAnalysisResultValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of DifferentialExpressionAnalysisResultValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DifferentialExpressionAnalysisResultValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DifferentialExpressionAnalysisResultValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DifferentialExpressionAnalysisResultValueObject$lock()


#' Create a new DifferentialExpressionAnalysisValueObject
#'
#' @description
#' DifferentialExpressionAnalysisValueObject Class
#'
#' @docType class
#' @title DifferentialExpressionAnalysisValueObject
#' @description DifferentialExpressionAnalysisValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field factorValuesUsed  named list(list(\link{FactorValueValueObject})) optional
#' @field resultSets  list(\link{DiffExResultSetSummaryValueObject}) optional
#' @field arrayDesignsUsed  list(integer) optional
#' @field bioAssaySetId  integer optional
#' @field sourceExperiment  integer optional
#' @field subsetFactor  \link{ExperimentalFactorValueObject} optional
#' @field subsetFactorValue  \link{FactorValueValueObject} optional
#' @field subset  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DifferentialExpressionAnalysisValueObject <- R6::R6Class(
  "DifferentialExpressionAnalysisValueObject",
  public = list(
    `id` = NULL,
    `factorValuesUsed` = NULL,
    `resultSets` = NULL,
    `arrayDesignsUsed` = NULL,
    `bioAssaySetId` = NULL,
    `sourceExperiment` = NULL,
    `subsetFactor` = NULL,
    `subsetFactorValue` = NULL,
    `subset` = NULL,
    #' Initialize a new DifferentialExpressionAnalysisValueObject class.
    #'
    #' @description
    #' Initialize a new DifferentialExpressionAnalysisValueObject class.
    #'
    #' @param id id
    #' @param factorValuesUsed factorValuesUsed
    #' @param resultSets resultSets
    #' @param arrayDesignsUsed arrayDesignsUsed
    #' @param bioAssaySetId bioAssaySetId
    #' @param sourceExperiment sourceExperiment
    #' @param subsetFactor subsetFactor
    #' @param subsetFactorValue subsetFactorValue
    #' @param subset subset
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `factorValuesUsed` = NULL, `resultSets` = NULL, `arrayDesignsUsed` = NULL, `bioAssaySetId` = NULL, `sourceExperiment` = NULL, `subsetFactor` = NULL, `subsetFactorValue` = NULL, `subset` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`factorValuesUsed`)) {
        stopifnot(is.vector(`factorValuesUsed`), length(`factorValuesUsed`) != 0)
        sapply(`factorValuesUsed`, function(x) stopifnot(R6::is.R6(x)))
        self$`factorValuesUsed` <- `factorValuesUsed`
      }
      if (!is.null(`resultSets`)) {
        stopifnot(is.vector(`resultSets`), length(`resultSets`) != 0)
        sapply(`resultSets`, function(x) stopifnot(R6::is.R6(x)))
        self$`resultSets` <- `resultSets`
      }
      if (!is.null(`arrayDesignsUsed`)) {
        stopifnot(is.vector(`arrayDesignsUsed`), length(`arrayDesignsUsed`) != 0)
        sapply(`arrayDesignsUsed`, function(x) stopifnot(is.character(x)))
        self$`arrayDesignsUsed` <- `arrayDesignsUsed`
      }
      if (!is.null(`bioAssaySetId`)) {
        stopifnot(is.numeric(`bioAssaySetId`), length(`bioAssaySetId`) == 1)
        self$`bioAssaySetId` <- `bioAssaySetId`
      }
      if (!is.null(`sourceExperiment`)) {
        stopifnot(is.numeric(`sourceExperiment`), length(`sourceExperiment`) == 1)
        self$`sourceExperiment` <- `sourceExperiment`
      }
      if (!is.null(`subsetFactor`)) {
        stopifnot(R6::is.R6(`subsetFactor`))
        self$`subsetFactor` <- `subsetFactor`
      }
      if (!is.null(`subsetFactorValue`)) {
        stopifnot(R6::is.R6(`subsetFactorValue`))
        self$`subsetFactorValue` <- `subsetFactorValue`
      }
      if (!is.null(`subset`)) {
        stopifnot(is.logical(`subset`), length(`subset`) == 1)
        self$`subset` <- `subset`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DifferentialExpressionAnalysisValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      DifferentialExpressionAnalysisValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        DifferentialExpressionAnalysisValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`factorValuesUsed`)) {
        DifferentialExpressionAnalysisValueObjectObject[["factorValuesUsed"]] <-
          lapply(self$`factorValuesUsed`, function(x) x$toJSON())
      }
      if (!is.null(self$`resultSets`)) {
        DifferentialExpressionAnalysisValueObjectObject[["resultSets"]] <-
          lapply(self$`resultSets`, function(x) x$toJSON())
      }
      if (!is.null(self$`arrayDesignsUsed`)) {
        DifferentialExpressionAnalysisValueObjectObject[["arrayDesignsUsed"]] <-
          self$`arrayDesignsUsed`
      }
      if (!is.null(self$`bioAssaySetId`)) {
        DifferentialExpressionAnalysisValueObjectObject[["bioAssaySetId"]] <-
          self$`bioAssaySetId`
      }
      if (!is.null(self$`sourceExperiment`)) {
        DifferentialExpressionAnalysisValueObjectObject[["sourceExperiment"]] <-
          self$`sourceExperiment`
      }
      if (!is.null(self$`subsetFactor`)) {
        DifferentialExpressionAnalysisValueObjectObject[["subsetFactor"]] <-
          self$`subsetFactor`$toJSON()
      }
      if (!is.null(self$`subsetFactorValue`)) {
        DifferentialExpressionAnalysisValueObjectObject[["subsetFactorValue"]] <-
          self$`subsetFactorValue`$toJSON()
      }
      if (!is.null(self$`subset`)) {
        DifferentialExpressionAnalysisValueObjectObject[["subset"]] <-
          self$`subset`
      }
      DifferentialExpressionAnalysisValueObjectObject
    },
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DifferentialExpressionAnalysisValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`factorValuesUsed`)) {
        self$`factorValuesUsed` <- ApiClient$new()$deserializeObj(this_object$`factorValuesUsed`, "map(array[FactorValueValueObject])", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`resultSets`)) {
        self$`resultSets` <- ApiClient$new()$deserializeObj(this_object$`resultSets`, "array[DiffExResultSetSummaryValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`arrayDesignsUsed`)) {
        self$`arrayDesignsUsed` <- ApiClient$new()$deserializeObj(this_object$`arrayDesignsUsed`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`bioAssaySetId`)) {
        self$`bioAssaySetId` <- this_object$`bioAssaySetId`
      }
      if (!is.null(this_object$`sourceExperiment`)) {
        self$`sourceExperiment` <- this_object$`sourceExperiment`
      }
      if (!is.null(this_object$`subsetFactor`)) {
        subsetfactor_object <- ExperimentalFactorValueObject$new()
        subsetfactor_object$fromJSON(jsonlite::toJSON(this_object$subsetFactor, auto_unbox = TRUE, digits = NA))
        self$`subsetFactor` <- subsetfactor_object
      }
      if (!is.null(this_object$`subsetFactorValue`)) {
        subsetfactorvalue_object <- FactorValueValueObject$new()
        subsetfactorvalue_object$fromJSON(jsonlite::toJSON(this_object$subsetFactorValue, auto_unbox = TRUE, digits = NA))
        self$`subsetFactorValue` <- subsetfactorvalue_object
      }
      if (!is.null(this_object$`subset`)) {
        self$`subset` <- this_object$`subset`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DifferentialExpressionAnalysisValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`factorValuesUsed`)) {
          sprintf(
          '"factorValuesUsed":
          %s
',
          jsonlite::toJSON(lapply(self$`factorValuesUsed`, function(x){ x$toJSON() }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`resultSets`)) {
          sprintf(
          '"resultSets":
          [%s]
',
          paste(sapply(self$`resultSets`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`arrayDesignsUsed`)) {
          sprintf(
          '"arrayDesignsUsed":
             [%s]
          ',
          paste(unlist(lapply(self$`arrayDesignsUsed`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`bioAssaySetId`)) {
          sprintf(
          '"bioAssaySetId":
            %d
                    ',
          self$`bioAssaySetId`
          )
        },
        if (!is.null(self$`sourceExperiment`)) {
          sprintf(
          '"sourceExperiment":
            %d
                    ',
          self$`sourceExperiment`
          )
        },
        if (!is.null(self$`subsetFactor`)) {
          sprintf(
          '"subsetFactor":
          %s
          ',
          jsonlite::toJSON(self$`subsetFactor`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`subsetFactorValue`)) {
          sprintf(
          '"subsetFactorValue":
          %s
          ',
          jsonlite::toJSON(self$`subsetFactorValue`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`subset`)) {
          sprintf(
          '"subset":
            %s
                    ',
          tolower(self$`subset`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of DifferentialExpressionAnalysisValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of DifferentialExpressionAnalysisValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`factorValuesUsed` <- ApiClient$new()$deserializeObj(this_object$`factorValuesUsed`, "map(array[FactorValueValueObject])", loadNamespace("gemma.R"))
      self$`resultSets` <- ApiClient$new()$deserializeObj(this_object$`resultSets`, "array[DiffExResultSetSummaryValueObject]", loadNamespace("gemma.R"))
      self$`arrayDesignsUsed` <- ApiClient$new()$deserializeObj(this_object$`arrayDesignsUsed`, "array[integer]", loadNamespace("gemma.R"))
      self$`bioAssaySetId` <- this_object$`bioAssaySetId`
      self$`sourceExperiment` <- this_object$`sourceExperiment`
      self$`subsetFactor` <- ExperimentalFactorValueObject$new()$fromJSON(jsonlite::toJSON(this_object$subsetFactor, auto_unbox = TRUE, digits = NA))
      self$`subsetFactorValue` <- FactorValueValueObject$new()$fromJSON(jsonlite::toJSON(this_object$subsetFactorValue, auto_unbox = TRUE, digits = NA))
      self$`subset` <- this_object$`subset`
      self
    },
    #' Validate JSON input with respect to DifferentialExpressionAnalysisValueObject
    #'
    #' @description
    #' Validate JSON input with respect to DifferentialExpressionAnalysisValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of DifferentialExpressionAnalysisValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DifferentialExpressionAnalysisValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DifferentialExpressionAnalysisValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DifferentialExpressionAnalysisValueObject$lock()


#' Create a new DoubleMatrixLongInteger
#'
#' @description
#' DoubleMatrixLongInteger Class
#'
#' @docType class
#' @title DoubleMatrixLongInteger
#' @description DoubleMatrixLongInteger Class
#' @format An \code{R6Class} generator object
#' @field colNames  list(integer) optional
#' @field rowNames  list(integer) optional
#' @field rawMatrix  list(list(numeric)) optional
#' @field columnNames  list(integer) optional
#' @field rowNameMapIterator  object optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
DoubleMatrixLongInteger <- R6::R6Class(
  "DoubleMatrixLongInteger",
  public = list(
    `colNames` = NULL,
    `rowNames` = NULL,
    `rawMatrix` = NULL,
    `columnNames` = NULL,
    `rowNameMapIterator` = NULL,
    #' Initialize a new DoubleMatrixLongInteger class.
    #'
    #' @description
    #' Initialize a new DoubleMatrixLongInteger class.
    #'
    #' @param colNames colNames
    #' @param rowNames rowNames
    #' @param rawMatrix rawMatrix
    #' @param columnNames columnNames
    #' @param rowNameMapIterator rowNameMapIterator
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `colNames` = NULL, `rowNames` = NULL, `rawMatrix` = NULL, `columnNames` = NULL, `rowNameMapIterator` = NULL, ...
    ) {
      if (!is.null(`colNames`)) {
        stopifnot(is.vector(`colNames`), length(`colNames`) != 0)
        sapply(`colNames`, function(x) stopifnot(is.character(x)))
        self$`colNames` <- `colNames`
      }
      if (!is.null(`rowNames`)) {
        stopifnot(is.vector(`rowNames`), length(`rowNames`) != 0)
        sapply(`rowNames`, function(x) stopifnot(is.character(x)))
        self$`rowNames` <- `rowNames`
      }
      if (!is.null(`rawMatrix`)) {
        stopifnot(is.vector(`rawMatrix`), length(`rawMatrix`) != 0)
        sapply(`rawMatrix`, function(x) stopifnot(R6::is.R6(x)))
        self$`rawMatrix` <- `rawMatrix`
      }
      if (!is.null(`columnNames`)) {
        stopifnot(is.vector(`columnNames`), length(`columnNames`) != 0)
        sapply(`columnNames`, function(x) stopifnot(is.character(x)))
        self$`columnNames` <- `columnNames`
      }
      if (!is.null(`rowNameMapIterator`)) {
        self$`rowNameMapIterator` <- `rowNameMapIterator`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DoubleMatrixLongInteger in JSON format
    #' @keywords internal
    toJSON = function() {
      DoubleMatrixLongIntegerObject <- list()
      if (!is.null(self$`colNames`)) {
        DoubleMatrixLongIntegerObject[["colNames"]] <-
          self$`colNames`
      }
      if (!is.null(self$`rowNames`)) {
        DoubleMatrixLongIntegerObject[["rowNames"]] <-
          self$`rowNames`
      }
      if (!is.null(self$`rawMatrix`)) {
        DoubleMatrixLongIntegerObject[["rawMatrix"]] <-
          lapply(self$`rawMatrix`, function(x) x$toJSON())
      }
      if (!is.null(self$`columnNames`)) {
        DoubleMatrixLongIntegerObject[["columnNames"]] <-
          self$`columnNames`
      }
      if (!is.null(self$`rowNameMapIterator`)) {
        DoubleMatrixLongIntegerObject[["rowNameMapIterator"]] <-
          self$`rowNameMapIterator`
      }
      DoubleMatrixLongIntegerObject
    },
    #' Deserialize JSON string into an instance of DoubleMatrixLongInteger
    #'
    #' @description
    #' Deserialize JSON string into an instance of DoubleMatrixLongInteger
    #'
    #' @param input_json the JSON input
    #' @return the instance of DoubleMatrixLongInteger
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`colNames`)) {
        self$`colNames` <- ApiClient$new()$deserializeObj(this_object$`colNames`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`rowNames`)) {
        self$`rowNames` <- ApiClient$new()$deserializeObj(this_object$`rowNames`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`rawMatrix`)) {
        self$`rawMatrix` <- ApiClient$new()$deserializeObj(this_object$`rawMatrix`, "array[array[numeric]]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`columnNames`)) {
        self$`columnNames` <- ApiClient$new()$deserializeObj(this_object$`columnNames`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`rowNameMapIterator`)) {
        self$`rowNameMapIterator` <- this_object$`rowNameMapIterator`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return DoubleMatrixLongInteger in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`colNames`)) {
          sprintf(
          '"colNames":
             [%s]
          ',
          paste(unlist(lapply(self$`colNames`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`rowNames`)) {
          sprintf(
          '"rowNames":
             [%s]
          ',
          paste(unlist(lapply(self$`rowNames`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`rawMatrix`)) {
          sprintf(
          '"rawMatrix":
          [%s]
',
          paste(sapply(self$`rawMatrix`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`columnNames`)) {
          sprintf(
          '"columnNames":
             [%s]
          ',
          paste(unlist(lapply(self$`columnNames`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`rowNameMapIterator`)) {
          sprintf(
          '"rowNameMapIterator":
            "%s"
                    ',
          self$`rowNameMapIterator`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of DoubleMatrixLongInteger
    #'
    #' @description
    #' Deserialize JSON string into an instance of DoubleMatrixLongInteger
    #'
    #' @param input_json the JSON input
    #' @return the instance of DoubleMatrixLongInteger
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`colNames` <- ApiClient$new()$deserializeObj(this_object$`colNames`, "array[integer]", loadNamespace("gemma.R"))
      self$`rowNames` <- ApiClient$new()$deserializeObj(this_object$`rowNames`, "array[integer]", loadNamespace("gemma.R"))
      self$`rawMatrix` <- ApiClient$new()$deserializeObj(this_object$`rawMatrix`, "array[array[numeric]]", loadNamespace("gemma.R"))
      self$`columnNames` <- ApiClient$new()$deserializeObj(this_object$`columnNames`, "array[integer]", loadNamespace("gemma.R"))
      self$`rowNameMapIterator` <- this_object$`rowNameMapIterator`
      self
    },
    #' Validate JSON input with respect to DoubleMatrixLongInteger
    #'
    #' @description
    #' Validate JSON input with respect to DoubleMatrixLongInteger and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of DoubleMatrixLongInteger
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
DoubleMatrixLongInteger$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
DoubleMatrixLongInteger$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
DoubleMatrixLongInteger$lock()


#' Create a new ExperimentExpressionLevelsValueObject
#'
#' @description
#' ExperimentExpressionLevelsValueObject Class
#'
#' @docType class
#' @title ExperimentExpressionLevelsValueObject
#' @description ExperimentExpressionLevelsValueObject Class
#' @format An \code{R6Class} generator object
#' @field datasetId  integer optional
#' @field geneExpressionLevels  list(\link{GeneElementExpressionsValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ExperimentExpressionLevelsValueObject <- R6::R6Class(
  "ExperimentExpressionLevelsValueObject",
  public = list(
    `datasetId` = NULL,
    `geneExpressionLevels` = NULL,
    #' Initialize a new ExperimentExpressionLevelsValueObject class.
    #'
    #' @description
    #' Initialize a new ExperimentExpressionLevelsValueObject class.
    #'
    #' @param datasetId datasetId
    #' @param geneExpressionLevels geneExpressionLevels
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `datasetId` = NULL, `geneExpressionLevels` = NULL, ...
    ) {
      if (!is.null(`datasetId`)) {
        stopifnot(is.numeric(`datasetId`), length(`datasetId`) == 1)
        self$`datasetId` <- `datasetId`
      }
      if (!is.null(`geneExpressionLevels`)) {
        stopifnot(is.vector(`geneExpressionLevels`), length(`geneExpressionLevels`) != 0)
        sapply(`geneExpressionLevels`, function(x) stopifnot(R6::is.R6(x)))
        self$`geneExpressionLevels` <- `geneExpressionLevels`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExperimentExpressionLevelsValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ExperimentExpressionLevelsValueObjectObject <- list()
      if (!is.null(self$`datasetId`)) {
        ExperimentExpressionLevelsValueObjectObject[["datasetId"]] <-
          self$`datasetId`
      }
      if (!is.null(self$`geneExpressionLevels`)) {
        ExperimentExpressionLevelsValueObjectObject[["geneExpressionLevels"]] <-
          lapply(self$`geneExpressionLevels`, function(x) x$toJSON())
      }
      ExperimentExpressionLevelsValueObjectObject
    },
    #' Deserialize JSON string into an instance of ExperimentExpressionLevelsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExperimentExpressionLevelsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExperimentExpressionLevelsValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`datasetId`)) {
        self$`datasetId` <- this_object$`datasetId`
      }
      if (!is.null(this_object$`geneExpressionLevels`)) {
        self$`geneExpressionLevels` <- ApiClient$new()$deserializeObj(this_object$`geneExpressionLevels`, "array[GeneElementExpressionsValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExperimentExpressionLevelsValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`datasetId`)) {
          sprintf(
          '"datasetId":
            %d
                    ',
          self$`datasetId`
          )
        },
        if (!is.null(self$`geneExpressionLevels`)) {
          sprintf(
          '"geneExpressionLevels":
          [%s]
',
          paste(sapply(self$`geneExpressionLevels`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ExperimentExpressionLevelsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExperimentExpressionLevelsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExperimentExpressionLevelsValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`datasetId` <- this_object$`datasetId`
      self$`geneExpressionLevels` <- ApiClient$new()$deserializeObj(this_object$`geneExpressionLevels`, "array[GeneElementExpressionsValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ExperimentExpressionLevelsValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ExperimentExpressionLevelsValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ExperimentExpressionLevelsValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ExperimentExpressionLevelsValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ExperimentExpressionLevelsValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ExperimentExpressionLevelsValueObject$lock()


#' Create a new ExperimentalFactorValueObject
#'
#' @description
#' ExperimentalFactorValueObject Class
#'
#' @docType class
#' @title ExperimentalFactorValueObject
#' @description ExperimentalFactorValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field category  character optional
#' @field categoryUri  character optional
#' @field description  character optional
#' @field factorValues  character optional
#' @field name  character optional
#' @field numValues  integer optional
#' @field type  character optional
#' @field values  list(\link{FactorValueValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ExperimentalFactorValueObject <- R6::R6Class(
  "ExperimentalFactorValueObject",
  public = list(
    `id` = NULL,
    `category` = NULL,
    `categoryUri` = NULL,
    `description` = NULL,
    `factorValues` = NULL,
    `name` = NULL,
    `numValues` = NULL,
    `type` = NULL,
    `values` = NULL,
    #' Initialize a new ExperimentalFactorValueObject class.
    #'
    #' @description
    #' Initialize a new ExperimentalFactorValueObject class.
    #'
    #' @param id id
    #' @param category category
    #' @param categoryUri categoryUri
    #' @param description description
    #' @param factorValues factorValues
    #' @param name name
    #' @param numValues numValues
    #' @param type type
    #' @param values values
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `category` = NULL, `categoryUri` = NULL, `description` = NULL, `factorValues` = NULL, `name` = NULL, `numValues` = NULL, `type` = NULL, `values` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`category`)) {
        stopifnot(is.character(`category`), length(`category`) == 1)
        self$`category` <- `category`
      }
      if (!is.null(`categoryUri`)) {
        stopifnot(is.character(`categoryUri`), length(`categoryUri`) == 1)
        self$`categoryUri` <- `categoryUri`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`factorValues`)) {
        stopifnot(is.character(`factorValues`), length(`factorValues`) == 1)
        self$`factorValues` <- `factorValues`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`numValues`)) {
        stopifnot(is.numeric(`numValues`), length(`numValues`) == 1)
        self$`numValues` <- `numValues`
      }
      if (!is.null(`type`)) {
        stopifnot(is.character(`type`), length(`type`) == 1)
        self$`type` <- `type`
      }
      if (!is.null(`values`)) {
        stopifnot(is.vector(`values`), length(`values`) != 0)
        sapply(`values`, function(x) stopifnot(R6::is.R6(x)))
        self$`values` <- `values`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExperimentalFactorValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ExperimentalFactorValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        ExperimentalFactorValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`category`)) {
        ExperimentalFactorValueObjectObject[["category"]] <-
          self$`category`
      }
      if (!is.null(self$`categoryUri`)) {
        ExperimentalFactorValueObjectObject[["categoryUri"]] <-
          self$`categoryUri`
      }
      if (!is.null(self$`description`)) {
        ExperimentalFactorValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`factorValues`)) {
        ExperimentalFactorValueObjectObject[["factorValues"]] <-
          self$`factorValues`
      }
      if (!is.null(self$`name`)) {
        ExperimentalFactorValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`numValues`)) {
        ExperimentalFactorValueObjectObject[["numValues"]] <-
          self$`numValues`
      }
      if (!is.null(self$`type`)) {
        ExperimentalFactorValueObjectObject[["type"]] <-
          self$`type`
      }
      if (!is.null(self$`values`)) {
        ExperimentalFactorValueObjectObject[["values"]] <-
          lapply(self$`values`, function(x) x$toJSON())
      }
      ExperimentalFactorValueObjectObject
    },
    #' Deserialize JSON string into an instance of ExperimentalFactorValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExperimentalFactorValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExperimentalFactorValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`category`)) {
        self$`category` <- this_object$`category`
      }
      if (!is.null(this_object$`categoryUri`)) {
        self$`categoryUri` <- this_object$`categoryUri`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`factorValues`)) {
        self$`factorValues` <- this_object$`factorValues`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`numValues`)) {
        self$`numValues` <- this_object$`numValues`
      }
      if (!is.null(this_object$`type`)) {
        self$`type` <- this_object$`type`
      }
      if (!is.null(this_object$`values`)) {
        self$`values` <- ApiClient$new()$deserializeObj(this_object$`values`, "array[FactorValueValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExperimentalFactorValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`category`)) {
          sprintf(
          '"category":
            "%s"
                    ',
          self$`category`
          )
        },
        if (!is.null(self$`categoryUri`)) {
          sprintf(
          '"categoryUri":
            "%s"
                    ',
          self$`categoryUri`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`factorValues`)) {
          sprintf(
          '"factorValues":
            "%s"
                    ',
          self$`factorValues`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`numValues`)) {
          sprintf(
          '"numValues":
            %d
                    ',
          self$`numValues`
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
          '"type":
            "%s"
                    ',
          self$`type`
          )
        },
        if (!is.null(self$`values`)) {
          sprintf(
          '"values":
          [%s]
',
          paste(sapply(self$`values`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ExperimentalFactorValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExperimentalFactorValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExperimentalFactorValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`category` <- this_object$`category`
      self$`categoryUri` <- this_object$`categoryUri`
      self$`description` <- this_object$`description`
      self$`factorValues` <- this_object$`factorValues`
      self$`name` <- this_object$`name`
      self$`numValues` <- this_object$`numValues`
      self$`type` <- this_object$`type`
      self$`values` <- ApiClient$new()$deserializeObj(this_object$`values`, "array[FactorValueValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ExperimentalFactorValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ExperimentalFactorValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ExperimentalFactorValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ExperimentalFactorValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ExperimentalFactorValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ExperimentalFactorValueObject$lock()


#' Create a new ExpressionAnalysisResultSetValueObject
#'
#' @description
#' ExpressionAnalysisResultSetValueObject Class
#'
#' @docType class
#' @title ExpressionAnalysisResultSetValueObject
#' @description ExpressionAnalysisResultSetValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field analysis  \link{DifferentialExpressionAnalysisValueObject} optional
#' @field experimentalFactors  list(\link{ExperimentalFactorValueObject}) optional
#' @field results  list(\link{DifferentialExpressionAnalysisResultValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ExpressionAnalysisResultSetValueObject <- R6::R6Class(
  "ExpressionAnalysisResultSetValueObject",
  public = list(
    `id` = NULL,
    `analysis` = NULL,
    `experimentalFactors` = NULL,
    `results` = NULL,
    #' Initialize a new ExpressionAnalysisResultSetValueObject class.
    #'
    #' @description
    #' Initialize a new ExpressionAnalysisResultSetValueObject class.
    #'
    #' @param id id
    #' @param analysis analysis
    #' @param experimentalFactors experimentalFactors
    #' @param results results
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `analysis` = NULL, `experimentalFactors` = NULL, `results` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`analysis`)) {
        stopifnot(R6::is.R6(`analysis`))
        self$`analysis` <- `analysis`
      }
      if (!is.null(`experimentalFactors`)) {
        stopifnot(is.vector(`experimentalFactors`), length(`experimentalFactors`) != 0)
        sapply(`experimentalFactors`, function(x) stopifnot(R6::is.R6(x)))
        self$`experimentalFactors` <- `experimentalFactors`
      }
      if (!is.null(`results`)) {
        stopifnot(is.vector(`results`), length(`results`) != 0)
        sapply(`results`, function(x) stopifnot(R6::is.R6(x)))
        self$`results` <- `results`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExpressionAnalysisResultSetValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ExpressionAnalysisResultSetValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        ExpressionAnalysisResultSetValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`analysis`)) {
        ExpressionAnalysisResultSetValueObjectObject[["analysis"]] <-
          self$`analysis`$toJSON()
      }
      if (!is.null(self$`experimentalFactors`)) {
        ExpressionAnalysisResultSetValueObjectObject[["experimentalFactors"]] <-
          lapply(self$`experimentalFactors`, function(x) x$toJSON())
      }
      if (!is.null(self$`results`)) {
        ExpressionAnalysisResultSetValueObjectObject[["results"]] <-
          lapply(self$`results`, function(x) x$toJSON())
      }
      ExpressionAnalysisResultSetValueObjectObject
    },
    #' Deserialize JSON string into an instance of ExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExpressionAnalysisResultSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExpressionAnalysisResultSetValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`analysis`)) {
        analysis_object <- DifferentialExpressionAnalysisValueObject$new()
        analysis_object$fromJSON(jsonlite::toJSON(this_object$analysis, auto_unbox = TRUE, digits = NA))
        self$`analysis` <- analysis_object
      }
      if (!is.null(this_object$`experimentalFactors`)) {
        self$`experimentalFactors` <- ApiClient$new()$deserializeObj(this_object$`experimentalFactors`, "array[ExperimentalFactorValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`results`)) {
        self$`results` <- ApiClient$new()$deserializeObj(this_object$`results`, "array[DifferentialExpressionAnalysisResultValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExpressionAnalysisResultSetValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`analysis`)) {
          sprintf(
          '"analysis":
          %s
          ',
          jsonlite::toJSON(self$`analysis`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`experimentalFactors`)) {
          sprintf(
          '"experimentalFactors":
          [%s]
',
          paste(sapply(self$`experimentalFactors`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`results`)) {
          sprintf(
          '"results":
          [%s]
',
          paste(sapply(self$`results`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExpressionAnalysisResultSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExpressionAnalysisResultSetValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`analysis` <- DifferentialExpressionAnalysisValueObject$new()$fromJSON(jsonlite::toJSON(this_object$analysis, auto_unbox = TRUE, digits = NA))
      self$`experimentalFactors` <- ApiClient$new()$deserializeObj(this_object$`experimentalFactors`, "array[ExperimentalFactorValueObject]", loadNamespace("gemma.R"))
      self$`results` <- ApiClient$new()$deserializeObj(this_object$`results`, "array[DifferentialExpressionAnalysisResultValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ExpressionAnalysisResultSetValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ExpressionAnalysisResultSetValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ExpressionAnalysisResultSetValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ExpressionAnalysisResultSetValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ExpressionAnalysisResultSetValueObject$lock()


#' Create a new ExpressionExperimentValueObject
#'
#' @description
#' ExpressionExperimentValueObject Class
#'
#' @docType class
#' @title ExpressionExperimentValueObject
#' @description ExpressionExperimentValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field lastUpdated  character optional
#' @field troubled  character optional
#' @field lastTroubledEvent  \link{AuditEventValueObject} optional
#' @field needsAttention  character optional
#' @field lastNeedsAttentionEvent  \link{AuditEventValueObject} optional
#' @field curationNote  character optional
#' @field lastNoteUpdateEvent  \link{AuditEventValueObject} optional
#' @field bioAssayCount  integer optional
#' @field description  character optional
#' @field name  character optional
#' @field accession  character optional
#' @field arrayDesignCount  integer optional
#' @field batchConfound  character optional
#' @field batchEffect  character optional
#' @field bioMaterialCount  integer optional
#' @field currentUserHasWritePermission  character optional
#' @field currentUserIsOwner  character optional
#' @field experimentalDesign  integer optional
#' @field externalDatabase  character optional
#' @field externalUri  character optional
#' @field geeq  \link{GeeqValueObject} optional
#' @field isPublic  character optional
#' @field isShared  character optional
#' @field metadata  character optional
#' @field processedExpressionVectorCount  integer optional
#' @field shortName  character optional
#' @field source  character optional
#' @field suitableForDEA  character optional
#' @field taxon  character optional
#' @field taxonId  integer optional
#' @field technologyType  character optional
#' @field userOwned  character optional
#' @field userCanWrite  character optional
#' @field troubleDetails  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ExpressionExperimentValueObject <- R6::R6Class(
  "ExpressionExperimentValueObject",
  public = list(
    `id` = NULL,
    `lastUpdated` = NULL,
    `troubled` = NULL,
    `lastTroubledEvent` = NULL,
    `needsAttention` = NULL,
    `lastNeedsAttentionEvent` = NULL,
    `curationNote` = NULL,
    `lastNoteUpdateEvent` = NULL,
    `bioAssayCount` = NULL,
    `description` = NULL,
    `name` = NULL,
    `accession` = NULL,
    `arrayDesignCount` = NULL,
    `batchConfound` = NULL,
    `batchEffect` = NULL,
    `bioMaterialCount` = NULL,
    `currentUserHasWritePermission` = NULL,
    `currentUserIsOwner` = NULL,
    `experimentalDesign` = NULL,
    `externalDatabase` = NULL,
    `externalUri` = NULL,
    `geeq` = NULL,
    `isPublic` = NULL,
    `isShared` = NULL,
    `metadata` = NULL,
    `processedExpressionVectorCount` = NULL,
    `shortName` = NULL,
    `source` = NULL,
    `suitableForDEA` = NULL,
    `taxon` = NULL,
    `taxonId` = NULL,
    `technologyType` = NULL,
    `userOwned` = NULL,
    `userCanWrite` = NULL,
    `troubleDetails` = NULL,
    #' Initialize a new ExpressionExperimentValueObject class.
    #'
    #' @description
    #' Initialize a new ExpressionExperimentValueObject class.
    #'
    #' @param id id
    #' @param lastUpdated lastUpdated
    #' @param troubled troubled
    #' @param lastTroubledEvent lastTroubledEvent
    #' @param needsAttention needsAttention
    #' @param lastNeedsAttentionEvent lastNeedsAttentionEvent
    #' @param curationNote curationNote
    #' @param lastNoteUpdateEvent lastNoteUpdateEvent
    #' @param bioAssayCount bioAssayCount
    #' @param description description
    #' @param name name
    #' @param accession accession
    #' @param arrayDesignCount arrayDesignCount
    #' @param batchConfound batchConfound
    #' @param batchEffect batchEffect
    #' @param bioMaterialCount bioMaterialCount
    #' @param currentUserHasWritePermission currentUserHasWritePermission
    #' @param currentUserIsOwner currentUserIsOwner
    #' @param experimentalDesign experimentalDesign
    #' @param externalDatabase externalDatabase
    #' @param externalUri externalUri
    #' @param geeq geeq
    #' @param isPublic isPublic
    #' @param isShared isShared
    #' @param metadata metadata
    #' @param processedExpressionVectorCount processedExpressionVectorCount
    #' @param shortName shortName
    #' @param source source
    #' @param suitableForDEA suitableForDEA
    #' @param taxon taxon
    #' @param taxonId taxonId
    #' @param technologyType technologyType
    #' @param userOwned userOwned
    #' @param userCanWrite userCanWrite
    #' @param troubleDetails troubleDetails
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `lastUpdated` = NULL, `troubled` = NULL, `lastTroubledEvent` = NULL, `needsAttention` = NULL, `lastNeedsAttentionEvent` = NULL, `curationNote` = NULL, `lastNoteUpdateEvent` = NULL, `bioAssayCount` = NULL, `description` = NULL, `name` = NULL, `accession` = NULL, `arrayDesignCount` = NULL, `batchConfound` = NULL, `batchEffect` = NULL, `bioMaterialCount` = NULL, `currentUserHasWritePermission` = NULL, `currentUserIsOwner` = NULL, `experimentalDesign` = NULL, `externalDatabase` = NULL, `externalUri` = NULL, `geeq` = NULL, `isPublic` = NULL, `isShared` = NULL, `metadata` = NULL, `processedExpressionVectorCount` = NULL, `shortName` = NULL, `source` = NULL, `suitableForDEA` = NULL, `taxon` = NULL, `taxonId` = NULL, `technologyType` = NULL, `userOwned` = NULL, `userCanWrite` = NULL, `troubleDetails` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`lastUpdated`)) {
        stopifnot(is.character(`lastUpdated`), length(`lastUpdated`) == 1)
        self$`lastUpdated` <- `lastUpdated`
      }
      if (!is.null(`troubled`)) {
        stopifnot(is.logical(`troubled`), length(`troubled`) == 1)
        self$`troubled` <- `troubled`
      }
      if (!is.null(`lastTroubledEvent`)) {
        stopifnot(R6::is.R6(`lastTroubledEvent`))
        self$`lastTroubledEvent` <- `lastTroubledEvent`
      }
      if (!is.null(`needsAttention`)) {
        stopifnot(is.logical(`needsAttention`), length(`needsAttention`) == 1)
        self$`needsAttention` <- `needsAttention`
      }
      if (!is.null(`lastNeedsAttentionEvent`)) {
        stopifnot(R6::is.R6(`lastNeedsAttentionEvent`))
        self$`lastNeedsAttentionEvent` <- `lastNeedsAttentionEvent`
      }
      if (!is.null(`curationNote`)) {
        stopifnot(is.character(`curationNote`), length(`curationNote`) == 1)
        self$`curationNote` <- `curationNote`
      }
      if (!is.null(`lastNoteUpdateEvent`)) {
        stopifnot(R6::is.R6(`lastNoteUpdateEvent`))
        self$`lastNoteUpdateEvent` <- `lastNoteUpdateEvent`
      }
      if (!is.null(`bioAssayCount`)) {
        stopifnot(is.numeric(`bioAssayCount`), length(`bioAssayCount`) == 1)
        self$`bioAssayCount` <- `bioAssayCount`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`accession`)) {
        stopifnot(is.character(`accession`), length(`accession`) == 1)
        self$`accession` <- `accession`
      }
      if (!is.null(`arrayDesignCount`)) {
        stopifnot(is.numeric(`arrayDesignCount`), length(`arrayDesignCount`) == 1)
        self$`arrayDesignCount` <- `arrayDesignCount`
      }
      if (!is.null(`batchConfound`)) {
        stopifnot(is.character(`batchConfound`), length(`batchConfound`) == 1)
        self$`batchConfound` <- `batchConfound`
      }
      if (!is.null(`batchEffect`)) {
        stopifnot(is.character(`batchEffect`), length(`batchEffect`) == 1)
        self$`batchEffect` <- `batchEffect`
      }
      if (!is.null(`bioMaterialCount`)) {
        stopifnot(is.numeric(`bioMaterialCount`), length(`bioMaterialCount`) == 1)
        self$`bioMaterialCount` <- `bioMaterialCount`
      }
      if (!is.null(`currentUserHasWritePermission`)) {
        stopifnot(is.logical(`currentUserHasWritePermission`), length(`currentUserHasWritePermission`) == 1)
        self$`currentUserHasWritePermission` <- `currentUserHasWritePermission`
      }
      if (!is.null(`currentUserIsOwner`)) {
        stopifnot(is.logical(`currentUserIsOwner`), length(`currentUserIsOwner`) == 1)
        self$`currentUserIsOwner` <- `currentUserIsOwner`
      }
      if (!is.null(`experimentalDesign`)) {
        stopifnot(is.numeric(`experimentalDesign`), length(`experimentalDesign`) == 1)
        self$`experimentalDesign` <- `experimentalDesign`
      }
      if (!is.null(`externalDatabase`)) {
        stopifnot(is.character(`externalDatabase`), length(`externalDatabase`) == 1)
        self$`externalDatabase` <- `externalDatabase`
      }
      if (!is.null(`externalUri`)) {
        stopifnot(is.character(`externalUri`), length(`externalUri`) == 1)
        self$`externalUri` <- `externalUri`
      }
      if (!is.null(`geeq`)) {
        stopifnot(R6::is.R6(`geeq`))
        self$`geeq` <- `geeq`
      }
      if (!is.null(`isPublic`)) {
        stopifnot(is.logical(`isPublic`), length(`isPublic`) == 1)
        self$`isPublic` <- `isPublic`
      }
      if (!is.null(`isShared`)) {
        stopifnot(is.logical(`isShared`), length(`isShared`) == 1)
        self$`isShared` <- `isShared`
      }
      if (!is.null(`metadata`)) {
        stopifnot(is.character(`metadata`), length(`metadata`) == 1)
        self$`metadata` <- `metadata`
      }
      if (!is.null(`processedExpressionVectorCount`)) {
        stopifnot(is.numeric(`processedExpressionVectorCount`), length(`processedExpressionVectorCount`) == 1)
        self$`processedExpressionVectorCount` <- `processedExpressionVectorCount`
      }
      if (!is.null(`shortName`)) {
        stopifnot(is.character(`shortName`), length(`shortName`) == 1)
        self$`shortName` <- `shortName`
      }
      if (!is.null(`source`)) {
        stopifnot(is.character(`source`), length(`source`) == 1)
        self$`source` <- `source`
      }
      if (!is.null(`suitableForDEA`)) {
        stopifnot(is.logical(`suitableForDEA`), length(`suitableForDEA`) == 1)
        self$`suitableForDEA` <- `suitableForDEA`
      }
      if (!is.null(`taxon`)) {
        stopifnot(is.character(`taxon`), length(`taxon`) == 1)
        self$`taxon` <- `taxon`
      }
      if (!is.null(`taxonId`)) {
        stopifnot(is.numeric(`taxonId`), length(`taxonId`) == 1)
        self$`taxonId` <- `taxonId`
      }
      if (!is.null(`technologyType`)) {
        stopifnot(is.character(`technologyType`), length(`technologyType`) == 1)
        self$`technologyType` <- `technologyType`
      }
      if (!is.null(`userOwned`)) {
        stopifnot(is.logical(`userOwned`), length(`userOwned`) == 1)
        self$`userOwned` <- `userOwned`
      }
      if (!is.null(`userCanWrite`)) {
        stopifnot(is.logical(`userCanWrite`), length(`userCanWrite`) == 1)
        self$`userCanWrite` <- `userCanWrite`
      }
      if (!is.null(`troubleDetails`)) {
        stopifnot(is.character(`troubleDetails`), length(`troubleDetails`) == 1)
        self$`troubleDetails` <- `troubleDetails`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExpressionExperimentValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ExpressionExperimentValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        ExpressionExperimentValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`lastUpdated`)) {
        ExpressionExperimentValueObjectObject[["lastUpdated"]] <-
          self$`lastUpdated`
      }
      if (!is.null(self$`troubled`)) {
        ExpressionExperimentValueObjectObject[["troubled"]] <-
          self$`troubled`
      }
      if (!is.null(self$`lastTroubledEvent`)) {
        ExpressionExperimentValueObjectObject[["lastTroubledEvent"]] <-
          self$`lastTroubledEvent`$toJSON()
      }
      if (!is.null(self$`needsAttention`)) {
        ExpressionExperimentValueObjectObject[["needsAttention"]] <-
          self$`needsAttention`
      }
      if (!is.null(self$`lastNeedsAttentionEvent`)) {
        ExpressionExperimentValueObjectObject[["lastNeedsAttentionEvent"]] <-
          self$`lastNeedsAttentionEvent`$toJSON()
      }
      if (!is.null(self$`curationNote`)) {
        ExpressionExperimentValueObjectObject[["curationNote"]] <-
          self$`curationNote`
      }
      if (!is.null(self$`lastNoteUpdateEvent`)) {
        ExpressionExperimentValueObjectObject[["lastNoteUpdateEvent"]] <-
          self$`lastNoteUpdateEvent`$toJSON()
      }
      if (!is.null(self$`bioAssayCount`)) {
        ExpressionExperimentValueObjectObject[["bioAssayCount"]] <-
          self$`bioAssayCount`
      }
      if (!is.null(self$`description`)) {
        ExpressionExperimentValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`name`)) {
        ExpressionExperimentValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`accession`)) {
        ExpressionExperimentValueObjectObject[["accession"]] <-
          self$`accession`
      }
      if (!is.null(self$`arrayDesignCount`)) {
        ExpressionExperimentValueObjectObject[["arrayDesignCount"]] <-
          self$`arrayDesignCount`
      }
      if (!is.null(self$`batchConfound`)) {
        ExpressionExperimentValueObjectObject[["batchConfound"]] <-
          self$`batchConfound`
      }
      if (!is.null(self$`batchEffect`)) {
        ExpressionExperimentValueObjectObject[["batchEffect"]] <-
          self$`batchEffect`
      }
      if (!is.null(self$`bioMaterialCount`)) {
        ExpressionExperimentValueObjectObject[["bioMaterialCount"]] <-
          self$`bioMaterialCount`
      }
      if (!is.null(self$`currentUserHasWritePermission`)) {
        ExpressionExperimentValueObjectObject[["currentUserHasWritePermission"]] <-
          self$`currentUserHasWritePermission`
      }
      if (!is.null(self$`currentUserIsOwner`)) {
        ExpressionExperimentValueObjectObject[["currentUserIsOwner"]] <-
          self$`currentUserIsOwner`
      }
      if (!is.null(self$`experimentalDesign`)) {
        ExpressionExperimentValueObjectObject[["experimentalDesign"]] <-
          self$`experimentalDesign`
      }
      if (!is.null(self$`externalDatabase`)) {
        ExpressionExperimentValueObjectObject[["externalDatabase"]] <-
          self$`externalDatabase`
      }
      if (!is.null(self$`externalUri`)) {
        ExpressionExperimentValueObjectObject[["externalUri"]] <-
          self$`externalUri`
      }
      if (!is.null(self$`geeq`)) {
        ExpressionExperimentValueObjectObject[["geeq"]] <-
          self$`geeq`$toJSON()
      }
      if (!is.null(self$`isPublic`)) {
        ExpressionExperimentValueObjectObject[["isPublic"]] <-
          self$`isPublic`
      }
      if (!is.null(self$`isShared`)) {
        ExpressionExperimentValueObjectObject[["isShared"]] <-
          self$`isShared`
      }
      if (!is.null(self$`metadata`)) {
        ExpressionExperimentValueObjectObject[["metadata"]] <-
          self$`metadata`
      }
      if (!is.null(self$`processedExpressionVectorCount`)) {
        ExpressionExperimentValueObjectObject[["processedExpressionVectorCount"]] <-
          self$`processedExpressionVectorCount`
      }
      if (!is.null(self$`shortName`)) {
        ExpressionExperimentValueObjectObject[["shortName"]] <-
          self$`shortName`
      }
      if (!is.null(self$`source`)) {
        ExpressionExperimentValueObjectObject[["source"]] <-
          self$`source`
      }
      if (!is.null(self$`suitableForDEA`)) {
        ExpressionExperimentValueObjectObject[["suitableForDEA"]] <-
          self$`suitableForDEA`
      }
      if (!is.null(self$`taxon`)) {
        ExpressionExperimentValueObjectObject[["taxon"]] <-
          self$`taxon`
      }
      if (!is.null(self$`taxonId`)) {
        ExpressionExperimentValueObjectObject[["taxonId"]] <-
          self$`taxonId`
      }
      if (!is.null(self$`technologyType`)) {
        ExpressionExperimentValueObjectObject[["technologyType"]] <-
          self$`technologyType`
      }
      if (!is.null(self$`userOwned`)) {
        ExpressionExperimentValueObjectObject[["userOwned"]] <-
          self$`userOwned`
      }
      if (!is.null(self$`userCanWrite`)) {
        ExpressionExperimentValueObjectObject[["userCanWrite"]] <-
          self$`userCanWrite`
      }
      if (!is.null(self$`troubleDetails`)) {
        ExpressionExperimentValueObjectObject[["troubleDetails"]] <-
          self$`troubleDetails`
      }
      ExpressionExperimentValueObjectObject
    },
    #' Deserialize JSON string into an instance of ExpressionExperimentValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExpressionExperimentValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExpressionExperimentValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`lastUpdated`)) {
        self$`lastUpdated` <- this_object$`lastUpdated`
      }
      if (!is.null(this_object$`troubled`)) {
        self$`troubled` <- this_object$`troubled`
      }
      if (!is.null(this_object$`lastTroubledEvent`)) {
        lasttroubledevent_object <- AuditEventValueObject$new()
        lasttroubledevent_object$fromJSON(jsonlite::toJSON(this_object$lastTroubledEvent, auto_unbox = TRUE, digits = NA))
        self$`lastTroubledEvent` <- lasttroubledevent_object
      }
      if (!is.null(this_object$`needsAttention`)) {
        self$`needsAttention` <- this_object$`needsAttention`
      }
      if (!is.null(this_object$`lastNeedsAttentionEvent`)) {
        lastneedsattentionevent_object <- AuditEventValueObject$new()
        lastneedsattentionevent_object$fromJSON(jsonlite::toJSON(this_object$lastNeedsAttentionEvent, auto_unbox = TRUE, digits = NA))
        self$`lastNeedsAttentionEvent` <- lastneedsattentionevent_object
      }
      if (!is.null(this_object$`curationNote`)) {
        self$`curationNote` <- this_object$`curationNote`
      }
      if (!is.null(this_object$`lastNoteUpdateEvent`)) {
        lastnoteupdateevent_object <- AuditEventValueObject$new()
        lastnoteupdateevent_object$fromJSON(jsonlite::toJSON(this_object$lastNoteUpdateEvent, auto_unbox = TRUE, digits = NA))
        self$`lastNoteUpdateEvent` <- lastnoteupdateevent_object
      }
      if (!is.null(this_object$`bioAssayCount`)) {
        self$`bioAssayCount` <- this_object$`bioAssayCount`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`accession`)) {
        self$`accession` <- this_object$`accession`
      }
      if (!is.null(this_object$`arrayDesignCount`)) {
        self$`arrayDesignCount` <- this_object$`arrayDesignCount`
      }
      if (!is.null(this_object$`batchConfound`)) {
        self$`batchConfound` <- this_object$`batchConfound`
      }
      if (!is.null(this_object$`batchEffect`)) {
        self$`batchEffect` <- this_object$`batchEffect`
      }
      if (!is.null(this_object$`bioMaterialCount`)) {
        self$`bioMaterialCount` <- this_object$`bioMaterialCount`
      }
      if (!is.null(this_object$`currentUserHasWritePermission`)) {
        self$`currentUserHasWritePermission` <- this_object$`currentUserHasWritePermission`
      }
      if (!is.null(this_object$`currentUserIsOwner`)) {
        self$`currentUserIsOwner` <- this_object$`currentUserIsOwner`
      }
      if (!is.null(this_object$`experimentalDesign`)) {
        self$`experimentalDesign` <- this_object$`experimentalDesign`
      }
      if (!is.null(this_object$`externalDatabase`)) {
        self$`externalDatabase` <- this_object$`externalDatabase`
      }
      if (!is.null(this_object$`externalUri`)) {
        self$`externalUri` <- this_object$`externalUri`
      }
      if (!is.null(this_object$`geeq`)) {
        geeq_object <- GeeqValueObject$new()
        geeq_object$fromJSON(jsonlite::toJSON(this_object$geeq, auto_unbox = TRUE, digits = NA))
        self$`geeq` <- geeq_object
      }
      if (!is.null(this_object$`isPublic`)) {
        self$`isPublic` <- this_object$`isPublic`
      }
      if (!is.null(this_object$`isShared`)) {
        self$`isShared` <- this_object$`isShared`
      }
      if (!is.null(this_object$`metadata`)) {
        self$`metadata` <- this_object$`metadata`
      }
      if (!is.null(this_object$`processedExpressionVectorCount`)) {
        self$`processedExpressionVectorCount` <- this_object$`processedExpressionVectorCount`
      }
      if (!is.null(this_object$`shortName`)) {
        self$`shortName` <- this_object$`shortName`
      }
      if (!is.null(this_object$`source`)) {
        self$`source` <- this_object$`source`
      }
      if (!is.null(this_object$`suitableForDEA`)) {
        self$`suitableForDEA` <- this_object$`suitableForDEA`
      }
      if (!is.null(this_object$`taxon`)) {
        self$`taxon` <- this_object$`taxon`
      }
      if (!is.null(this_object$`taxonId`)) {
        self$`taxonId` <- this_object$`taxonId`
      }
      if (!is.null(this_object$`technologyType`)) {
        self$`technologyType` <- this_object$`technologyType`
      }
      if (!is.null(this_object$`userOwned`)) {
        self$`userOwned` <- this_object$`userOwned`
      }
      if (!is.null(this_object$`userCanWrite`)) {
        self$`userCanWrite` <- this_object$`userCanWrite`
      }
      if (!is.null(this_object$`troubleDetails`)) {
        self$`troubleDetails` <- this_object$`troubleDetails`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExpressionExperimentValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`lastUpdated`)) {
          sprintf(
          '"lastUpdated":
            "%s"
                    ',
          self$`lastUpdated`
          )
        },
        if (!is.null(self$`troubled`)) {
          sprintf(
          '"troubled":
            %s
                    ',
          tolower(self$`troubled`)
          )
        },
        if (!is.null(self$`lastTroubledEvent`)) {
          sprintf(
          '"lastTroubledEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastTroubledEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`needsAttention`)) {
          sprintf(
          '"needsAttention":
            %s
                    ',
          tolower(self$`needsAttention`)
          )
        },
        if (!is.null(self$`lastNeedsAttentionEvent`)) {
          sprintf(
          '"lastNeedsAttentionEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastNeedsAttentionEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`curationNote`)) {
          sprintf(
          '"curationNote":
            "%s"
                    ',
          self$`curationNote`
          )
        },
        if (!is.null(self$`lastNoteUpdateEvent`)) {
          sprintf(
          '"lastNoteUpdateEvent":
          %s
          ',
          jsonlite::toJSON(self$`lastNoteUpdateEvent`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`bioAssayCount`)) {
          sprintf(
          '"bioAssayCount":
            %d
                    ',
          self$`bioAssayCount`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`accession`)) {
          sprintf(
          '"accession":
            "%s"
                    ',
          self$`accession`
          )
        },
        if (!is.null(self$`arrayDesignCount`)) {
          sprintf(
          '"arrayDesignCount":
            %d
                    ',
          self$`arrayDesignCount`
          )
        },
        if (!is.null(self$`batchConfound`)) {
          sprintf(
          '"batchConfound":
            "%s"
                    ',
          self$`batchConfound`
          )
        },
        if (!is.null(self$`batchEffect`)) {
          sprintf(
          '"batchEffect":
            "%s"
                    ',
          self$`batchEffect`
          )
        },
        if (!is.null(self$`bioMaterialCount`)) {
          sprintf(
          '"bioMaterialCount":
            %d
                    ',
          self$`bioMaterialCount`
          )
        },
        if (!is.null(self$`currentUserHasWritePermission`)) {
          sprintf(
          '"currentUserHasWritePermission":
            %s
                    ',
          tolower(self$`currentUserHasWritePermission`)
          )
        },
        if (!is.null(self$`currentUserIsOwner`)) {
          sprintf(
          '"currentUserIsOwner":
            %s
                    ',
          tolower(self$`currentUserIsOwner`)
          )
        },
        if (!is.null(self$`experimentalDesign`)) {
          sprintf(
          '"experimentalDesign":
            %d
                    ',
          self$`experimentalDesign`
          )
        },
        if (!is.null(self$`externalDatabase`)) {
          sprintf(
          '"externalDatabase":
            "%s"
                    ',
          self$`externalDatabase`
          )
        },
        if (!is.null(self$`externalUri`)) {
          sprintf(
          '"externalUri":
            "%s"
                    ',
          self$`externalUri`
          )
        },
        if (!is.null(self$`geeq`)) {
          sprintf(
          '"geeq":
          %s
          ',
          jsonlite::toJSON(self$`geeq`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`isPublic`)) {
          sprintf(
          '"isPublic":
            %s
                    ',
          tolower(self$`isPublic`)
          )
        },
        if (!is.null(self$`isShared`)) {
          sprintf(
          '"isShared":
            %s
                    ',
          tolower(self$`isShared`)
          )
        },
        if (!is.null(self$`metadata`)) {
          sprintf(
          '"metadata":
            "%s"
                    ',
          self$`metadata`
          )
        },
        if (!is.null(self$`processedExpressionVectorCount`)) {
          sprintf(
          '"processedExpressionVectorCount":
            %d
                    ',
          self$`processedExpressionVectorCount`
          )
        },
        if (!is.null(self$`shortName`)) {
          sprintf(
          '"shortName":
            "%s"
                    ',
          self$`shortName`
          )
        },
        if (!is.null(self$`source`)) {
          sprintf(
          '"source":
            "%s"
                    ',
          self$`source`
          )
        },
        if (!is.null(self$`suitableForDEA`)) {
          sprintf(
          '"suitableForDEA":
            %s
                    ',
          tolower(self$`suitableForDEA`)
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
            "%s"
                    ',
          self$`taxon`
          )
        },
        if (!is.null(self$`taxonId`)) {
          sprintf(
          '"taxonId":
            %d
                    ',
          self$`taxonId`
          )
        },
        if (!is.null(self$`technologyType`)) {
          sprintf(
          '"technologyType":
            "%s"
                    ',
          self$`technologyType`
          )
        },
        if (!is.null(self$`userOwned`)) {
          sprintf(
          '"userOwned":
            %s
                    ',
          tolower(self$`userOwned`)
          )
        },
        if (!is.null(self$`userCanWrite`)) {
          sprintf(
          '"userCanWrite":
            %s
                    ',
          tolower(self$`userCanWrite`)
          )
        },
        if (!is.null(self$`troubleDetails`)) {
          sprintf(
          '"troubleDetails":
            "%s"
                    ',
          self$`troubleDetails`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ExpressionExperimentValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExpressionExperimentValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExpressionExperimentValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`lastUpdated` <- this_object$`lastUpdated`
      self$`troubled` <- this_object$`troubled`
      self$`lastTroubledEvent` <- AuditEventValueObject$new()$fromJSON(jsonlite::toJSON(this_object$lastTroubledEvent, auto_unbox = TRUE, digits = NA))
      self$`needsAttention` <- this_object$`needsAttention`
      self$`lastNeedsAttentionEvent` <- AuditEventValueObject$new()$fromJSON(jsonlite::toJSON(this_object$lastNeedsAttentionEvent, auto_unbox = TRUE, digits = NA))
      self$`curationNote` <- this_object$`curationNote`
      self$`lastNoteUpdateEvent` <- AuditEventValueObject$new()$fromJSON(jsonlite::toJSON(this_object$lastNoteUpdateEvent, auto_unbox = TRUE, digits = NA))
      self$`bioAssayCount` <- this_object$`bioAssayCount`
      self$`description` <- this_object$`description`
      self$`name` <- this_object$`name`
      self$`accession` <- this_object$`accession`
      self$`arrayDesignCount` <- this_object$`arrayDesignCount`
      self$`batchConfound` <- this_object$`batchConfound`
      self$`batchEffect` <- this_object$`batchEffect`
      self$`bioMaterialCount` <- this_object$`bioMaterialCount`
      self$`currentUserHasWritePermission` <- this_object$`currentUserHasWritePermission`
      self$`currentUserIsOwner` <- this_object$`currentUserIsOwner`
      self$`experimentalDesign` <- this_object$`experimentalDesign`
      self$`externalDatabase` <- this_object$`externalDatabase`
      self$`externalUri` <- this_object$`externalUri`
      self$`geeq` <- GeeqValueObject$new()$fromJSON(jsonlite::toJSON(this_object$geeq, auto_unbox = TRUE, digits = NA))
      self$`isPublic` <- this_object$`isPublic`
      self$`isShared` <- this_object$`isShared`
      self$`metadata` <- this_object$`metadata`
      self$`processedExpressionVectorCount` <- this_object$`processedExpressionVectorCount`
      self$`shortName` <- this_object$`shortName`
      self$`source` <- this_object$`source`
      self$`suitableForDEA` <- this_object$`suitableForDEA`
      self$`taxon` <- this_object$`taxon`
      self$`taxonId` <- this_object$`taxonId`
      self$`technologyType` <- this_object$`technologyType`
      self$`userOwned` <- this_object$`userOwned`
      self$`userCanWrite` <- this_object$`userCanWrite`
      self$`troubleDetails` <- this_object$`troubleDetails`
      self
    },
    #' Validate JSON input with respect to ExpressionExperimentValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ExpressionExperimentValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ExpressionExperimentValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ExpressionExperimentValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ExpressionExperimentValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ExpressionExperimentValueObject$lock()


#' Create a new ExternalDatabase
#'
#' @description
#' ExternalDatabase Class
#'
#' @docType class
#' @title ExternalDatabase
#' @description ExternalDatabase Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field localInstallDbName  character optional
#' @field webUri  character optional
#' @field ftpUri  character optional
#' @field type  \link{DatabaseType} optional
#' @field databaseSupplier  \link{Contact} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ExternalDatabase <- R6::R6Class(
  "ExternalDatabase",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `localInstallDbName` = NULL,
    `webUri` = NULL,
    `ftpUri` = NULL,
    `type` = NULL,
    `databaseSupplier` = NULL,
    #' Initialize a new ExternalDatabase class.
    #'
    #' @description
    #' Initialize a new ExternalDatabase class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param localInstallDbName localInstallDbName
    #' @param webUri webUri
    #' @param ftpUri ftpUri
    #' @param type type
    #' @param databaseSupplier databaseSupplier
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `localInstallDbName` = NULL, `webUri` = NULL, `ftpUri` = NULL, `type` = NULL, `databaseSupplier` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`localInstallDbName`)) {
        stopifnot(is.character(`localInstallDbName`), length(`localInstallDbName`) == 1)
        self$`localInstallDbName` <- `localInstallDbName`
      }
      if (!is.null(`webUri`)) {
        stopifnot(is.character(`webUri`), length(`webUri`) == 1)
        self$`webUri` <- `webUri`
      }
      if (!is.null(`ftpUri`)) {
        stopifnot(is.character(`ftpUri`), length(`ftpUri`) == 1)
        self$`ftpUri` <- `ftpUri`
      }
      if (!is.null(`type`)) {
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
      if (!is.null(`databaseSupplier`)) {
        stopifnot(R6::is.R6(`databaseSupplier`))
        self$`databaseSupplier` <- `databaseSupplier`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExternalDatabase in JSON format
    #' @keywords internal
    toJSON = function() {
      ExternalDatabaseObject <- list()
      if (!is.null(self$`name`)) {
        ExternalDatabaseObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        ExternalDatabaseObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        ExternalDatabaseObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`localInstallDbName`)) {
        ExternalDatabaseObject[["localInstallDbName"]] <-
          self$`localInstallDbName`
      }
      if (!is.null(self$`webUri`)) {
        ExternalDatabaseObject[["webUri"]] <-
          self$`webUri`
      }
      if (!is.null(self$`ftpUri`)) {
        ExternalDatabaseObject[["ftpUri"]] <-
          self$`ftpUri`
      }
      if (!is.null(self$`type`)) {
        ExternalDatabaseObject[["type"]] <-
          self$`type`$toJSON()
      }
      if (!is.null(self$`databaseSupplier`)) {
        ExternalDatabaseObject[["databaseSupplier"]] <-
          self$`databaseSupplier`$toJSON()
      }
      ExternalDatabaseObject
    },
    #' Deserialize JSON string into an instance of ExternalDatabase
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExternalDatabase
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExternalDatabase
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`localInstallDbName`)) {
        self$`localInstallDbName` <- this_object$`localInstallDbName`
      }
      if (!is.null(this_object$`webUri`)) {
        self$`webUri` <- this_object$`webUri`
      }
      if (!is.null(this_object$`ftpUri`)) {
        self$`ftpUri` <- this_object$`ftpUri`
      }
      if (!is.null(this_object$`type`)) {
        type_object <- DatabaseType$new()
        type_object$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
        self$`type` <- type_object
      }
      if (!is.null(this_object$`databaseSupplier`)) {
        databasesupplier_object <- Contact$new()
        databasesupplier_object$fromJSON(jsonlite::toJSON(this_object$databaseSupplier, auto_unbox = TRUE, digits = NA))
        self$`databaseSupplier` <- databasesupplier_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExternalDatabase in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`localInstallDbName`)) {
          sprintf(
          '"localInstallDbName":
            "%s"
                    ',
          self$`localInstallDbName`
          )
        },
        if (!is.null(self$`webUri`)) {
          sprintf(
          '"webUri":
            "%s"
                    ',
          self$`webUri`
          )
        },
        if (!is.null(self$`ftpUri`)) {
          sprintf(
          '"ftpUri":
            "%s"
                    ',
          self$`ftpUri`
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
          '"type":
          %s
          ',
          jsonlite::toJSON(self$`type`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`databaseSupplier`)) {
          sprintf(
          '"databaseSupplier":
          %s
          ',
          jsonlite::toJSON(self$`databaseSupplier`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ExternalDatabase
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExternalDatabase
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExternalDatabase
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`localInstallDbName` <- this_object$`localInstallDbName`
      self$`webUri` <- this_object$`webUri`
      self$`ftpUri` <- this_object$`ftpUri`
      self$`type` <- DatabaseType$new()$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
      self$`databaseSupplier` <- Contact$new()$fromJSON(jsonlite::toJSON(this_object$databaseSupplier, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to ExternalDatabase
    #'
    #' @description
    #' Validate JSON input with respect to ExternalDatabase and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ExternalDatabase
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ExternalDatabase$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ExternalDatabase$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ExternalDatabase$lock()


#' Create a new ExternalDatabaseValueObject
#'
#' @description
#' ExternalDatabaseValueObject Class
#'
#' @docType class
#' @title ExternalDatabaseValueObject
#' @description ExternalDatabaseValueObject Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field id  integer optional
#' @field checked  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ExternalDatabaseValueObject <- R6::R6Class(
  "ExternalDatabaseValueObject",
  public = list(
    `name` = NULL,
    `id` = NULL,
    `checked` = NULL,
    #' Initialize a new ExternalDatabaseValueObject class.
    #'
    #' @description
    #' Initialize a new ExternalDatabaseValueObject class.
    #'
    #' @param name name
    #' @param id id
    #' @param checked checked
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `id` = NULL, `checked` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`checked`)) {
        stopifnot(is.logical(`checked`), length(`checked`) == 1)
        self$`checked` <- `checked`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExternalDatabaseValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ExternalDatabaseValueObjectObject <- list()
      if (!is.null(self$`name`)) {
        ExternalDatabaseValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`id`)) {
        ExternalDatabaseValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`checked`)) {
        ExternalDatabaseValueObjectObject[["checked"]] <-
          self$`checked`
      }
      ExternalDatabaseValueObjectObject
    },
    #' Deserialize JSON string into an instance of ExternalDatabaseValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExternalDatabaseValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExternalDatabaseValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`checked`)) {
        self$`checked` <- this_object$`checked`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ExternalDatabaseValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`checked`)) {
          sprintf(
          '"checked":
            %s
                    ',
          tolower(self$`checked`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ExternalDatabaseValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ExternalDatabaseValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ExternalDatabaseValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`id` <- this_object$`id`
      self$`checked` <- this_object$`checked`
      self
    },
    #' Validate JSON input with respect to ExternalDatabaseValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ExternalDatabaseValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ExternalDatabaseValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ExternalDatabaseValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ExternalDatabaseValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ExternalDatabaseValueObject$lock()


#' Create a new FactorValueBasicValueObject
#'
#' @description
#' FactorValueBasicValueObject Class
#'
#' @docType class
#' @title FactorValueBasicValueObject
#' @description FactorValueBasicValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field characteristics  list(\link{CharacteristicBasicValueObject}) optional
#' @field experimentalFactorCategory  \link{CharacteristicBasicValueObject} optional
#' @field measurement  \link{MeasurementValueObject} optional
#' @field fvValue  character optional
#' @field fvSummary  character optional
#' @field experimentalFactorId  integer optional
#' @field baseline  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
FactorValueBasicValueObject <- R6::R6Class(
  "FactorValueBasicValueObject",
  public = list(
    `id` = NULL,
    `characteristics` = NULL,
    `experimentalFactorCategory` = NULL,
    `measurement` = NULL,
    `fvValue` = NULL,
    `fvSummary` = NULL,
    `experimentalFactorId` = NULL,
    `baseline` = NULL,
    #' Initialize a new FactorValueBasicValueObject class.
    #'
    #' @description
    #' Initialize a new FactorValueBasicValueObject class.
    #'
    #' @param id id
    #' @param characteristics characteristics
    #' @param experimentalFactorCategory experimentalFactorCategory
    #' @param measurement measurement
    #' @param fvValue fvValue
    #' @param fvSummary fvSummary
    #' @param experimentalFactorId experimentalFactorId
    #' @param baseline baseline
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `characteristics` = NULL, `experimentalFactorCategory` = NULL, `measurement` = NULL, `fvValue` = NULL, `fvSummary` = NULL, `experimentalFactorId` = NULL, `baseline` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`characteristics`)) {
        stopifnot(is.vector(`characteristics`), length(`characteristics`) != 0)
        sapply(`characteristics`, function(x) stopifnot(R6::is.R6(x)))
        self$`characteristics` <- `characteristics`
      }
      if (!is.null(`experimentalFactorCategory`)) {
        stopifnot(R6::is.R6(`experimentalFactorCategory`))
        self$`experimentalFactorCategory` <- `experimentalFactorCategory`
      }
      if (!is.null(`measurement`)) {
        stopifnot(R6::is.R6(`measurement`))
        self$`measurement` <- `measurement`
      }
      if (!is.null(`fvValue`)) {
        stopifnot(is.character(`fvValue`), length(`fvValue`) == 1)
        self$`fvValue` <- `fvValue`
      }
      if (!is.null(`fvSummary`)) {
        stopifnot(is.character(`fvSummary`), length(`fvSummary`) == 1)
        self$`fvSummary` <- `fvSummary`
      }
      if (!is.null(`experimentalFactorId`)) {
        stopifnot(is.numeric(`experimentalFactorId`), length(`experimentalFactorId`) == 1)
        self$`experimentalFactorId` <- `experimentalFactorId`
      }
      if (!is.null(`baseline`)) {
        stopifnot(is.logical(`baseline`), length(`baseline`) == 1)
        self$`baseline` <- `baseline`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return FactorValueBasicValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      FactorValueBasicValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        FactorValueBasicValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`characteristics`)) {
        FactorValueBasicValueObjectObject[["characteristics"]] <-
          lapply(self$`characteristics`, function(x) x$toJSON())
      }
      if (!is.null(self$`experimentalFactorCategory`)) {
        FactorValueBasicValueObjectObject[["experimentalFactorCategory"]] <-
          self$`experimentalFactorCategory`$toJSON()
      }
      if (!is.null(self$`measurement`)) {
        FactorValueBasicValueObjectObject[["measurement"]] <-
          self$`measurement`$toJSON()
      }
      if (!is.null(self$`fvValue`)) {
        FactorValueBasicValueObjectObject[["fvValue"]] <-
          self$`fvValue`
      }
      if (!is.null(self$`fvSummary`)) {
        FactorValueBasicValueObjectObject[["fvSummary"]] <-
          self$`fvSummary`
      }
      if (!is.null(self$`experimentalFactorId`)) {
        FactorValueBasicValueObjectObject[["experimentalFactorId"]] <-
          self$`experimentalFactorId`
      }
      if (!is.null(self$`baseline`)) {
        FactorValueBasicValueObjectObject[["baseline"]] <-
          self$`baseline`
      }
      FactorValueBasicValueObjectObject
    },
    #' Deserialize JSON string into an instance of FactorValueBasicValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of FactorValueBasicValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of FactorValueBasicValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`characteristics`)) {
        self$`characteristics` <- ApiClient$new()$deserializeObj(this_object$`characteristics`, "array[CharacteristicBasicValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`experimentalFactorCategory`)) {
        experimentalfactorcategory_object <- CharacteristicBasicValueObject$new()
        experimentalfactorcategory_object$fromJSON(jsonlite::toJSON(this_object$experimentalFactorCategory, auto_unbox = TRUE, digits = NA))
        self$`experimentalFactorCategory` <- experimentalfactorcategory_object
      }
      if (!is.null(this_object$`measurement`)) {
        measurement_object <- MeasurementValueObject$new()
        measurement_object$fromJSON(jsonlite::toJSON(this_object$measurement, auto_unbox = TRUE, digits = NA))
        self$`measurement` <- measurement_object
      }
      if (!is.null(this_object$`fvValue`)) {
        self$`fvValue` <- this_object$`fvValue`
      }
      if (!is.null(this_object$`fvSummary`)) {
        self$`fvSummary` <- this_object$`fvSummary`
      }
      if (!is.null(this_object$`experimentalFactorId`)) {
        self$`experimentalFactorId` <- this_object$`experimentalFactorId`
      }
      if (!is.null(this_object$`baseline`)) {
        self$`baseline` <- this_object$`baseline`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return FactorValueBasicValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`characteristics`)) {
          sprintf(
          '"characteristics":
          [%s]
',
          paste(sapply(self$`characteristics`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`experimentalFactorCategory`)) {
          sprintf(
          '"experimentalFactorCategory":
          %s
          ',
          jsonlite::toJSON(self$`experimentalFactorCategory`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`measurement`)) {
          sprintf(
          '"measurement":
          %s
          ',
          jsonlite::toJSON(self$`measurement`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`fvValue`)) {
          sprintf(
          '"fvValue":
            "%s"
                    ',
          self$`fvValue`
          )
        },
        if (!is.null(self$`fvSummary`)) {
          sprintf(
          '"fvSummary":
            "%s"
                    ',
          self$`fvSummary`
          )
        },
        if (!is.null(self$`experimentalFactorId`)) {
          sprintf(
          '"experimentalFactorId":
            %d
                    ',
          self$`experimentalFactorId`
          )
        },
        if (!is.null(self$`baseline`)) {
          sprintf(
          '"baseline":
            %s
                    ',
          tolower(self$`baseline`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of FactorValueBasicValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of FactorValueBasicValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of FactorValueBasicValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`characteristics` <- ApiClient$new()$deserializeObj(this_object$`characteristics`, "array[CharacteristicBasicValueObject]", loadNamespace("gemma.R"))
      self$`experimentalFactorCategory` <- CharacteristicBasicValueObject$new()$fromJSON(jsonlite::toJSON(this_object$experimentalFactorCategory, auto_unbox = TRUE, digits = NA))
      self$`measurement` <- MeasurementValueObject$new()$fromJSON(jsonlite::toJSON(this_object$measurement, auto_unbox = TRUE, digits = NA))
      self$`fvValue` <- this_object$`fvValue`
      self$`fvSummary` <- this_object$`fvSummary`
      self$`experimentalFactorId` <- this_object$`experimentalFactorId`
      self$`baseline` <- this_object$`baseline`
      self
    },
    #' Validate JSON input with respect to FactorValueBasicValueObject
    #'
    #' @description
    #' Validate JSON input with respect to FactorValueBasicValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of FactorValueBasicValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
FactorValueBasicValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
FactorValueBasicValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
FactorValueBasicValueObject$lock()


#' Create a new FactorValueValueObject
#'
#' @description
#' FactorValueValueObject Class
#'
#' @docType class
#' @title FactorValueValueObject
#' @description FactorValueValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field category  character optional
#' @field categoryUri  character optional
#' @field description  character optional
#' @field value  character optional
#' @field valueUri  character optional
#' @field charId  integer optional
#' @field factorId  integer optional
#' @field isBaseline  character optional
#' @field measurement  character optional
#' @field factorValue  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
FactorValueValueObject <- R6::R6Class(
  "FactorValueValueObject",
  public = list(
    `id` = NULL,
    `category` = NULL,
    `categoryUri` = NULL,
    `description` = NULL,
    `value` = NULL,
    `valueUri` = NULL,
    `charId` = NULL,
    `factorId` = NULL,
    `isBaseline` = NULL,
    `measurement` = NULL,
    `factorValue` = NULL,
    #' Initialize a new FactorValueValueObject class.
    #'
    #' @description
    #' Initialize a new FactorValueValueObject class.
    #'
    #' @param id id
    #' @param category category
    #' @param categoryUri categoryUri
    #' @param description description
    #' @param value value
    #' @param valueUri valueUri
    #' @param charId charId
    #' @param factorId factorId
    #' @param isBaseline isBaseline
    #' @param measurement measurement
    #' @param factorValue factorValue
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `category` = NULL, `categoryUri` = NULL, `description` = NULL, `value` = NULL, `valueUri` = NULL, `charId` = NULL, `factorId` = NULL, `isBaseline` = NULL, `measurement` = NULL, `factorValue` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`category`)) {
        stopifnot(is.character(`category`), length(`category`) == 1)
        self$`category` <- `category`
      }
      if (!is.null(`categoryUri`)) {
        stopifnot(is.character(`categoryUri`), length(`categoryUri`) == 1)
        self$`categoryUri` <- `categoryUri`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
      if (!is.null(`valueUri`)) {
        stopifnot(is.character(`valueUri`), length(`valueUri`) == 1)
        self$`valueUri` <- `valueUri`
      }
      if (!is.null(`charId`)) {
        stopifnot(is.numeric(`charId`), length(`charId`) == 1)
        self$`charId` <- `charId`
      }
      if (!is.null(`factorId`)) {
        stopifnot(is.numeric(`factorId`), length(`factorId`) == 1)
        self$`factorId` <- `factorId`
      }
      if (!is.null(`isBaseline`)) {
        stopifnot(is.logical(`isBaseline`), length(`isBaseline`) == 1)
        self$`isBaseline` <- `isBaseline`
      }
      if (!is.null(`measurement`)) {
        stopifnot(is.logical(`measurement`), length(`measurement`) == 1)
        self$`measurement` <- `measurement`
      }
      if (!is.null(`factorValue`)) {
        stopifnot(is.character(`factorValue`), length(`factorValue`) == 1)
        self$`factorValue` <- `factorValue`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return FactorValueValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      FactorValueValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        FactorValueValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`category`)) {
        FactorValueValueObjectObject[["category"]] <-
          self$`category`
      }
      if (!is.null(self$`categoryUri`)) {
        FactorValueValueObjectObject[["categoryUri"]] <-
          self$`categoryUri`
      }
      if (!is.null(self$`description`)) {
        FactorValueValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`value`)) {
        FactorValueValueObjectObject[["value"]] <-
          self$`value`
      }
      if (!is.null(self$`valueUri`)) {
        FactorValueValueObjectObject[["valueUri"]] <-
          self$`valueUri`
      }
      if (!is.null(self$`charId`)) {
        FactorValueValueObjectObject[["charId"]] <-
          self$`charId`
      }
      if (!is.null(self$`factorId`)) {
        FactorValueValueObjectObject[["factorId"]] <-
          self$`factorId`
      }
      if (!is.null(self$`isBaseline`)) {
        FactorValueValueObjectObject[["isBaseline"]] <-
          self$`isBaseline`
      }
      if (!is.null(self$`measurement`)) {
        FactorValueValueObjectObject[["measurement"]] <-
          self$`measurement`
      }
      if (!is.null(self$`factorValue`)) {
        FactorValueValueObjectObject[["factorValue"]] <-
          self$`factorValue`
      }
      FactorValueValueObjectObject
    },
    #' Deserialize JSON string into an instance of FactorValueValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of FactorValueValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of FactorValueValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`category`)) {
        self$`category` <- this_object$`category`
      }
      if (!is.null(this_object$`categoryUri`)) {
        self$`categoryUri` <- this_object$`categoryUri`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      if (!is.null(this_object$`valueUri`)) {
        self$`valueUri` <- this_object$`valueUri`
      }
      if (!is.null(this_object$`charId`)) {
        self$`charId` <- this_object$`charId`
      }
      if (!is.null(this_object$`factorId`)) {
        self$`factorId` <- this_object$`factorId`
      }
      if (!is.null(this_object$`isBaseline`)) {
        self$`isBaseline` <- this_object$`isBaseline`
      }
      if (!is.null(this_object$`measurement`)) {
        self$`measurement` <- this_object$`measurement`
      }
      if (!is.null(this_object$`factorValue`)) {
        self$`factorValue` <- this_object$`factorValue`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return FactorValueValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`category`)) {
          sprintf(
          '"category":
            "%s"
                    ',
          self$`category`
          )
        },
        if (!is.null(self$`categoryUri`)) {
          sprintf(
          '"categoryUri":
            "%s"
                    ',
          self$`categoryUri`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        },
        if (!is.null(self$`valueUri`)) {
          sprintf(
          '"valueUri":
            "%s"
                    ',
          self$`valueUri`
          )
        },
        if (!is.null(self$`charId`)) {
          sprintf(
          '"charId":
            %d
                    ',
          self$`charId`
          )
        },
        if (!is.null(self$`factorId`)) {
          sprintf(
          '"factorId":
            %d
                    ',
          self$`factorId`
          )
        },
        if (!is.null(self$`isBaseline`)) {
          sprintf(
          '"isBaseline":
            %s
                    ',
          tolower(self$`isBaseline`)
          )
        },
        if (!is.null(self$`measurement`)) {
          sprintf(
          '"measurement":
            %s
                    ',
          tolower(self$`measurement`)
          )
        },
        if (!is.null(self$`factorValue`)) {
          sprintf(
          '"factorValue":
            "%s"
                    ',
          self$`factorValue`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of FactorValueValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of FactorValueValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of FactorValueValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`category` <- this_object$`category`
      self$`categoryUri` <- this_object$`categoryUri`
      self$`description` <- this_object$`description`
      self$`value` <- this_object$`value`
      self$`valueUri` <- this_object$`valueUri`
      self$`charId` <- this_object$`charId`
      self$`factorId` <- this_object$`factorId`
      self$`isBaseline` <- this_object$`isBaseline`
      self$`measurement` <- this_object$`measurement`
      self$`factorValue` <- this_object$`factorValue`
      self
    },
    #' Validate JSON input with respect to FactorValueValueObject
    #'
    #' @description
    #' Validate JSON input with respect to FactorValueValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of FactorValueValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
FactorValueValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
FactorValueValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
FactorValueValueObject$lock()


#' Create a new GeeqValueObject
#'
#' @description
#' GeeqValueObject Class
#'
#' @docType class
#' @title GeeqValueObject
#' @description GeeqValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field publicQualityScore  numeric optional
#' @field publicSuitabilityScore  numeric optional
#' @field getsScorePublication  numeric optional
#' @field getsScorePlatformAmount  numeric optional
#' @field getsScorePlatformsTechMulti  numeric optional
#' @field getsScoreAvgPlatformPopularity  numeric optional
#' @field getsScoreAvgPlatformSize  numeric optional
#' @field getsScoreSampleSize  numeric optional
#' @field getsScoreRawData  numeric optional
#' @field getsScoreMissingValues  numeric optional
#' @field getqScoreOutliers  numeric optional
#' @field getqScoreSampleMeanCorrelation  numeric optional
#' @field getqScoreSampleMedianCorrelation  numeric optional
#' @field getqScoreSampleCorrelationVariance  numeric optional
#' @field getqScorePlatformsTech  numeric optional
#' @field getqScoreReplicates  numeric optional
#' @field getqScoreBatchInfo  numeric optional
#' @field getqScorePublicBatchEffect  numeric optional
#' @field getqScorePublicBatchConfound  numeric optional
#' @field noVectors  character optional
#' @field corrMatIssues  character optional
#' @field replicatesIssues  character optional
#' @field batchCorrected  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeeqValueObject <- R6::R6Class(
  "GeeqValueObject",
  public = list(
    `id` = NULL,
    `publicQualityScore` = NULL,
    `publicSuitabilityScore` = NULL,
    `getsScorePublication` = NULL,
    `getsScorePlatformAmount` = NULL,
    `getsScorePlatformsTechMulti` = NULL,
    `getsScoreAvgPlatformPopularity` = NULL,
    `getsScoreAvgPlatformSize` = NULL,
    `getsScoreSampleSize` = NULL,
    `getsScoreRawData` = NULL,
    `getsScoreMissingValues` = NULL,
    `getqScoreOutliers` = NULL,
    `getqScoreSampleMeanCorrelation` = NULL,
    `getqScoreSampleMedianCorrelation` = NULL,
    `getqScoreSampleCorrelationVariance` = NULL,
    `getqScorePlatformsTech` = NULL,
    `getqScoreReplicates` = NULL,
    `getqScoreBatchInfo` = NULL,
    `getqScorePublicBatchEffect` = NULL,
    `getqScorePublicBatchConfound` = NULL,
    `noVectors` = NULL,
    `corrMatIssues` = NULL,
    `replicatesIssues` = NULL,
    `batchCorrected` = NULL,
    #' Initialize a new GeeqValueObject class.
    #'
    #' @description
    #' Initialize a new GeeqValueObject class.
    #'
    #' @param id id
    #' @param publicQualityScore publicQualityScore
    #' @param publicSuitabilityScore publicSuitabilityScore
    #' @param getsScorePublication getsScorePublication
    #' @param getsScorePlatformAmount getsScorePlatformAmount
    #' @param getsScorePlatformsTechMulti getsScorePlatformsTechMulti
    #' @param getsScoreAvgPlatformPopularity getsScoreAvgPlatformPopularity
    #' @param getsScoreAvgPlatformSize getsScoreAvgPlatformSize
    #' @param getsScoreSampleSize getsScoreSampleSize
    #' @param getsScoreRawData getsScoreRawData
    #' @param getsScoreMissingValues getsScoreMissingValues
    #' @param getqScoreOutliers getqScoreOutliers
    #' @param getqScoreSampleMeanCorrelation getqScoreSampleMeanCorrelation
    #' @param getqScoreSampleMedianCorrelation getqScoreSampleMedianCorrelation
    #' @param getqScoreSampleCorrelationVariance getqScoreSampleCorrelationVariance
    #' @param getqScorePlatformsTech getqScorePlatformsTech
    #' @param getqScoreReplicates getqScoreReplicates
    #' @param getqScoreBatchInfo getqScoreBatchInfo
    #' @param getqScorePublicBatchEffect getqScorePublicBatchEffect
    #' @param getqScorePublicBatchConfound getqScorePublicBatchConfound
    #' @param noVectors noVectors
    #' @param corrMatIssues corrMatIssues
    #' @param replicatesIssues replicatesIssues
    #' @param batchCorrected batchCorrected
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `publicQualityScore` = NULL, `publicSuitabilityScore` = NULL, `getsScorePublication` = NULL, `getsScorePlatformAmount` = NULL, `getsScorePlatformsTechMulti` = NULL, `getsScoreAvgPlatformPopularity` = NULL, `getsScoreAvgPlatformSize` = NULL, `getsScoreSampleSize` = NULL, `getsScoreRawData` = NULL, `getsScoreMissingValues` = NULL, `getqScoreOutliers` = NULL, `getqScoreSampleMeanCorrelation` = NULL, `getqScoreSampleMedianCorrelation` = NULL, `getqScoreSampleCorrelationVariance` = NULL, `getqScorePlatformsTech` = NULL, `getqScoreReplicates` = NULL, `getqScoreBatchInfo` = NULL, `getqScorePublicBatchEffect` = NULL, `getqScorePublicBatchConfound` = NULL, `noVectors` = NULL, `corrMatIssues` = NULL, `replicatesIssues` = NULL, `batchCorrected` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`publicQualityScore`)) {
        stopifnot(is.numeric(`publicQualityScore`), length(`publicQualityScore`) == 1)
        self$`publicQualityScore` <- `publicQualityScore`
      }
      if (!is.null(`publicSuitabilityScore`)) {
        stopifnot(is.numeric(`publicSuitabilityScore`), length(`publicSuitabilityScore`) == 1)
        self$`publicSuitabilityScore` <- `publicSuitabilityScore`
      }
      if (!is.null(`getsScorePublication`)) {
        stopifnot(is.numeric(`getsScorePublication`), length(`getsScorePublication`) == 1)
        self$`getsScorePublication` <- `getsScorePublication`
      }
      if (!is.null(`getsScorePlatformAmount`)) {
        stopifnot(is.numeric(`getsScorePlatformAmount`), length(`getsScorePlatformAmount`) == 1)
        self$`getsScorePlatformAmount` <- `getsScorePlatformAmount`
      }
      if (!is.null(`getsScorePlatformsTechMulti`)) {
        stopifnot(is.numeric(`getsScorePlatformsTechMulti`), length(`getsScorePlatformsTechMulti`) == 1)
        self$`getsScorePlatformsTechMulti` <- `getsScorePlatformsTechMulti`
      }
      if (!is.null(`getsScoreAvgPlatformPopularity`)) {
        stopifnot(is.numeric(`getsScoreAvgPlatformPopularity`), length(`getsScoreAvgPlatformPopularity`) == 1)
        self$`getsScoreAvgPlatformPopularity` <- `getsScoreAvgPlatformPopularity`
      }
      if (!is.null(`getsScoreAvgPlatformSize`)) {
        stopifnot(is.numeric(`getsScoreAvgPlatformSize`), length(`getsScoreAvgPlatformSize`) == 1)
        self$`getsScoreAvgPlatformSize` <- `getsScoreAvgPlatformSize`
      }
      if (!is.null(`getsScoreSampleSize`)) {
        stopifnot(is.numeric(`getsScoreSampleSize`), length(`getsScoreSampleSize`) == 1)
        self$`getsScoreSampleSize` <- `getsScoreSampleSize`
      }
      if (!is.null(`getsScoreRawData`)) {
        stopifnot(is.numeric(`getsScoreRawData`), length(`getsScoreRawData`) == 1)
        self$`getsScoreRawData` <- `getsScoreRawData`
      }
      if (!is.null(`getsScoreMissingValues`)) {
        stopifnot(is.numeric(`getsScoreMissingValues`), length(`getsScoreMissingValues`) == 1)
        self$`getsScoreMissingValues` <- `getsScoreMissingValues`
      }
      if (!is.null(`getqScoreOutliers`)) {
        stopifnot(is.numeric(`getqScoreOutliers`), length(`getqScoreOutliers`) == 1)
        self$`getqScoreOutliers` <- `getqScoreOutliers`
      }
      if (!is.null(`getqScoreSampleMeanCorrelation`)) {
        stopifnot(is.numeric(`getqScoreSampleMeanCorrelation`), length(`getqScoreSampleMeanCorrelation`) == 1)
        self$`getqScoreSampleMeanCorrelation` <- `getqScoreSampleMeanCorrelation`
      }
      if (!is.null(`getqScoreSampleMedianCorrelation`)) {
        stopifnot(is.numeric(`getqScoreSampleMedianCorrelation`), length(`getqScoreSampleMedianCorrelation`) == 1)
        self$`getqScoreSampleMedianCorrelation` <- `getqScoreSampleMedianCorrelation`
      }
      if (!is.null(`getqScoreSampleCorrelationVariance`)) {
        stopifnot(is.numeric(`getqScoreSampleCorrelationVariance`), length(`getqScoreSampleCorrelationVariance`) == 1)
        self$`getqScoreSampleCorrelationVariance` <- `getqScoreSampleCorrelationVariance`
      }
      if (!is.null(`getqScorePlatformsTech`)) {
        stopifnot(is.numeric(`getqScorePlatformsTech`), length(`getqScorePlatformsTech`) == 1)
        self$`getqScorePlatformsTech` <- `getqScorePlatformsTech`
      }
      if (!is.null(`getqScoreReplicates`)) {
        stopifnot(is.numeric(`getqScoreReplicates`), length(`getqScoreReplicates`) == 1)
        self$`getqScoreReplicates` <- `getqScoreReplicates`
      }
      if (!is.null(`getqScoreBatchInfo`)) {
        stopifnot(is.numeric(`getqScoreBatchInfo`), length(`getqScoreBatchInfo`) == 1)
        self$`getqScoreBatchInfo` <- `getqScoreBatchInfo`
      }
      if (!is.null(`getqScorePublicBatchEffect`)) {
        stopifnot(is.numeric(`getqScorePublicBatchEffect`), length(`getqScorePublicBatchEffect`) == 1)
        self$`getqScorePublicBatchEffect` <- `getqScorePublicBatchEffect`
      }
      if (!is.null(`getqScorePublicBatchConfound`)) {
        stopifnot(is.numeric(`getqScorePublicBatchConfound`), length(`getqScorePublicBatchConfound`) == 1)
        self$`getqScorePublicBatchConfound` <- `getqScorePublicBatchConfound`
      }
      if (!is.null(`noVectors`)) {
        stopifnot(is.logical(`noVectors`), length(`noVectors`) == 1)
        self$`noVectors` <- `noVectors`
      }
      if (!is.null(`corrMatIssues`)) {
        self$`corrMatIssues` <- `corrMatIssues`
      }
      if (!is.null(`replicatesIssues`)) {
        self$`replicatesIssues` <- `replicatesIssues`
      }
      if (!is.null(`batchCorrected`)) {
        stopifnot(is.logical(`batchCorrected`), length(`batchCorrected`) == 1)
        self$`batchCorrected` <- `batchCorrected`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeeqValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      GeeqValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        GeeqValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`publicQualityScore`)) {
        GeeqValueObjectObject[["publicQualityScore"]] <-
          self$`publicQualityScore`
      }
      if (!is.null(self$`publicSuitabilityScore`)) {
        GeeqValueObjectObject[["publicSuitabilityScore"]] <-
          self$`publicSuitabilityScore`
      }
      if (!is.null(self$`getsScorePublication`)) {
        GeeqValueObjectObject[["getsScorePublication"]] <-
          self$`getsScorePublication`
      }
      if (!is.null(self$`getsScorePlatformAmount`)) {
        GeeqValueObjectObject[["getsScorePlatformAmount"]] <-
          self$`getsScorePlatformAmount`
      }
      if (!is.null(self$`getsScorePlatformsTechMulti`)) {
        GeeqValueObjectObject[["getsScorePlatformsTechMulti"]] <-
          self$`getsScorePlatformsTechMulti`
      }
      if (!is.null(self$`getsScoreAvgPlatformPopularity`)) {
        GeeqValueObjectObject[["getsScoreAvgPlatformPopularity"]] <-
          self$`getsScoreAvgPlatformPopularity`
      }
      if (!is.null(self$`getsScoreAvgPlatformSize`)) {
        GeeqValueObjectObject[["getsScoreAvgPlatformSize"]] <-
          self$`getsScoreAvgPlatformSize`
      }
      if (!is.null(self$`getsScoreSampleSize`)) {
        GeeqValueObjectObject[["getsScoreSampleSize"]] <-
          self$`getsScoreSampleSize`
      }
      if (!is.null(self$`getsScoreRawData`)) {
        GeeqValueObjectObject[["getsScoreRawData"]] <-
          self$`getsScoreRawData`
      }
      if (!is.null(self$`getsScoreMissingValues`)) {
        GeeqValueObjectObject[["getsScoreMissingValues"]] <-
          self$`getsScoreMissingValues`
      }
      if (!is.null(self$`getqScoreOutliers`)) {
        GeeqValueObjectObject[["getqScoreOutliers"]] <-
          self$`getqScoreOutliers`
      }
      if (!is.null(self$`getqScoreSampleMeanCorrelation`)) {
        GeeqValueObjectObject[["getqScoreSampleMeanCorrelation"]] <-
          self$`getqScoreSampleMeanCorrelation`
      }
      if (!is.null(self$`getqScoreSampleMedianCorrelation`)) {
        GeeqValueObjectObject[["getqScoreSampleMedianCorrelation"]] <-
          self$`getqScoreSampleMedianCorrelation`
      }
      if (!is.null(self$`getqScoreSampleCorrelationVariance`)) {
        GeeqValueObjectObject[["getqScoreSampleCorrelationVariance"]] <-
          self$`getqScoreSampleCorrelationVariance`
      }
      if (!is.null(self$`getqScorePlatformsTech`)) {
        GeeqValueObjectObject[["getqScorePlatformsTech"]] <-
          self$`getqScorePlatformsTech`
      }
      if (!is.null(self$`getqScoreReplicates`)) {
        GeeqValueObjectObject[["getqScoreReplicates"]] <-
          self$`getqScoreReplicates`
      }
      if (!is.null(self$`getqScoreBatchInfo`)) {
        GeeqValueObjectObject[["getqScoreBatchInfo"]] <-
          self$`getqScoreBatchInfo`
      }
      if (!is.null(self$`getqScorePublicBatchEffect`)) {
        GeeqValueObjectObject[["getqScorePublicBatchEffect"]] <-
          self$`getqScorePublicBatchEffect`
      }
      if (!is.null(self$`getqScorePublicBatchConfound`)) {
        GeeqValueObjectObject[["getqScorePublicBatchConfound"]] <-
          self$`getqScorePublicBatchConfound`
      }
      if (!is.null(self$`noVectors`)) {
        GeeqValueObjectObject[["noVectors"]] <-
          self$`noVectors`
      }
      if (!is.null(self$`corrMatIssues`)) {
        GeeqValueObjectObject[["corrMatIssues"]] <-
          self$`corrMatIssues`
      }
      if (!is.null(self$`replicatesIssues`)) {
        GeeqValueObjectObject[["replicatesIssues"]] <-
          self$`replicatesIssues`
      }
      if (!is.null(self$`batchCorrected`)) {
        GeeqValueObjectObject[["batchCorrected"]] <-
          self$`batchCorrected`
      }
      GeeqValueObjectObject
    },
    #' Deserialize JSON string into an instance of GeeqValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeeqValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeeqValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`publicQualityScore`)) {
        self$`publicQualityScore` <- this_object$`publicQualityScore`
      }
      if (!is.null(this_object$`publicSuitabilityScore`)) {
        self$`publicSuitabilityScore` <- this_object$`publicSuitabilityScore`
      }
      if (!is.null(this_object$`getsScorePublication`)) {
        self$`getsScorePublication` <- this_object$`getsScorePublication`
      }
      if (!is.null(this_object$`getsScorePlatformAmount`)) {
        self$`getsScorePlatformAmount` <- this_object$`getsScorePlatformAmount`
      }
      if (!is.null(this_object$`getsScorePlatformsTechMulti`)) {
        self$`getsScorePlatformsTechMulti` <- this_object$`getsScorePlatformsTechMulti`
      }
      if (!is.null(this_object$`getsScoreAvgPlatformPopularity`)) {
        self$`getsScoreAvgPlatformPopularity` <- this_object$`getsScoreAvgPlatformPopularity`
      }
      if (!is.null(this_object$`getsScoreAvgPlatformSize`)) {
        self$`getsScoreAvgPlatformSize` <- this_object$`getsScoreAvgPlatformSize`
      }
      if (!is.null(this_object$`getsScoreSampleSize`)) {
        self$`getsScoreSampleSize` <- this_object$`getsScoreSampleSize`
      }
      if (!is.null(this_object$`getsScoreRawData`)) {
        self$`getsScoreRawData` <- this_object$`getsScoreRawData`
      }
      if (!is.null(this_object$`getsScoreMissingValues`)) {
        self$`getsScoreMissingValues` <- this_object$`getsScoreMissingValues`
      }
      if (!is.null(this_object$`getqScoreOutliers`)) {
        self$`getqScoreOutliers` <- this_object$`getqScoreOutliers`
      }
      if (!is.null(this_object$`getqScoreSampleMeanCorrelation`)) {
        self$`getqScoreSampleMeanCorrelation` <- this_object$`getqScoreSampleMeanCorrelation`
      }
      if (!is.null(this_object$`getqScoreSampleMedianCorrelation`)) {
        self$`getqScoreSampleMedianCorrelation` <- this_object$`getqScoreSampleMedianCorrelation`
      }
      if (!is.null(this_object$`getqScoreSampleCorrelationVariance`)) {
        self$`getqScoreSampleCorrelationVariance` <- this_object$`getqScoreSampleCorrelationVariance`
      }
      if (!is.null(this_object$`getqScorePlatformsTech`)) {
        self$`getqScorePlatformsTech` <- this_object$`getqScorePlatformsTech`
      }
      if (!is.null(this_object$`getqScoreReplicates`)) {
        self$`getqScoreReplicates` <- this_object$`getqScoreReplicates`
      }
      if (!is.null(this_object$`getqScoreBatchInfo`)) {
        self$`getqScoreBatchInfo` <- this_object$`getqScoreBatchInfo`
      }
      if (!is.null(this_object$`getqScorePublicBatchEffect`)) {
        self$`getqScorePublicBatchEffect` <- this_object$`getqScorePublicBatchEffect`
      }
      if (!is.null(this_object$`getqScorePublicBatchConfound`)) {
        self$`getqScorePublicBatchConfound` <- this_object$`getqScorePublicBatchConfound`
      }
      if (!is.null(this_object$`noVectors`)) {
        self$`noVectors` <- this_object$`noVectors`
      }
      if (!is.null(this_object$`corrMatIssues`)) {
        self$`corrMatIssues` <- this_object$`corrMatIssues`
      }
      if (!is.null(this_object$`replicatesIssues`)) {
        self$`replicatesIssues` <- this_object$`replicatesIssues`
      }
      if (!is.null(this_object$`batchCorrected`)) {
        self$`batchCorrected` <- this_object$`batchCorrected`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeeqValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`publicQualityScore`)) {
          sprintf(
          '"publicQualityScore":
            %d
                    ',
          self$`publicQualityScore`
          )
        },
        if (!is.null(self$`publicSuitabilityScore`)) {
          sprintf(
          '"publicSuitabilityScore":
            %d
                    ',
          self$`publicSuitabilityScore`
          )
        },
        if (!is.null(self$`getsScorePublication`)) {
          sprintf(
          '"getsScorePublication":
            %d
                    ',
          self$`getsScorePublication`
          )
        },
        if (!is.null(self$`getsScorePlatformAmount`)) {
          sprintf(
          '"getsScorePlatformAmount":
            %d
                    ',
          self$`getsScorePlatformAmount`
          )
        },
        if (!is.null(self$`getsScorePlatformsTechMulti`)) {
          sprintf(
          '"getsScorePlatformsTechMulti":
            %d
                    ',
          self$`getsScorePlatformsTechMulti`
          )
        },
        if (!is.null(self$`getsScoreAvgPlatformPopularity`)) {
          sprintf(
          '"getsScoreAvgPlatformPopularity":
            %d
                    ',
          self$`getsScoreAvgPlatformPopularity`
          )
        },
        if (!is.null(self$`getsScoreAvgPlatformSize`)) {
          sprintf(
          '"getsScoreAvgPlatformSize":
            %d
                    ',
          self$`getsScoreAvgPlatformSize`
          )
        },
        if (!is.null(self$`getsScoreSampleSize`)) {
          sprintf(
          '"getsScoreSampleSize":
            %d
                    ',
          self$`getsScoreSampleSize`
          )
        },
        if (!is.null(self$`getsScoreRawData`)) {
          sprintf(
          '"getsScoreRawData":
            %d
                    ',
          self$`getsScoreRawData`
          )
        },
        if (!is.null(self$`getsScoreMissingValues`)) {
          sprintf(
          '"getsScoreMissingValues":
            %d
                    ',
          self$`getsScoreMissingValues`
          )
        },
        if (!is.null(self$`getqScoreOutliers`)) {
          sprintf(
          '"getqScoreOutliers":
            %d
                    ',
          self$`getqScoreOutliers`
          )
        },
        if (!is.null(self$`getqScoreSampleMeanCorrelation`)) {
          sprintf(
          '"getqScoreSampleMeanCorrelation":
            %d
                    ',
          self$`getqScoreSampleMeanCorrelation`
          )
        },
        if (!is.null(self$`getqScoreSampleMedianCorrelation`)) {
          sprintf(
          '"getqScoreSampleMedianCorrelation":
            %d
                    ',
          self$`getqScoreSampleMedianCorrelation`
          )
        },
        if (!is.null(self$`getqScoreSampleCorrelationVariance`)) {
          sprintf(
          '"getqScoreSampleCorrelationVariance":
            %d
                    ',
          self$`getqScoreSampleCorrelationVariance`
          )
        },
        if (!is.null(self$`getqScorePlatformsTech`)) {
          sprintf(
          '"getqScorePlatformsTech":
            %d
                    ',
          self$`getqScorePlatformsTech`
          )
        },
        if (!is.null(self$`getqScoreReplicates`)) {
          sprintf(
          '"getqScoreReplicates":
            %d
                    ',
          self$`getqScoreReplicates`
          )
        },
        if (!is.null(self$`getqScoreBatchInfo`)) {
          sprintf(
          '"getqScoreBatchInfo":
            %d
                    ',
          self$`getqScoreBatchInfo`
          )
        },
        if (!is.null(self$`getqScorePublicBatchEffect`)) {
          sprintf(
          '"getqScorePublicBatchEffect":
            %d
                    ',
          self$`getqScorePublicBatchEffect`
          )
        },
        if (!is.null(self$`getqScorePublicBatchConfound`)) {
          sprintf(
          '"getqScorePublicBatchConfound":
            %d
                    ',
          self$`getqScorePublicBatchConfound`
          )
        },
        if (!is.null(self$`noVectors`)) {
          sprintf(
          '"noVectors":
            %s
                    ',
          tolower(self$`noVectors`)
          )
        },
        if (!is.null(self$`corrMatIssues`)) {
          sprintf(
          '"corrMatIssues":
            "%s"
                    ',
          self$`corrMatIssues`
          )
        },
        if (!is.null(self$`replicatesIssues`)) {
          sprintf(
          '"replicatesIssues":
            "%s"
                    ',
          self$`replicatesIssues`
          )
        },
        if (!is.null(self$`batchCorrected`)) {
          sprintf(
          '"batchCorrected":
            %s
                    ',
          tolower(self$`batchCorrected`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeeqValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeeqValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeeqValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`publicQualityScore` <- this_object$`publicQualityScore`
      self$`publicSuitabilityScore` <- this_object$`publicSuitabilityScore`
      self$`getsScorePublication` <- this_object$`getsScorePublication`
      self$`getsScorePlatformAmount` <- this_object$`getsScorePlatformAmount`
      self$`getsScorePlatformsTechMulti` <- this_object$`getsScorePlatformsTechMulti`
      self$`getsScoreAvgPlatformPopularity` <- this_object$`getsScoreAvgPlatformPopularity`
      self$`getsScoreAvgPlatformSize` <- this_object$`getsScoreAvgPlatformSize`
      self$`getsScoreSampleSize` <- this_object$`getsScoreSampleSize`
      self$`getsScoreRawData` <- this_object$`getsScoreRawData`
      self$`getsScoreMissingValues` <- this_object$`getsScoreMissingValues`
      self$`getqScoreOutliers` <- this_object$`getqScoreOutliers`
      self$`getqScoreSampleMeanCorrelation` <- this_object$`getqScoreSampleMeanCorrelation`
      self$`getqScoreSampleMedianCorrelation` <- this_object$`getqScoreSampleMedianCorrelation`
      self$`getqScoreSampleCorrelationVariance` <- this_object$`getqScoreSampleCorrelationVariance`
      self$`getqScorePlatformsTech` <- this_object$`getqScorePlatformsTech`
      self$`getqScoreReplicates` <- this_object$`getqScoreReplicates`
      self$`getqScoreBatchInfo` <- this_object$`getqScoreBatchInfo`
      self$`getqScorePublicBatchEffect` <- this_object$`getqScorePublicBatchEffect`
      self$`getqScorePublicBatchConfound` <- this_object$`getqScorePublicBatchConfound`
      self$`noVectors` <- this_object$`noVectors`
      self$`corrMatIssues` <- this_object$`corrMatIssues`
      self$`replicatesIssues` <- this_object$`replicatesIssues`
      self$`batchCorrected` <- this_object$`batchCorrected`
      self
    },
    #' Validate JSON input with respect to GeeqValueObject
    #'
    #' @description
    #' Validate JSON input with respect to GeeqValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeeqValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeeqValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeeqValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeeqValueObject$lock()


#' Create a new Gene
#'
#' @description
#' Gene Class
#'
#' @docType class
#' @title Gene
#' @description Gene Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field previousNcbiId  character optional
#' @field physicalLocation  \link{PhysicalLocation} optional
#' @field officialSymbol  character optional
#' @field officialName  character optional
#' @field ncbiGeneId  integer optional
#' @field ensemblId  character optional
#' @field products  list(\link{GeneProduct}) optional
#' @field aliases  list(\link{GeneAlias}) optional
#' @field taxon  \link{Taxon} optional
#' @field accessions  list(\link{DatabaseEntry}) optional
#' @field multifunctionality  \link{Multifunctionality} optional
#' @field phenotypeAssociations  list(\link{PhenotypeAssociation}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Gene <- R6::R6Class(
  "Gene",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `previousNcbiId` = NULL,
    `physicalLocation` = NULL,
    `officialSymbol` = NULL,
    `officialName` = NULL,
    `ncbiGeneId` = NULL,
    `ensemblId` = NULL,
    `products` = NULL,
    `aliases` = NULL,
    `taxon` = NULL,
    `accessions` = NULL,
    `multifunctionality` = NULL,
    `phenotypeAssociations` = NULL,
    #' Initialize a new Gene class.
    #'
    #' @description
    #' Initialize a new Gene class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param previousNcbiId previousNcbiId
    #' @param physicalLocation physicalLocation
    #' @param officialSymbol officialSymbol
    #' @param officialName officialName
    #' @param ncbiGeneId ncbiGeneId
    #' @param ensemblId ensemblId
    #' @param products products
    #' @param aliases aliases
    #' @param taxon taxon
    #' @param accessions accessions
    #' @param multifunctionality multifunctionality
    #' @param phenotypeAssociations phenotypeAssociations
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `previousNcbiId` = NULL, `physicalLocation` = NULL, `officialSymbol` = NULL, `officialName` = NULL, `ncbiGeneId` = NULL, `ensemblId` = NULL, `products` = NULL, `aliases` = NULL, `taxon` = NULL, `accessions` = NULL, `multifunctionality` = NULL, `phenotypeAssociations` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`previousNcbiId`)) {
        stopifnot(is.character(`previousNcbiId`), length(`previousNcbiId`) == 1)
        self$`previousNcbiId` <- `previousNcbiId`
      }
      if (!is.null(`physicalLocation`)) {
        stopifnot(R6::is.R6(`physicalLocation`))
        self$`physicalLocation` <- `physicalLocation`
      }
      if (!is.null(`officialSymbol`)) {
        stopifnot(is.character(`officialSymbol`), length(`officialSymbol`) == 1)
        self$`officialSymbol` <- `officialSymbol`
      }
      if (!is.null(`officialName`)) {
        stopifnot(is.character(`officialName`), length(`officialName`) == 1)
        self$`officialName` <- `officialName`
      }
      if (!is.null(`ncbiGeneId`)) {
        stopifnot(is.numeric(`ncbiGeneId`), length(`ncbiGeneId`) == 1)
        self$`ncbiGeneId` <- `ncbiGeneId`
      }
      if (!is.null(`ensemblId`)) {
        stopifnot(is.character(`ensemblId`), length(`ensemblId`) == 1)
        self$`ensemblId` <- `ensemblId`
      }
      if (!is.null(`products`)) {
        stopifnot(is.vector(`products`), length(`products`) != 0)
        sapply(`products`, function(x) stopifnot(R6::is.R6(x)))
        self$`products` <- `products`
      }
      if (!is.null(`aliases`)) {
        stopifnot(is.vector(`aliases`), length(`aliases`) != 0)
        sapply(`aliases`, function(x) stopifnot(R6::is.R6(x)))
        self$`aliases` <- `aliases`
      }
      if (!is.null(`taxon`)) {
        stopifnot(R6::is.R6(`taxon`))
        self$`taxon` <- `taxon`
      }
      if (!is.null(`accessions`)) {
        stopifnot(is.vector(`accessions`), length(`accessions`) != 0)
        sapply(`accessions`, function(x) stopifnot(R6::is.R6(x)))
        self$`accessions` <- `accessions`
      }
      if (!is.null(`multifunctionality`)) {
        stopifnot(R6::is.R6(`multifunctionality`))
        self$`multifunctionality` <- `multifunctionality`
      }
      if (!is.null(`phenotypeAssociations`)) {
        stopifnot(is.vector(`phenotypeAssociations`), length(`phenotypeAssociations`) != 0)
        sapply(`phenotypeAssociations`, function(x) stopifnot(R6::is.R6(x)))
        self$`phenotypeAssociations` <- `phenotypeAssociations`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Gene in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneObject <- list()
      if (!is.null(self$`name`)) {
        GeneObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        GeneObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        GeneObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`previousNcbiId`)) {
        GeneObject[["previousNcbiId"]] <-
          self$`previousNcbiId`
      }
      if (!is.null(self$`physicalLocation`)) {
        GeneObject[["physicalLocation"]] <-
          self$`physicalLocation`$toJSON()
      }
      if (!is.null(self$`officialSymbol`)) {
        GeneObject[["officialSymbol"]] <-
          self$`officialSymbol`
      }
      if (!is.null(self$`officialName`)) {
        GeneObject[["officialName"]] <-
          self$`officialName`
      }
      if (!is.null(self$`ncbiGeneId`)) {
        GeneObject[["ncbiGeneId"]] <-
          self$`ncbiGeneId`
      }
      if (!is.null(self$`ensemblId`)) {
        GeneObject[["ensemblId"]] <-
          self$`ensemblId`
      }
      if (!is.null(self$`products`)) {
        GeneObject[["products"]] <-
          lapply(self$`products`, function(x) x$toJSON())
      }
      if (!is.null(self$`aliases`)) {
        GeneObject[["aliases"]] <-
          lapply(self$`aliases`, function(x) x$toJSON())
      }
      if (!is.null(self$`taxon`)) {
        GeneObject[["taxon"]] <-
          self$`taxon`$toJSON()
      }
      if (!is.null(self$`accessions`)) {
        GeneObject[["accessions"]] <-
          lapply(self$`accessions`, function(x) x$toJSON())
      }
      if (!is.null(self$`multifunctionality`)) {
        GeneObject[["multifunctionality"]] <-
          self$`multifunctionality`$toJSON()
      }
      if (!is.null(self$`phenotypeAssociations`)) {
        GeneObject[["phenotypeAssociations"]] <-
          lapply(self$`phenotypeAssociations`, function(x) x$toJSON())
      }
      GeneObject
    },
    #' Deserialize JSON string into an instance of Gene
    #'
    #' @description
    #' Deserialize JSON string into an instance of Gene
    #'
    #' @param input_json the JSON input
    #' @return the instance of Gene
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`previousNcbiId`)) {
        self$`previousNcbiId` <- this_object$`previousNcbiId`
      }
      if (!is.null(this_object$`physicalLocation`)) {
        physicallocation_object <- PhysicalLocation$new()
        physicallocation_object$fromJSON(jsonlite::toJSON(this_object$physicalLocation, auto_unbox = TRUE, digits = NA))
        self$`physicalLocation` <- physicallocation_object
      }
      if (!is.null(this_object$`officialSymbol`)) {
        self$`officialSymbol` <- this_object$`officialSymbol`
      }
      if (!is.null(this_object$`officialName`)) {
        self$`officialName` <- this_object$`officialName`
      }
      if (!is.null(this_object$`ncbiGeneId`)) {
        self$`ncbiGeneId` <- this_object$`ncbiGeneId`
      }
      if (!is.null(this_object$`ensemblId`)) {
        self$`ensemblId` <- this_object$`ensemblId`
      }
      if (!is.null(this_object$`products`)) {
        self$`products` <- ApiClient$new()$deserializeObj(this_object$`products`, "set[GeneProduct]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`aliases`)) {
        self$`aliases` <- ApiClient$new()$deserializeObj(this_object$`aliases`, "set[GeneAlias]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`taxon`)) {
        taxon_object <- Taxon$new()
        taxon_object$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
        self$`taxon` <- taxon_object
      }
      if (!is.null(this_object$`accessions`)) {
        self$`accessions` <- ApiClient$new()$deserializeObj(this_object$`accessions`, "set[DatabaseEntry]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`multifunctionality`)) {
        multifunctionality_object <- Multifunctionality$new()
        multifunctionality_object$fromJSON(jsonlite::toJSON(this_object$multifunctionality, auto_unbox = TRUE, digits = NA))
        self$`multifunctionality` <- multifunctionality_object
      }
      if (!is.null(this_object$`phenotypeAssociations`)) {
        self$`phenotypeAssociations` <- ApiClient$new()$deserializeObj(this_object$`phenotypeAssociations`, "set[PhenotypeAssociation]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Gene in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`previousNcbiId`)) {
          sprintf(
          '"previousNcbiId":
            "%s"
                    ',
          self$`previousNcbiId`
          )
        },
        if (!is.null(self$`physicalLocation`)) {
          sprintf(
          '"physicalLocation":
          %s
          ',
          jsonlite::toJSON(self$`physicalLocation`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`officialSymbol`)) {
          sprintf(
          '"officialSymbol":
            "%s"
                    ',
          self$`officialSymbol`
          )
        },
        if (!is.null(self$`officialName`)) {
          sprintf(
          '"officialName":
            "%s"
                    ',
          self$`officialName`
          )
        },
        if (!is.null(self$`ncbiGeneId`)) {
          sprintf(
          '"ncbiGeneId":
            %d
                    ',
          self$`ncbiGeneId`
          )
        },
        if (!is.null(self$`ensemblId`)) {
          sprintf(
          '"ensemblId":
            "%s"
                    ',
          self$`ensemblId`
          )
        },
        if (!is.null(self$`products`)) {
          sprintf(
          '"products":
          [%s]
',
          paste(sapply(self$`products`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`aliases`)) {
          sprintf(
          '"aliases":
          [%s]
',
          paste(sapply(self$`aliases`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
          %s
          ',
          jsonlite::toJSON(self$`taxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`accessions`)) {
          sprintf(
          '"accessions":
          [%s]
',
          paste(sapply(self$`accessions`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`multifunctionality`)) {
          sprintf(
          '"multifunctionality":
          %s
          ',
          jsonlite::toJSON(self$`multifunctionality`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`phenotypeAssociations`)) {
          sprintf(
          '"phenotypeAssociations":
          [%s]
',
          paste(sapply(self$`phenotypeAssociations`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Gene
    #'
    #' @description
    #' Deserialize JSON string into an instance of Gene
    #'
    #' @param input_json the JSON input
    #' @return the instance of Gene
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`previousNcbiId` <- this_object$`previousNcbiId`
      self$`physicalLocation` <- PhysicalLocation$new()$fromJSON(jsonlite::toJSON(this_object$physicalLocation, auto_unbox = TRUE, digits = NA))
      self$`officialSymbol` <- this_object$`officialSymbol`
      self$`officialName` <- this_object$`officialName`
      self$`ncbiGeneId` <- this_object$`ncbiGeneId`
      self$`ensemblId` <- this_object$`ensemblId`
      self$`products` <- ApiClient$new()$deserializeObj(this_object$`products`, "set[GeneProduct]", loadNamespace("gemma.R"))
      self$`aliases` <- ApiClient$new()$deserializeObj(this_object$`aliases`, "set[GeneAlias]", loadNamespace("gemma.R"))
      self$`taxon` <- Taxon$new()$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
      self$`accessions` <- ApiClient$new()$deserializeObj(this_object$`accessions`, "set[DatabaseEntry]", loadNamespace("gemma.R"))
      self$`multifunctionality` <- Multifunctionality$new()$fromJSON(jsonlite::toJSON(this_object$multifunctionality, auto_unbox = TRUE, digits = NA))
      self$`phenotypeAssociations` <- ApiClient$new()$deserializeObj(this_object$`phenotypeAssociations`, "set[PhenotypeAssociation]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to Gene
    #'
    #' @description
    #' Validate JSON input with respect to Gene and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Gene
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {




      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()




      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Gene$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Gene$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Gene$lock()


#' Create a new GeneAlias
#'
#' @description
#' GeneAlias Class
#'
#' @docType class
#' @title GeneAlias
#' @description GeneAlias Class
#' @format An \code{R6Class} generator object
#' @field alias  character optional
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneAlias <- R6::R6Class(
  "GeneAlias",
  public = list(
    `alias` = NULL,
    `id` = NULL,
    #' Initialize a new GeneAlias class.
    #'
    #' @description
    #' Initialize a new GeneAlias class.
    #'
    #' @param alias alias
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `alias` = NULL, `id` = NULL, ...
    ) {
      if (!is.null(`alias`)) {
        stopifnot(is.character(`alias`), length(`alias`) == 1)
        self$`alias` <- `alias`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneAlias in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneAliasObject <- list()
      if (!is.null(self$`alias`)) {
        GeneAliasObject[["alias"]] <-
          self$`alias`
      }
      if (!is.null(self$`id`)) {
        GeneAliasObject[["id"]] <-
          self$`id`
      }
      GeneAliasObject
    },
    #' Deserialize JSON string into an instance of GeneAlias
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneAlias
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneAlias
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`alias`)) {
        self$`alias` <- this_object$`alias`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneAlias in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`alias`)) {
          sprintf(
          '"alias":
            "%s"
                    ',
          self$`alias`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneAlias
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneAlias
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneAlias
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`alias` <- this_object$`alias`
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to GeneAlias
    #'
    #' @description
    #' Validate JSON input with respect to GeneAlias and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneAlias
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneAlias$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneAlias$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneAlias$lock()


#' @docType class
#' @title GeneArg
#'
#' @description GeneArg Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneArg <- R6::R6Class(
  "GeneArg",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character"),
    #' Initialize a new GeneArg.
    #'
    #' @description
    #' Initialize a new GeneArg.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else {
        stop(paste("Failed to initialize GeneArg with oneOf schemas character. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of GeneArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneArg.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of GeneArg.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of GeneArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneArg.
    #'
    #' @param input The input JSON.
    #' @return An instance of GeneArg.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into GeneArg with oneOf schemas character.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into GeneArg with oneOf schemas character. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize GeneArg to JSON string.
    #'
    #' @description
    #' Serialize GeneArg to JSON string.
    #'
    #' @return JSON string representation of the GeneArg.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize GeneArg to JSON.
    #'
    #' @description
    #' Serialize GeneArg to JSON.
    #'
    #' @return JSON representation of the GeneArg.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to GeneArg.
    #'
    #' @description
    #' Validate the input JSON with respect to GeneArg and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneArg$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneArg$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneArg$lock()


#' Create a new GeneElementExpressionsValueObject
#'
#' @description
#' GeneElementExpressionsValueObject Class
#'
#' @docType class
#' @title GeneElementExpressionsValueObject
#' @description GeneElementExpressionsValueObject Class
#' @format An \code{R6Class} generator object
#' @field geneOfficialSymbol  character optional
#' @field geneNcbiId  integer optional
#' @field vectors  list(\link{VectorElementValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneElementExpressionsValueObject <- R6::R6Class(
  "GeneElementExpressionsValueObject",
  public = list(
    `geneOfficialSymbol` = NULL,
    `geneNcbiId` = NULL,
    `vectors` = NULL,
    #' Initialize a new GeneElementExpressionsValueObject class.
    #'
    #' @description
    #' Initialize a new GeneElementExpressionsValueObject class.
    #'
    #' @param geneOfficialSymbol geneOfficialSymbol
    #' @param geneNcbiId geneNcbiId
    #' @param vectors vectors
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `geneOfficialSymbol` = NULL, `geneNcbiId` = NULL, `vectors` = NULL, ...
    ) {
      if (!is.null(`geneOfficialSymbol`)) {
        stopifnot(is.character(`geneOfficialSymbol`), length(`geneOfficialSymbol`) == 1)
        self$`geneOfficialSymbol` <- `geneOfficialSymbol`
      }
      if (!is.null(`geneNcbiId`)) {
        stopifnot(is.numeric(`geneNcbiId`), length(`geneNcbiId`) == 1)
        self$`geneNcbiId` <- `geneNcbiId`
      }
      if (!is.null(`vectors`)) {
        stopifnot(is.vector(`vectors`), length(`vectors`) != 0)
        sapply(`vectors`, function(x) stopifnot(R6::is.R6(x)))
        self$`vectors` <- `vectors`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneElementExpressionsValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneElementExpressionsValueObjectObject <- list()
      if (!is.null(self$`geneOfficialSymbol`)) {
        GeneElementExpressionsValueObjectObject[["geneOfficialSymbol"]] <-
          self$`geneOfficialSymbol`
      }
      if (!is.null(self$`geneNcbiId`)) {
        GeneElementExpressionsValueObjectObject[["geneNcbiId"]] <-
          self$`geneNcbiId`
      }
      if (!is.null(self$`vectors`)) {
        GeneElementExpressionsValueObjectObject[["vectors"]] <-
          lapply(self$`vectors`, function(x) x$toJSON())
      }
      GeneElementExpressionsValueObjectObject
    },
    #' Deserialize JSON string into an instance of GeneElementExpressionsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneElementExpressionsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneElementExpressionsValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`geneOfficialSymbol`)) {
        self$`geneOfficialSymbol` <- this_object$`geneOfficialSymbol`
      }
      if (!is.null(this_object$`geneNcbiId`)) {
        self$`geneNcbiId` <- this_object$`geneNcbiId`
      }
      if (!is.null(this_object$`vectors`)) {
        self$`vectors` <- ApiClient$new()$deserializeObj(this_object$`vectors`, "array[VectorElementValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneElementExpressionsValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`geneOfficialSymbol`)) {
          sprintf(
          '"geneOfficialSymbol":
            "%s"
                    ',
          self$`geneOfficialSymbol`
          )
        },
        if (!is.null(self$`geneNcbiId`)) {
          sprintf(
          '"geneNcbiId":
            %d
                    ',
          self$`geneNcbiId`
          )
        },
        if (!is.null(self$`vectors`)) {
          sprintf(
          '"vectors":
          [%s]
',
          paste(sapply(self$`vectors`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneElementExpressionsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneElementExpressionsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneElementExpressionsValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`geneOfficialSymbol` <- this_object$`geneOfficialSymbol`
      self$`geneNcbiId` <- this_object$`geneNcbiId`
      self$`vectors` <- ApiClient$new()$deserializeObj(this_object$`vectors`, "array[VectorElementValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to GeneElementExpressionsValueObject
    #'
    #' @description
    #' Validate JSON input with respect to GeneElementExpressionsValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneElementExpressionsValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneElementExpressionsValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneElementExpressionsValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneElementExpressionsValueObject$lock()


#' Create a new GeneMappingSummary
#'
#' @description
#' GeneMappingSummary Class
#'
#' @docType class
#' @title GeneMappingSummary
#' @description GeneMappingSummary Class
#' @format An \code{R6Class} generator object
#' @field geneProductIdMap  named list(\link{GeneProductValueObject}) optional
#' @field geneProductIdGeneMap  named list(\link{GeneValueObject}) optional
#' @field blatResult  \link{BlatResultValueObject} optional
#' @field geneProductMap  named list(\link{GeneValueObject}) optional
#' @field compositeSequence  \link{CompositeSequenceValueObject} optional
#' @field identity  numeric optional
#' @field score  numeric optional
#' @field blatResultId  character optional
#' @field geneProducts  list(\link{GeneProductValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneMappingSummary <- R6::R6Class(
  "GeneMappingSummary",
  public = list(
    `geneProductIdMap` = NULL,
    `geneProductIdGeneMap` = NULL,
    `blatResult` = NULL,
    `geneProductMap` = NULL,
    `compositeSequence` = NULL,
    `identity` = NULL,
    `score` = NULL,
    `blatResultId` = NULL,
    `geneProducts` = NULL,
    #' Initialize a new GeneMappingSummary class.
    #'
    #' @description
    #' Initialize a new GeneMappingSummary class.
    #'
    #' @param geneProductIdMap geneProductIdMap
    #' @param geneProductIdGeneMap geneProductIdGeneMap
    #' @param blatResult blatResult
    #' @param geneProductMap geneProductMap
    #' @param compositeSequence compositeSequence
    #' @param identity identity
    #' @param score score
    #' @param blatResultId blatResultId
    #' @param geneProducts geneProducts
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `geneProductIdMap` = NULL, `geneProductIdGeneMap` = NULL, `blatResult` = NULL, `geneProductMap` = NULL, `compositeSequence` = NULL, `identity` = NULL, `score` = NULL, `blatResultId` = NULL, `geneProducts` = NULL, ...
    ) {
      if (!is.null(`geneProductIdMap`)) {
        stopifnot(is.vector(`geneProductIdMap`), length(`geneProductIdMap`) != 0)
        sapply(`geneProductIdMap`, function(x) stopifnot(R6::is.R6(x)))
        self$`geneProductIdMap` <- `geneProductIdMap`
      }
      if (!is.null(`geneProductIdGeneMap`)) {
        stopifnot(is.vector(`geneProductIdGeneMap`), length(`geneProductIdGeneMap`) != 0)
        sapply(`geneProductIdGeneMap`, function(x) stopifnot(R6::is.R6(x)))
        self$`geneProductIdGeneMap` <- `geneProductIdGeneMap`
      }
      if (!is.null(`blatResult`)) {
        stopifnot(R6::is.R6(`blatResult`))
        self$`blatResult` <- `blatResult`
      }
      if (!is.null(`geneProductMap`)) {
        stopifnot(is.vector(`geneProductMap`), length(`geneProductMap`) != 0)
        sapply(`geneProductMap`, function(x) stopifnot(R6::is.R6(x)))
        self$`geneProductMap` <- `geneProductMap`
      }
      if (!is.null(`compositeSequence`)) {
        stopifnot(R6::is.R6(`compositeSequence`))
        self$`compositeSequence` <- `compositeSequence`
      }
      if (!is.null(`identity`)) {
        stopifnot(is.numeric(`identity`), length(`identity`) == 1)
        self$`identity` <- `identity`
      }
      if (!is.null(`score`)) {
        stopifnot(is.numeric(`score`), length(`score`) == 1)
        self$`score` <- `score`
      }
      if (!is.null(`blatResultId`)) {
        stopifnot(is.character(`blatResultId`), length(`blatResultId`) == 1)
        self$`blatResultId` <- `blatResultId`
      }
      if (!is.null(`geneProducts`)) {
        stopifnot(is.vector(`geneProducts`), length(`geneProducts`) != 0)
        sapply(`geneProducts`, function(x) stopifnot(R6::is.R6(x)))
        self$`geneProducts` <- `geneProducts`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneMappingSummary in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneMappingSummaryObject <- list()
      if (!is.null(self$`geneProductIdMap`)) {
        GeneMappingSummaryObject[["geneProductIdMap"]] <-
          lapply(self$`geneProductIdMap`, function(x) x$toJSON())
      }
      if (!is.null(self$`geneProductIdGeneMap`)) {
        GeneMappingSummaryObject[["geneProductIdGeneMap"]] <-
          lapply(self$`geneProductIdGeneMap`, function(x) x$toJSON())
      }
      if (!is.null(self$`blatResult`)) {
        GeneMappingSummaryObject[["blatResult"]] <-
          self$`blatResult`$toJSON()
      }
      if (!is.null(self$`geneProductMap`)) {
        GeneMappingSummaryObject[["geneProductMap"]] <-
          lapply(self$`geneProductMap`, function(x) x$toJSON())
      }
      if (!is.null(self$`compositeSequence`)) {
        GeneMappingSummaryObject[["compositeSequence"]] <-
          self$`compositeSequence`$toJSON()
      }
      if (!is.null(self$`identity`)) {
        GeneMappingSummaryObject[["identity"]] <-
          self$`identity`
      }
      if (!is.null(self$`score`)) {
        GeneMappingSummaryObject[["score"]] <-
          self$`score`
      }
      if (!is.null(self$`blatResultId`)) {
        GeneMappingSummaryObject[["blatResultId"]] <-
          self$`blatResultId`
      }
      if (!is.null(self$`geneProducts`)) {
        GeneMappingSummaryObject[["geneProducts"]] <-
          lapply(self$`geneProducts`, function(x) x$toJSON())
      }
      GeneMappingSummaryObject
    },
    #' Deserialize JSON string into an instance of GeneMappingSummary
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneMappingSummary
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneMappingSummary
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`geneProductIdMap`)) {
        self$`geneProductIdMap` <- ApiClient$new()$deserializeObj(this_object$`geneProductIdMap`, "map(GeneProductValueObject)", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`geneProductIdGeneMap`)) {
        self$`geneProductIdGeneMap` <- ApiClient$new()$deserializeObj(this_object$`geneProductIdGeneMap`, "map(GeneValueObject)", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`blatResult`)) {
        blatresult_object <- BlatResultValueObject$new()
        blatresult_object$fromJSON(jsonlite::toJSON(this_object$blatResult, auto_unbox = TRUE, digits = NA))
        self$`blatResult` <- blatresult_object
      }
      if (!is.null(this_object$`geneProductMap`)) {
        self$`geneProductMap` <- ApiClient$new()$deserializeObj(this_object$`geneProductMap`, "map(GeneValueObject)", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`compositeSequence`)) {
        compositesequence_object <- CompositeSequenceValueObject$new()
        compositesequence_object$fromJSON(jsonlite::toJSON(this_object$compositeSequence, auto_unbox = TRUE, digits = NA))
        self$`compositeSequence` <- compositesequence_object
      }
      if (!is.null(this_object$`identity`)) {
        self$`identity` <- this_object$`identity`
      }
      if (!is.null(this_object$`score`)) {
        self$`score` <- this_object$`score`
      }
      if (!is.null(this_object$`blatResultId`)) {
        self$`blatResultId` <- this_object$`blatResultId`
      }
      if (!is.null(this_object$`geneProducts`)) {
        self$`geneProducts` <- ApiClient$new()$deserializeObj(this_object$`geneProducts`, "array[GeneProductValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneMappingSummary in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`geneProductIdMap`)) {
          sprintf(
          '"geneProductIdMap":
          %s
',
          jsonlite::toJSON(lapply(self$`geneProductIdMap`, function(x){ x$toJSON() }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`geneProductIdGeneMap`)) {
          sprintf(
          '"geneProductIdGeneMap":
          %s
',
          jsonlite::toJSON(lapply(self$`geneProductIdGeneMap`, function(x){ x$toJSON() }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`blatResult`)) {
          sprintf(
          '"blatResult":
          %s
          ',
          jsonlite::toJSON(self$`blatResult`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`geneProductMap`)) {
          sprintf(
          '"geneProductMap":
          %s
',
          jsonlite::toJSON(lapply(self$`geneProductMap`, function(x){ x$toJSON() }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`compositeSequence`)) {
          sprintf(
          '"compositeSequence":
          %s
          ',
          jsonlite::toJSON(self$`compositeSequence`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`identity`)) {
          sprintf(
          '"identity":
            %d
                    ',
          self$`identity`
          )
        },
        if (!is.null(self$`score`)) {
          sprintf(
          '"score":
            %d
                    ',
          self$`score`
          )
        },
        if (!is.null(self$`blatResultId`)) {
          sprintf(
          '"blatResultId":
            "%s"
                    ',
          self$`blatResultId`
          )
        },
        if (!is.null(self$`geneProducts`)) {
          sprintf(
          '"geneProducts":
          [%s]
',
          paste(sapply(self$`geneProducts`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneMappingSummary
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneMappingSummary
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneMappingSummary
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`geneProductIdMap` <- ApiClient$new()$deserializeObj(this_object$`geneProductIdMap`, "map(GeneProductValueObject)", loadNamespace("gemma.R"))
      self$`geneProductIdGeneMap` <- ApiClient$new()$deserializeObj(this_object$`geneProductIdGeneMap`, "map(GeneValueObject)", loadNamespace("gemma.R"))
      self$`blatResult` <- BlatResultValueObject$new()$fromJSON(jsonlite::toJSON(this_object$blatResult, auto_unbox = TRUE, digits = NA))
      self$`geneProductMap` <- ApiClient$new()$deserializeObj(this_object$`geneProductMap`, "map(GeneValueObject)", loadNamespace("gemma.R"))
      self$`compositeSequence` <- CompositeSequenceValueObject$new()$fromJSON(jsonlite::toJSON(this_object$compositeSequence, auto_unbox = TRUE, digits = NA))
      self$`identity` <- this_object$`identity`
      self$`score` <- this_object$`score`
      self$`blatResultId` <- this_object$`blatResultId`
      self$`geneProducts` <- ApiClient$new()$deserializeObj(this_object$`geneProducts`, "array[GeneProductValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to GeneMappingSummary
    #'
    #' @description
    #' Validate JSON input with respect to GeneMappingSummary and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneMappingSummary
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneMappingSummary$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneMappingSummary$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneMappingSummary$lock()


#' Create a new GeneOntologyTermValueObject
#'
#' @description
#' GeneOntologyTermValueObject Class
#'
#' @docType class
#' @title GeneOntologyTermValueObject
#' @description GeneOntologyTermValueObject Class
#' @format An \code{R6Class} generator object
#' @field goId  character optional
#' @field label  character optional
#' @field uri  character optional
#' @field comment  character optional
#' @field localName  character optional
#' @field term  character optional
#' @field obsolete  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneOntologyTermValueObject <- R6::R6Class(
  "GeneOntologyTermValueObject",
  public = list(
    `goId` = NULL,
    `label` = NULL,
    `uri` = NULL,
    `comment` = NULL,
    `localName` = NULL,
    `term` = NULL,
    `obsolete` = NULL,
    #' Initialize a new GeneOntologyTermValueObject class.
    #'
    #' @description
    #' Initialize a new GeneOntologyTermValueObject class.
    #'
    #' @param goId goId
    #' @param label label
    #' @param uri uri
    #' @param comment comment
    #' @param localName localName
    #' @param term term
    #' @param obsolete obsolete
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `goId` = NULL, `label` = NULL, `uri` = NULL, `comment` = NULL, `localName` = NULL, `term` = NULL, `obsolete` = NULL, ...
    ) {
      if (!is.null(`goId`)) {
        stopifnot(is.character(`goId`), length(`goId`) == 1)
        self$`goId` <- `goId`
      }
      if (!is.null(`label`)) {
        stopifnot(is.character(`label`), length(`label`) == 1)
        self$`label` <- `label`
      }
      if (!is.null(`uri`)) {
        stopifnot(is.character(`uri`), length(`uri`) == 1)
        self$`uri` <- `uri`
      }
      if (!is.null(`comment`)) {
        stopifnot(is.character(`comment`), length(`comment`) == 1)
        self$`comment` <- `comment`
      }
      if (!is.null(`localName`)) {
        stopifnot(is.character(`localName`), length(`localName`) == 1)
        self$`localName` <- `localName`
      }
      if (!is.null(`term`)) {
        stopifnot(is.character(`term`), length(`term`) == 1)
        self$`term` <- `term`
      }
      if (!is.null(`obsolete`)) {
        stopifnot(is.logical(`obsolete`), length(`obsolete`) == 1)
        self$`obsolete` <- `obsolete`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneOntologyTermValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneOntologyTermValueObjectObject <- list()
      if (!is.null(self$`goId`)) {
        GeneOntologyTermValueObjectObject[["goId"]] <-
          self$`goId`
      }
      if (!is.null(self$`label`)) {
        GeneOntologyTermValueObjectObject[["label"]] <-
          self$`label`
      }
      if (!is.null(self$`uri`)) {
        GeneOntologyTermValueObjectObject[["uri"]] <-
          self$`uri`
      }
      if (!is.null(self$`comment`)) {
        GeneOntologyTermValueObjectObject[["comment"]] <-
          self$`comment`
      }
      if (!is.null(self$`localName`)) {
        GeneOntologyTermValueObjectObject[["localName"]] <-
          self$`localName`
      }
      if (!is.null(self$`term`)) {
        GeneOntologyTermValueObjectObject[["term"]] <-
          self$`term`
      }
      if (!is.null(self$`obsolete`)) {
        GeneOntologyTermValueObjectObject[["obsolete"]] <-
          self$`obsolete`
      }
      GeneOntologyTermValueObjectObject
    },
    #' Deserialize JSON string into an instance of GeneOntologyTermValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneOntologyTermValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneOntologyTermValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`goId`)) {
        self$`goId` <- this_object$`goId`
      }
      if (!is.null(this_object$`label`)) {
        self$`label` <- this_object$`label`
      }
      if (!is.null(this_object$`uri`)) {
        self$`uri` <- this_object$`uri`
      }
      if (!is.null(this_object$`comment`)) {
        self$`comment` <- this_object$`comment`
      }
      if (!is.null(this_object$`localName`)) {
        self$`localName` <- this_object$`localName`
      }
      if (!is.null(this_object$`term`)) {
        self$`term` <- this_object$`term`
      }
      if (!is.null(this_object$`obsolete`)) {
        self$`obsolete` <- this_object$`obsolete`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneOntologyTermValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`goId`)) {
          sprintf(
          '"goId":
            "%s"
                    ',
          self$`goId`
          )
        },
        if (!is.null(self$`label`)) {
          sprintf(
          '"label":
            "%s"
                    ',
          self$`label`
          )
        },
        if (!is.null(self$`uri`)) {
          sprintf(
          '"uri":
            "%s"
                    ',
          self$`uri`
          )
        },
        if (!is.null(self$`comment`)) {
          sprintf(
          '"comment":
            "%s"
                    ',
          self$`comment`
          )
        },
        if (!is.null(self$`localName`)) {
          sprintf(
          '"localName":
            "%s"
                    ',
          self$`localName`
          )
        },
        if (!is.null(self$`term`)) {
          sprintf(
          '"term":
            "%s"
                    ',
          self$`term`
          )
        },
        if (!is.null(self$`obsolete`)) {
          sprintf(
          '"obsolete":
            %s
                    ',
          tolower(self$`obsolete`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneOntologyTermValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneOntologyTermValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneOntologyTermValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`goId` <- this_object$`goId`
      self$`label` <- this_object$`label`
      self$`uri` <- this_object$`uri`
      self$`comment` <- this_object$`comment`
      self$`localName` <- this_object$`localName`
      self$`term` <- this_object$`term`
      self$`obsolete` <- this_object$`obsolete`
      self
    },
    #' Validate JSON input with respect to GeneOntologyTermValueObject
    #'
    #' @description
    #' Validate JSON input with respect to GeneOntologyTermValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneOntologyTermValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneOntologyTermValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneOntologyTermValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneOntologyTermValueObject$lock()


#' Create a new GeneProduct
#'
#' @description
#' GeneProduct Class
#'
#' @docType class
#' @title GeneProduct
#' @description GeneProduct Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field previousNcbiId  character optional
#' @field physicalLocation  \link{PhysicalLocation} optional
#' @field ncbiGi  character optional
#' @field accessions  list(\link{DatabaseEntry}) optional
#' @field exons  list(\link{PhysicalLocation}) optional
#' @field gene  \link{Gene} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneProduct <- R6::R6Class(
  "GeneProduct",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `previousNcbiId` = NULL,
    `physicalLocation` = NULL,
    `ncbiGi` = NULL,
    `accessions` = NULL,
    `exons` = NULL,
    `gene` = NULL,
    #' Initialize a new GeneProduct class.
    #'
    #' @description
    #' Initialize a new GeneProduct class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param previousNcbiId previousNcbiId
    #' @param physicalLocation physicalLocation
    #' @param ncbiGi ncbiGi
    #' @param accessions accessions
    #' @param exons exons
    #' @param gene gene
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `previousNcbiId` = NULL, `physicalLocation` = NULL, `ncbiGi` = NULL, `accessions` = NULL, `exons` = NULL, `gene` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`previousNcbiId`)) {
        stopifnot(is.character(`previousNcbiId`), length(`previousNcbiId`) == 1)
        self$`previousNcbiId` <- `previousNcbiId`
      }
      if (!is.null(`physicalLocation`)) {
        stopifnot(R6::is.R6(`physicalLocation`))
        self$`physicalLocation` <- `physicalLocation`
      }
      if (!is.null(`ncbiGi`)) {
        stopifnot(is.character(`ncbiGi`), length(`ncbiGi`) == 1)
        self$`ncbiGi` <- `ncbiGi`
      }
      if (!is.null(`accessions`)) {
        stopifnot(is.vector(`accessions`), length(`accessions`) != 0)
        sapply(`accessions`, function(x) stopifnot(R6::is.R6(x)))
        self$`accessions` <- `accessions`
      }
      if (!is.null(`exons`)) {
        stopifnot(is.vector(`exons`), length(`exons`) != 0)
        sapply(`exons`, function(x) stopifnot(R6::is.R6(x)))
        self$`exons` <- `exons`
      }
      if (!is.null(`gene`)) {
        stopifnot(R6::is.R6(`gene`))
        self$`gene` <- `gene`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneProduct in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneProductObject <- list()
      if (!is.null(self$`name`)) {
        GeneProductObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        GeneProductObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        GeneProductObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`previousNcbiId`)) {
        GeneProductObject[["previousNcbiId"]] <-
          self$`previousNcbiId`
      }
      if (!is.null(self$`physicalLocation`)) {
        GeneProductObject[["physicalLocation"]] <-
          self$`physicalLocation`$toJSON()
      }
      if (!is.null(self$`ncbiGi`)) {
        GeneProductObject[["ncbiGi"]] <-
          self$`ncbiGi`
      }
      if (!is.null(self$`accessions`)) {
        GeneProductObject[["accessions"]] <-
          lapply(self$`accessions`, function(x) x$toJSON())
      }
      if (!is.null(self$`exons`)) {
        GeneProductObject[["exons"]] <-
          lapply(self$`exons`, function(x) x$toJSON())
      }
      if (!is.null(self$`gene`)) {
        GeneProductObject[["gene"]] <-
          self$`gene`$toJSON()
      }
      GeneProductObject
    },
    #' Deserialize JSON string into an instance of GeneProduct
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneProduct
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneProduct
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`previousNcbiId`)) {
        self$`previousNcbiId` <- this_object$`previousNcbiId`
      }
      if (!is.null(this_object$`physicalLocation`)) {
        physicallocation_object <- PhysicalLocation$new()
        physicallocation_object$fromJSON(jsonlite::toJSON(this_object$physicalLocation, auto_unbox = TRUE, digits = NA))
        self$`physicalLocation` <- physicallocation_object
      }
      if (!is.null(this_object$`ncbiGi`)) {
        self$`ncbiGi` <- this_object$`ncbiGi`
      }
      if (!is.null(this_object$`accessions`)) {
        self$`accessions` <- ApiClient$new()$deserializeObj(this_object$`accessions`, "set[DatabaseEntry]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`exons`)) {
        self$`exons` <- ApiClient$new()$deserializeObj(this_object$`exons`, "set[PhysicalLocation]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`gene`)) {
        gene_object <- Gene$new()
        gene_object$fromJSON(jsonlite::toJSON(this_object$gene, auto_unbox = TRUE, digits = NA))
        self$`gene` <- gene_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneProduct in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`previousNcbiId`)) {
          sprintf(
          '"previousNcbiId":
            "%s"
                    ',
          self$`previousNcbiId`
          )
        },
        if (!is.null(self$`physicalLocation`)) {
          sprintf(
          '"physicalLocation":
          %s
          ',
          jsonlite::toJSON(self$`physicalLocation`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`ncbiGi`)) {
          sprintf(
          '"ncbiGi":
            "%s"
                    ',
          self$`ncbiGi`
          )
        },
        if (!is.null(self$`accessions`)) {
          sprintf(
          '"accessions":
          [%s]
',
          paste(sapply(self$`accessions`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`exons`)) {
          sprintf(
          '"exons":
          [%s]
',
          paste(sapply(self$`exons`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`gene`)) {
          sprintf(
          '"gene":
          %s
          ',
          jsonlite::toJSON(self$`gene`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneProduct
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneProduct
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneProduct
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`previousNcbiId` <- this_object$`previousNcbiId`
      self$`physicalLocation` <- PhysicalLocation$new()$fromJSON(jsonlite::toJSON(this_object$physicalLocation, auto_unbox = TRUE, digits = NA))
      self$`ncbiGi` <- this_object$`ncbiGi`
      self$`accessions` <- ApiClient$new()$deserializeObj(this_object$`accessions`, "set[DatabaseEntry]", loadNamespace("gemma.R"))
      self$`exons` <- ApiClient$new()$deserializeObj(this_object$`exons`, "set[PhysicalLocation]", loadNamespace("gemma.R"))
      self$`gene` <- Gene$new()$fromJSON(jsonlite::toJSON(this_object$gene, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to GeneProduct
    #'
    #' @description
    #' Validate JSON input with respect to GeneProduct and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneProduct
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {


      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()


      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneProduct$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneProduct$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneProduct$lock()


#' Create a new GeneProductValueObject
#'
#' @description
#' GeneProductValueObject Class
#'
#' @docType class
#' @title GeneProductValueObject
#' @description GeneProductValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field ncbiId  character optional
#' @field name  character optional
#' @field geneId  integer optional
#' @field chromosome  character optional
#' @field strand  character optional
#' @field nucleotideStart  integer optional
#' @field nucleotideEnd  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneProductValueObject <- R6::R6Class(
  "GeneProductValueObject",
  public = list(
    `id` = NULL,
    `ncbiId` = NULL,
    `name` = NULL,
    `geneId` = NULL,
    `chromosome` = NULL,
    `strand` = NULL,
    `nucleotideStart` = NULL,
    `nucleotideEnd` = NULL,
    #' Initialize a new GeneProductValueObject class.
    #'
    #' @description
    #' Initialize a new GeneProductValueObject class.
    #'
    #' @param id id
    #' @param ncbiId ncbiId
    #' @param name name
    #' @param geneId geneId
    #' @param chromosome chromosome
    #' @param strand strand
    #' @param nucleotideStart nucleotideStart
    #' @param nucleotideEnd nucleotideEnd
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `ncbiId` = NULL, `name` = NULL, `geneId` = NULL, `chromosome` = NULL, `strand` = NULL, `nucleotideStart` = NULL, `nucleotideEnd` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`ncbiId`)) {
        stopifnot(is.character(`ncbiId`), length(`ncbiId`) == 1)
        self$`ncbiId` <- `ncbiId`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`geneId`)) {
        stopifnot(is.numeric(`geneId`), length(`geneId`) == 1)
        self$`geneId` <- `geneId`
      }
      if (!is.null(`chromosome`)) {
        stopifnot(is.character(`chromosome`), length(`chromosome`) == 1)
        self$`chromosome` <- `chromosome`
      }
      if (!is.null(`strand`)) {
        stopifnot(is.character(`strand`), length(`strand`) == 1)
        self$`strand` <- `strand`
      }
      if (!is.null(`nucleotideStart`)) {
        stopifnot(is.numeric(`nucleotideStart`), length(`nucleotideStart`) == 1)
        self$`nucleotideStart` <- `nucleotideStart`
      }
      if (!is.null(`nucleotideEnd`)) {
        stopifnot(is.numeric(`nucleotideEnd`), length(`nucleotideEnd`) == 1)
        self$`nucleotideEnd` <- `nucleotideEnd`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneProductValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneProductValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        GeneProductValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`ncbiId`)) {
        GeneProductValueObjectObject[["ncbiId"]] <-
          self$`ncbiId`
      }
      if (!is.null(self$`name`)) {
        GeneProductValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`geneId`)) {
        GeneProductValueObjectObject[["geneId"]] <-
          self$`geneId`
      }
      if (!is.null(self$`chromosome`)) {
        GeneProductValueObjectObject[["chromosome"]] <-
          self$`chromosome`
      }
      if (!is.null(self$`strand`)) {
        GeneProductValueObjectObject[["strand"]] <-
          self$`strand`
      }
      if (!is.null(self$`nucleotideStart`)) {
        GeneProductValueObjectObject[["nucleotideStart"]] <-
          self$`nucleotideStart`
      }
      if (!is.null(self$`nucleotideEnd`)) {
        GeneProductValueObjectObject[["nucleotideEnd"]] <-
          self$`nucleotideEnd`
      }
      GeneProductValueObjectObject
    },
    #' Deserialize JSON string into an instance of GeneProductValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneProductValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneProductValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`ncbiId`)) {
        self$`ncbiId` <- this_object$`ncbiId`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`geneId`)) {
        self$`geneId` <- this_object$`geneId`
      }
      if (!is.null(this_object$`chromosome`)) {
        self$`chromosome` <- this_object$`chromosome`
      }
      if (!is.null(this_object$`strand`)) {
        self$`strand` <- this_object$`strand`
      }
      if (!is.null(this_object$`nucleotideStart`)) {
        self$`nucleotideStart` <- this_object$`nucleotideStart`
      }
      if (!is.null(this_object$`nucleotideEnd`)) {
        self$`nucleotideEnd` <- this_object$`nucleotideEnd`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneProductValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`ncbiId`)) {
          sprintf(
          '"ncbiId":
            "%s"
                    ',
          self$`ncbiId`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`geneId`)) {
          sprintf(
          '"geneId":
            %d
                    ',
          self$`geneId`
          )
        },
        if (!is.null(self$`chromosome`)) {
          sprintf(
          '"chromosome":
            "%s"
                    ',
          self$`chromosome`
          )
        },
        if (!is.null(self$`strand`)) {
          sprintf(
          '"strand":
            "%s"
                    ',
          self$`strand`
          )
        },
        if (!is.null(self$`nucleotideStart`)) {
          sprintf(
          '"nucleotideStart":
            %d
                    ',
          self$`nucleotideStart`
          )
        },
        if (!is.null(self$`nucleotideEnd`)) {
          sprintf(
          '"nucleotideEnd":
            %d
                    ',
          self$`nucleotideEnd`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneProductValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneProductValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneProductValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`ncbiId` <- this_object$`ncbiId`
      self$`name` <- this_object$`name`
      self$`geneId` <- this_object$`geneId`
      self$`chromosome` <- this_object$`chromosome`
      self$`strand` <- this_object$`strand`
      self$`nucleotideStart` <- this_object$`nucleotideStart`
      self$`nucleotideEnd` <- this_object$`nucleotideEnd`
      self
    },
    #' Validate JSON input with respect to GeneProductValueObject
    #'
    #' @description
    #' Validate JSON input with respect to GeneProductValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneProductValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneProductValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneProductValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneProductValueObject$lock()


#' Create a new GeneSetValueObject
#'
#' @description
#' GeneSetValueObject Class
#'
#' @docType class
#' @title GeneSetValueObject
#' @description GeneSetValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field description  character optional
#' @field geneIds  list(integer) optional
#' @field isPublic  character optional
#' @field isShared  character optional
#' @field name  character optional
#' @field size  integer optional
#' @field taxonId  integer optional
#' @field taxonName  character optional
#' @field userOwned  character optional
#' @field userCanWrite  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneSetValueObject <- R6::R6Class(
  "GeneSetValueObject",
  public = list(
    `id` = NULL,
    `description` = NULL,
    `geneIds` = NULL,
    `isPublic` = NULL,
    `isShared` = NULL,
    `name` = NULL,
    `size` = NULL,
    `taxonId` = NULL,
    `taxonName` = NULL,
    `userOwned` = NULL,
    `userCanWrite` = NULL,
    #' Initialize a new GeneSetValueObject class.
    #'
    #' @description
    #' Initialize a new GeneSetValueObject class.
    #'
    #' @param id id
    #' @param description description
    #' @param geneIds geneIds
    #' @param isPublic isPublic
    #' @param isShared isShared
    #' @param name name
    #' @param size size
    #' @param taxonId taxonId
    #' @param taxonName taxonName
    #' @param userOwned userOwned
    #' @param userCanWrite userCanWrite
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `description` = NULL, `geneIds` = NULL, `isPublic` = NULL, `isShared` = NULL, `name` = NULL, `size` = NULL, `taxonId` = NULL, `taxonName` = NULL, `userOwned` = NULL, `userCanWrite` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`geneIds`)) {
        stopifnot(is.vector(`geneIds`), length(`geneIds`) != 0)
        sapply(`geneIds`, function(x) stopifnot(is.character(x)))
        self$`geneIds` <- `geneIds`
      }
      if (!is.null(`isPublic`)) {
        stopifnot(is.logical(`isPublic`), length(`isPublic`) == 1)
        self$`isPublic` <- `isPublic`
      }
      if (!is.null(`isShared`)) {
        stopifnot(is.logical(`isShared`), length(`isShared`) == 1)
        self$`isShared` <- `isShared`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`size`)) {
        stopifnot(is.numeric(`size`), length(`size`) == 1)
        self$`size` <- `size`
      }
      if (!is.null(`taxonId`)) {
        stopifnot(is.numeric(`taxonId`), length(`taxonId`) == 1)
        self$`taxonId` <- `taxonId`
      }
      if (!is.null(`taxonName`)) {
        stopifnot(is.character(`taxonName`), length(`taxonName`) == 1)
        self$`taxonName` <- `taxonName`
      }
      if (!is.null(`userOwned`)) {
        stopifnot(is.logical(`userOwned`), length(`userOwned`) == 1)
        self$`userOwned` <- `userOwned`
      }
      if (!is.null(`userCanWrite`)) {
        stopifnot(is.logical(`userCanWrite`), length(`userCanWrite`) == 1)
        self$`userCanWrite` <- `userCanWrite`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneSetValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneSetValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        GeneSetValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`description`)) {
        GeneSetValueObjectObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`geneIds`)) {
        GeneSetValueObjectObject[["geneIds"]] <-
          self$`geneIds`
      }
      if (!is.null(self$`isPublic`)) {
        GeneSetValueObjectObject[["isPublic"]] <-
          self$`isPublic`
      }
      if (!is.null(self$`isShared`)) {
        GeneSetValueObjectObject[["isShared"]] <-
          self$`isShared`
      }
      if (!is.null(self$`name`)) {
        GeneSetValueObjectObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`size`)) {
        GeneSetValueObjectObject[["size"]] <-
          self$`size`
      }
      if (!is.null(self$`taxonId`)) {
        GeneSetValueObjectObject[["taxonId"]] <-
          self$`taxonId`
      }
      if (!is.null(self$`taxonName`)) {
        GeneSetValueObjectObject[["taxonName"]] <-
          self$`taxonName`
      }
      if (!is.null(self$`userOwned`)) {
        GeneSetValueObjectObject[["userOwned"]] <-
          self$`userOwned`
      }
      if (!is.null(self$`userCanWrite`)) {
        GeneSetValueObjectObject[["userCanWrite"]] <-
          self$`userCanWrite`
      }
      GeneSetValueObjectObject
    },
    #' Deserialize JSON string into an instance of GeneSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneSetValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`geneIds`)) {
        self$`geneIds` <- ApiClient$new()$deserializeObj(this_object$`geneIds`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`isPublic`)) {
        self$`isPublic` <- this_object$`isPublic`
      }
      if (!is.null(this_object$`isShared`)) {
        self$`isShared` <- this_object$`isShared`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`size`)) {
        self$`size` <- this_object$`size`
      }
      if (!is.null(this_object$`taxonId`)) {
        self$`taxonId` <- this_object$`taxonId`
      }
      if (!is.null(this_object$`taxonName`)) {
        self$`taxonName` <- this_object$`taxonName`
      }
      if (!is.null(this_object$`userOwned`)) {
        self$`userOwned` <- this_object$`userOwned`
      }
      if (!is.null(this_object$`userCanWrite`)) {
        self$`userCanWrite` <- this_object$`userCanWrite`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneSetValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`geneIds`)) {
          sprintf(
          '"geneIds":
             [%s]
          ',
          paste(unlist(lapply(self$`geneIds`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`isPublic`)) {
          sprintf(
          '"isPublic":
            %s
                    ',
          tolower(self$`isPublic`)
          )
        },
        if (!is.null(self$`isShared`)) {
          sprintf(
          '"isShared":
            %s
                    ',
          tolower(self$`isShared`)
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`size`)) {
          sprintf(
          '"size":
            %d
                    ',
          self$`size`
          )
        },
        if (!is.null(self$`taxonId`)) {
          sprintf(
          '"taxonId":
            %d
                    ',
          self$`taxonId`
          )
        },
        if (!is.null(self$`taxonName`)) {
          sprintf(
          '"taxonName":
            "%s"
                    ',
          self$`taxonName`
          )
        },
        if (!is.null(self$`userOwned`)) {
          sprintf(
          '"userOwned":
            %s
                    ',
          tolower(self$`userOwned`)
          )
        },
        if (!is.null(self$`userCanWrite`)) {
          sprintf(
          '"userCanWrite":
            %s
                    ',
          tolower(self$`userCanWrite`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneSetValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`description` <- this_object$`description`
      self$`geneIds` <- ApiClient$new()$deserializeObj(this_object$`geneIds`, "array[integer]", loadNamespace("gemma.R"))
      self$`isPublic` <- this_object$`isPublic`
      self$`isShared` <- this_object$`isShared`
      self$`name` <- this_object$`name`
      self$`size` <- this_object$`size`
      self$`taxonId` <- this_object$`taxonId`
      self$`taxonName` <- this_object$`taxonName`
      self$`userOwned` <- this_object$`userOwned`
      self$`userCanWrite` <- this_object$`userCanWrite`
      self
    },
    #' Validate JSON input with respect to GeneSetValueObject
    #'
    #' @description
    #' Validate JSON input with respect to GeneSetValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneSetValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneSetValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneSetValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneSetValueObject$lock()


#' Create a new GeneValueObject
#'
#' @description
#' GeneValueObject Class
#'
#' @docType class
#' @title GeneValueObject
#' @description GeneValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field aliases  list(character) optional
#' @field associatedExperimentCount  integer optional
#' @field compositeSequenceCount  integer optional
#' @field geneSets  list(\link{GeneSetValueObject}) optional
#' @field homologues  list(\link{GeneValueObject}) optional
#' @field isQuery  character optional
#' @field multifunctionalityRank  numeric optional
#' @field ncbiId  integer optional
#' @field ensemblId  character optional
#' @field nodeDegreeNegRanks  list(numeric) optional
#' @field nodeDegreePosRanks  list(numeric) optional
#' @field nodeDegreesNeg  list(integer) optional
#' @field nodeDegreesPos  list(integer) optional
#' @field numGoTerms  integer optional
#' @field officialName  character optional
#' @field officialSymbol  character optional
#' @field phenotypes  list(\link{CharacteristicValueObject}) optional
#' @field platformCount  integer optional
#' @field score  numeric optional
#' @field taxonCommonName  character optional
#' @field taxonId  integer optional
#' @field taxonScientificName  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneValueObject <- R6::R6Class(
  "GeneValueObject",
  public = list(
    `id` = NULL,
    `aliases` = NULL,
    `associatedExperimentCount` = NULL,
    `compositeSequenceCount` = NULL,
    `geneSets` = NULL,
    `homologues` = NULL,
    `isQuery` = NULL,
    `multifunctionalityRank` = NULL,
    `ncbiId` = NULL,
    `ensemblId` = NULL,
    `nodeDegreeNegRanks` = NULL,
    `nodeDegreePosRanks` = NULL,
    `nodeDegreesNeg` = NULL,
    `nodeDegreesPos` = NULL,
    `numGoTerms` = NULL,
    `officialName` = NULL,
    `officialSymbol` = NULL,
    `phenotypes` = NULL,
    `platformCount` = NULL,
    `score` = NULL,
    `taxonCommonName` = NULL,
    `taxonId` = NULL,
    `taxonScientificName` = NULL,
    #' Initialize a new GeneValueObject class.
    #'
    #' @description
    #' Initialize a new GeneValueObject class.
    #'
    #' @param id id
    #' @param aliases aliases
    #' @param associatedExperimentCount associatedExperimentCount
    #' @param compositeSequenceCount compositeSequenceCount
    #' @param geneSets geneSets
    #' @param homologues homologues
    #' @param isQuery isQuery
    #' @param multifunctionalityRank multifunctionalityRank
    #' @param ncbiId ncbiId
    #' @param ensemblId ensemblId
    #' @param nodeDegreeNegRanks nodeDegreeNegRanks
    #' @param nodeDegreePosRanks nodeDegreePosRanks
    #' @param nodeDegreesNeg nodeDegreesNeg
    #' @param nodeDegreesPos nodeDegreesPos
    #' @param numGoTerms numGoTerms
    #' @param officialName officialName
    #' @param officialSymbol officialSymbol
    #' @param phenotypes phenotypes
    #' @param platformCount platformCount
    #' @param score score
    #' @param taxonCommonName taxonCommonName
    #' @param taxonId taxonId
    #' @param taxonScientificName taxonScientificName
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `aliases` = NULL, `associatedExperimentCount` = NULL, `compositeSequenceCount` = NULL, `geneSets` = NULL, `homologues` = NULL, `isQuery` = NULL, `multifunctionalityRank` = NULL, `ncbiId` = NULL, `ensemblId` = NULL, `nodeDegreeNegRanks` = NULL, `nodeDegreePosRanks` = NULL, `nodeDegreesNeg` = NULL, `nodeDegreesPos` = NULL, `numGoTerms` = NULL, `officialName` = NULL, `officialSymbol` = NULL, `phenotypes` = NULL, `platformCount` = NULL, `score` = NULL, `taxonCommonName` = NULL, `taxonId` = NULL, `taxonScientificName` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`aliases`)) {
        stopifnot(is.vector(`aliases`), length(`aliases`) != 0)
        sapply(`aliases`, function(x) stopifnot(is.character(x)))
        self$`aliases` <- `aliases`
      }
      if (!is.null(`associatedExperimentCount`)) {
        stopifnot(is.numeric(`associatedExperimentCount`), length(`associatedExperimentCount`) == 1)
        self$`associatedExperimentCount` <- `associatedExperimentCount`
      }
      if (!is.null(`compositeSequenceCount`)) {
        stopifnot(is.numeric(`compositeSequenceCount`), length(`compositeSequenceCount`) == 1)
        self$`compositeSequenceCount` <- `compositeSequenceCount`
      }
      if (!is.null(`geneSets`)) {
        stopifnot(is.vector(`geneSets`), length(`geneSets`) != 0)
        sapply(`geneSets`, function(x) stopifnot(R6::is.R6(x)))
        self$`geneSets` <- `geneSets`
      }
      if (!is.null(`homologues`)) {
        stopifnot(is.vector(`homologues`), length(`homologues`) != 0)
        sapply(`homologues`, function(x) stopifnot(R6::is.R6(x)))
        self$`homologues` <- `homologues`
      }
      if (!is.null(`isQuery`)) {
        stopifnot(is.logical(`isQuery`), length(`isQuery`) == 1)
        self$`isQuery` <- `isQuery`
      }
      if (!is.null(`multifunctionalityRank`)) {
        stopifnot(is.numeric(`multifunctionalityRank`), length(`multifunctionalityRank`) == 1)
        self$`multifunctionalityRank` <- `multifunctionalityRank`
      }
      if (!is.null(`ncbiId`)) {
        stopifnot(is.numeric(`ncbiId`), length(`ncbiId`) == 1)
        self$`ncbiId` <- `ncbiId`
      }
      if (!is.null(`ensemblId`)) {
        stopifnot(is.character(`ensemblId`), length(`ensemblId`) == 1)
        self$`ensemblId` <- `ensemblId`
      }
      if (!is.null(`nodeDegreeNegRanks`)) {
        stopifnot(is.vector(`nodeDegreeNegRanks`), length(`nodeDegreeNegRanks`) != 0)
        sapply(`nodeDegreeNegRanks`, function(x) stopifnot(is.character(x)))
        self$`nodeDegreeNegRanks` <- `nodeDegreeNegRanks`
      }
      if (!is.null(`nodeDegreePosRanks`)) {
        stopifnot(is.vector(`nodeDegreePosRanks`), length(`nodeDegreePosRanks`) != 0)
        sapply(`nodeDegreePosRanks`, function(x) stopifnot(is.character(x)))
        self$`nodeDegreePosRanks` <- `nodeDegreePosRanks`
      }
      if (!is.null(`nodeDegreesNeg`)) {
        stopifnot(is.vector(`nodeDegreesNeg`), length(`nodeDegreesNeg`) != 0)
        sapply(`nodeDegreesNeg`, function(x) stopifnot(is.character(x)))
        self$`nodeDegreesNeg` <- `nodeDegreesNeg`
      }
      if (!is.null(`nodeDegreesPos`)) {
        stopifnot(is.vector(`nodeDegreesPos`), length(`nodeDegreesPos`) != 0)
        sapply(`nodeDegreesPos`, function(x) stopifnot(is.character(x)))
        self$`nodeDegreesPos` <- `nodeDegreesPos`
      }
      if (!is.null(`numGoTerms`)) {
        stopifnot(is.numeric(`numGoTerms`), length(`numGoTerms`) == 1)
        self$`numGoTerms` <- `numGoTerms`
      }
      if (!is.null(`officialName`)) {
        stopifnot(is.character(`officialName`), length(`officialName`) == 1)
        self$`officialName` <- `officialName`
      }
      if (!is.null(`officialSymbol`)) {
        stopifnot(is.character(`officialSymbol`), length(`officialSymbol`) == 1)
        self$`officialSymbol` <- `officialSymbol`
      }
      if (!is.null(`phenotypes`)) {
        stopifnot(is.vector(`phenotypes`), length(`phenotypes`) != 0)
        sapply(`phenotypes`, function(x) stopifnot(R6::is.R6(x)))
        self$`phenotypes` <- `phenotypes`
      }
      if (!is.null(`platformCount`)) {
        stopifnot(is.numeric(`platformCount`), length(`platformCount`) == 1)
        self$`platformCount` <- `platformCount`
      }
      if (!is.null(`score`)) {
        stopifnot(is.numeric(`score`), length(`score`) == 1)
        self$`score` <- `score`
      }
      if (!is.null(`taxonCommonName`)) {
        stopifnot(is.character(`taxonCommonName`), length(`taxonCommonName`) == 1)
        self$`taxonCommonName` <- `taxonCommonName`
      }
      if (!is.null(`taxonId`)) {
        stopifnot(is.numeric(`taxonId`), length(`taxonId`) == 1)
        self$`taxonId` <- `taxonId`
      }
      if (!is.null(`taxonScientificName`)) {
        stopifnot(is.character(`taxonScientificName`), length(`taxonScientificName`) == 1)
        self$`taxonScientificName` <- `taxonScientificName`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        GeneValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`aliases`)) {
        GeneValueObjectObject[["aliases"]] <-
          self$`aliases`
      }
      if (!is.null(self$`associatedExperimentCount`)) {
        GeneValueObjectObject[["associatedExperimentCount"]] <-
          self$`associatedExperimentCount`
      }
      if (!is.null(self$`compositeSequenceCount`)) {
        GeneValueObjectObject[["compositeSequenceCount"]] <-
          self$`compositeSequenceCount`
      }
      if (!is.null(self$`geneSets`)) {
        GeneValueObjectObject[["geneSets"]] <-
          lapply(self$`geneSets`, function(x) x$toJSON())
      }
      if (!is.null(self$`homologues`)) {
        GeneValueObjectObject[["homologues"]] <-
          lapply(self$`homologues`, function(x) x$toJSON())
      }
      if (!is.null(self$`isQuery`)) {
        GeneValueObjectObject[["isQuery"]] <-
          self$`isQuery`
      }
      if (!is.null(self$`multifunctionalityRank`)) {
        GeneValueObjectObject[["multifunctionalityRank"]] <-
          self$`multifunctionalityRank`
      }
      if (!is.null(self$`ncbiId`)) {
        GeneValueObjectObject[["ncbiId"]] <-
          self$`ncbiId`
      }
      if (!is.null(self$`ensemblId`)) {
        GeneValueObjectObject[["ensemblId"]] <-
          self$`ensemblId`
      }
      if (!is.null(self$`nodeDegreeNegRanks`)) {
        GeneValueObjectObject[["nodeDegreeNegRanks"]] <-
          self$`nodeDegreeNegRanks`
      }
      if (!is.null(self$`nodeDegreePosRanks`)) {
        GeneValueObjectObject[["nodeDegreePosRanks"]] <-
          self$`nodeDegreePosRanks`
      }
      if (!is.null(self$`nodeDegreesNeg`)) {
        GeneValueObjectObject[["nodeDegreesNeg"]] <-
          self$`nodeDegreesNeg`
      }
      if (!is.null(self$`nodeDegreesPos`)) {
        GeneValueObjectObject[["nodeDegreesPos"]] <-
          self$`nodeDegreesPos`
      }
      if (!is.null(self$`numGoTerms`)) {
        GeneValueObjectObject[["numGoTerms"]] <-
          self$`numGoTerms`
      }
      if (!is.null(self$`officialName`)) {
        GeneValueObjectObject[["officialName"]] <-
          self$`officialName`
      }
      if (!is.null(self$`officialSymbol`)) {
        GeneValueObjectObject[["officialSymbol"]] <-
          self$`officialSymbol`
      }
      if (!is.null(self$`phenotypes`)) {
        GeneValueObjectObject[["phenotypes"]] <-
          lapply(self$`phenotypes`, function(x) x$toJSON())
      }
      if (!is.null(self$`platformCount`)) {
        GeneValueObjectObject[["platformCount"]] <-
          self$`platformCount`
      }
      if (!is.null(self$`score`)) {
        GeneValueObjectObject[["score"]] <-
          self$`score`
      }
      if (!is.null(self$`taxonCommonName`)) {
        GeneValueObjectObject[["taxonCommonName"]] <-
          self$`taxonCommonName`
      }
      if (!is.null(self$`taxonId`)) {
        GeneValueObjectObject[["taxonId"]] <-
          self$`taxonId`
      }
      if (!is.null(self$`taxonScientificName`)) {
        GeneValueObjectObject[["taxonScientificName"]] <-
          self$`taxonScientificName`
      }
      GeneValueObjectObject
    },
    #' Deserialize JSON string into an instance of GeneValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`aliases`)) {
        self$`aliases` <- ApiClient$new()$deserializeObj(this_object$`aliases`, "array[character]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`associatedExperimentCount`)) {
        self$`associatedExperimentCount` <- this_object$`associatedExperimentCount`
      }
      if (!is.null(this_object$`compositeSequenceCount`)) {
        self$`compositeSequenceCount` <- this_object$`compositeSequenceCount`
      }
      if (!is.null(this_object$`geneSets`)) {
        self$`geneSets` <- ApiClient$new()$deserializeObj(this_object$`geneSets`, "array[GeneSetValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`homologues`)) {
        self$`homologues` <- ApiClient$new()$deserializeObj(this_object$`homologues`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`isQuery`)) {
        self$`isQuery` <- this_object$`isQuery`
      }
      if (!is.null(this_object$`multifunctionalityRank`)) {
        self$`multifunctionalityRank` <- this_object$`multifunctionalityRank`
      }
      if (!is.null(this_object$`ncbiId`)) {
        self$`ncbiId` <- this_object$`ncbiId`
      }
      if (!is.null(this_object$`ensemblId`)) {
        self$`ensemblId` <- this_object$`ensemblId`
      }
      if (!is.null(this_object$`nodeDegreeNegRanks`)) {
        self$`nodeDegreeNegRanks` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreeNegRanks`, "array[numeric]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`nodeDegreePosRanks`)) {
        self$`nodeDegreePosRanks` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreePosRanks`, "array[numeric]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`nodeDegreesNeg`)) {
        self$`nodeDegreesNeg` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreesNeg`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`nodeDegreesPos`)) {
        self$`nodeDegreesPos` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreesPos`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`numGoTerms`)) {
        self$`numGoTerms` <- this_object$`numGoTerms`
      }
      if (!is.null(this_object$`officialName`)) {
        self$`officialName` <- this_object$`officialName`
      }
      if (!is.null(this_object$`officialSymbol`)) {
        self$`officialSymbol` <- this_object$`officialSymbol`
      }
      if (!is.null(this_object$`phenotypes`)) {
        self$`phenotypes` <- ApiClient$new()$deserializeObj(this_object$`phenotypes`, "array[CharacteristicValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`platformCount`)) {
        self$`platformCount` <- this_object$`platformCount`
      }
      if (!is.null(this_object$`score`)) {
        self$`score` <- this_object$`score`
      }
      if (!is.null(this_object$`taxonCommonName`)) {
        self$`taxonCommonName` <- this_object$`taxonCommonName`
      }
      if (!is.null(this_object$`taxonId`)) {
        self$`taxonId` <- this_object$`taxonId`
      }
      if (!is.null(this_object$`taxonScientificName`)) {
        self$`taxonScientificName` <- this_object$`taxonScientificName`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`aliases`)) {
          sprintf(
          '"aliases":
             [%s]
          ',
          paste(unlist(lapply(self$`aliases`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`associatedExperimentCount`)) {
          sprintf(
          '"associatedExperimentCount":
            %d
                    ',
          self$`associatedExperimentCount`
          )
        },
        if (!is.null(self$`compositeSequenceCount`)) {
          sprintf(
          '"compositeSequenceCount":
            %d
                    ',
          self$`compositeSequenceCount`
          )
        },
        if (!is.null(self$`geneSets`)) {
          sprintf(
          '"geneSets":
          [%s]
',
          paste(sapply(self$`geneSets`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`homologues`)) {
          sprintf(
          '"homologues":
          [%s]
',
          paste(sapply(self$`homologues`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`isQuery`)) {
          sprintf(
          '"isQuery":
            %s
                    ',
          tolower(self$`isQuery`)
          )
        },
        if (!is.null(self$`multifunctionalityRank`)) {
          sprintf(
          '"multifunctionalityRank":
            %d
                    ',
          self$`multifunctionalityRank`
          )
        },
        if (!is.null(self$`ncbiId`)) {
          sprintf(
          '"ncbiId":
            %d
                    ',
          self$`ncbiId`
          )
        },
        if (!is.null(self$`ensemblId`)) {
          sprintf(
          '"ensemblId":
            "%s"
                    ',
          self$`ensemblId`
          )
        },
        if (!is.null(self$`nodeDegreeNegRanks`)) {
          sprintf(
          '"nodeDegreeNegRanks":
             [%s]
          ',
          paste(unlist(lapply(self$`nodeDegreeNegRanks`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`nodeDegreePosRanks`)) {
          sprintf(
          '"nodeDegreePosRanks":
             [%s]
          ',
          paste(unlist(lapply(self$`nodeDegreePosRanks`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`nodeDegreesNeg`)) {
          sprintf(
          '"nodeDegreesNeg":
             [%s]
          ',
          paste(unlist(lapply(self$`nodeDegreesNeg`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`nodeDegreesPos`)) {
          sprintf(
          '"nodeDegreesPos":
             [%s]
          ',
          paste(unlist(lapply(self$`nodeDegreesPos`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`numGoTerms`)) {
          sprintf(
          '"numGoTerms":
            %d
                    ',
          self$`numGoTerms`
          )
        },
        if (!is.null(self$`officialName`)) {
          sprintf(
          '"officialName":
            "%s"
                    ',
          self$`officialName`
          )
        },
        if (!is.null(self$`officialSymbol`)) {
          sprintf(
          '"officialSymbol":
            "%s"
                    ',
          self$`officialSymbol`
          )
        },
        if (!is.null(self$`phenotypes`)) {
          sprintf(
          '"phenotypes":
          [%s]
',
          paste(sapply(self$`phenotypes`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`platformCount`)) {
          sprintf(
          '"platformCount":
            %d
                    ',
          self$`platformCount`
          )
        },
        if (!is.null(self$`score`)) {
          sprintf(
          '"score":
            %d
                    ',
          self$`score`
          )
        },
        if (!is.null(self$`taxonCommonName`)) {
          sprintf(
          '"taxonCommonName":
            "%s"
                    ',
          self$`taxonCommonName`
          )
        },
        if (!is.null(self$`taxonId`)) {
          sprintf(
          '"taxonId":
            %d
                    ',
          self$`taxonId`
          )
        },
        if (!is.null(self$`taxonScientificName`)) {
          sprintf(
          '"taxonScientificName":
            "%s"
                    ',
          self$`taxonScientificName`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`aliases` <- ApiClient$new()$deserializeObj(this_object$`aliases`, "array[character]", loadNamespace("gemma.R"))
      self$`associatedExperimentCount` <- this_object$`associatedExperimentCount`
      self$`compositeSequenceCount` <- this_object$`compositeSequenceCount`
      self$`geneSets` <- ApiClient$new()$deserializeObj(this_object$`geneSets`, "array[GeneSetValueObject]", loadNamespace("gemma.R"))
      self$`homologues` <- ApiClient$new()$deserializeObj(this_object$`homologues`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      self$`isQuery` <- this_object$`isQuery`
      self$`multifunctionalityRank` <- this_object$`multifunctionalityRank`
      self$`ncbiId` <- this_object$`ncbiId`
      self$`ensemblId` <- this_object$`ensemblId`
      self$`nodeDegreeNegRanks` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreeNegRanks`, "array[numeric]", loadNamespace("gemma.R"))
      self$`nodeDegreePosRanks` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreePosRanks`, "array[numeric]", loadNamespace("gemma.R"))
      self$`nodeDegreesNeg` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreesNeg`, "array[integer]", loadNamespace("gemma.R"))
      self$`nodeDegreesPos` <- ApiClient$new()$deserializeObj(this_object$`nodeDegreesPos`, "array[integer]", loadNamespace("gemma.R"))
      self$`numGoTerms` <- this_object$`numGoTerms`
      self$`officialName` <- this_object$`officialName`
      self$`officialSymbol` <- this_object$`officialSymbol`
      self$`phenotypes` <- ApiClient$new()$deserializeObj(this_object$`phenotypes`, "array[CharacteristicValueObject]", loadNamespace("gemma.R"))
      self$`platformCount` <- this_object$`platformCount`
      self$`score` <- this_object$`score`
      self$`taxonCommonName` <- this_object$`taxonCommonName`
      self$`taxonId` <- this_object$`taxonId`
      self$`taxonScientificName` <- this_object$`taxonScientificName`
      self
    },
    #' Validate JSON input with respect to GeneValueObject
    #'
    #' @description
    #' Validate JSON input with respect to GeneValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneValueObject$lock()


#' Create a new GeneralType
#'
#' @description
#' GeneralType Class
#'
#' @docType class
#' @title GeneralType
#' @description GeneralType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GeneralType <- R6::R6Class(
  "GeneralType",
  public = list(
    `value` = NULL,
    #' Initialize a new GeneralType class.
    #'
    #' @description
    #' Initialize a new GeneralType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneralType in JSON format
    #' @keywords internal
    toJSON = function() {
      GeneralTypeObject <- list()
      if (!is.null(self$`value`)) {
        GeneralTypeObject[["value"]] <-
          self$`value`
      }
      GeneralTypeObject
    },
    #' Deserialize JSON string into an instance of GeneralType
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneralType
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneralType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GeneralType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GeneralType
    #'
    #' @description
    #' Deserialize JSON string into an instance of GeneralType
    #'
    #' @param input_json the JSON input
    #' @return the instance of GeneralType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to GeneralType
    #'
    #' @description
    #' Validate JSON input with respect to GeneralType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GeneralType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GeneralType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GeneralType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GeneralType$lock()


#' @docType class
#' @title GetDatasetExpressionForGenesGenesParameterInner
#'
#' @description GetDatasetExpressionForGenesGenesParameterInner Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GetDatasetExpressionForGenesGenesParameterInner <- R6::R6Class(
  "GetDatasetExpressionForGenesGenesParameterInner",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character"),
    #' Initialize a new GetDatasetExpressionForGenesGenesParameterInner.
    #'
    #' @description
    #' Initialize a new GetDatasetExpressionForGenesGenesParameterInner.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else {
        stop(paste("Failed to initialize GetDatasetExpressionForGenesGenesParameterInner with oneOf schemas character. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of GetDatasetExpressionForGenesGenesParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetDatasetExpressionForGenesGenesParameterInner.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of GetDatasetExpressionForGenesGenesParameterInner.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of GetDatasetExpressionForGenesGenesParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetDatasetExpressionForGenesGenesParameterInner.
    #'
    #' @param input The input JSON.
    #' @return An instance of GetDatasetExpressionForGenesGenesParameterInner.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into GetDatasetExpressionForGenesGenesParameterInner with oneOf schemas character.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into GetDatasetExpressionForGenesGenesParameterInner with oneOf schemas character. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize GetDatasetExpressionForGenesGenesParameterInner to JSON string.
    #'
    #' @description
    #' Serialize GetDatasetExpressionForGenesGenesParameterInner to JSON string.
    #'
    #' @return JSON string representation of the GetDatasetExpressionForGenesGenesParameterInner.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize GetDatasetExpressionForGenesGenesParameterInner to JSON.
    #'
    #' @description
    #' Serialize GetDatasetExpressionForGenesGenesParameterInner to JSON.
    #'
    #' @return JSON representation of the GetDatasetExpressionForGenesGenesParameterInner.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to GetDatasetExpressionForGenesGenesParameterInner.
    #'
    #' @description
    #' Validate the input JSON with respect to GetDatasetExpressionForGenesGenesParameterInner and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GetDatasetExpressionForGenesGenesParameterInner$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GetDatasetExpressionForGenesGenesParameterInner$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GetDatasetExpressionForGenesGenesParameterInner$lock()


#' @docType class
#' @title GetPlatformAnnotationsPlatformParameter
#'
#' @description GetPlatformAnnotationsPlatformParameter Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GetPlatformAnnotationsPlatformParameter <- R6::R6Class(
  "GetPlatformAnnotationsPlatformParameter",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new GetPlatformAnnotationsPlatformParameter.
    #'
    #' @description
    #' Initialize a new GetPlatformAnnotationsPlatformParameter.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize GetPlatformAnnotationsPlatformParameter with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of GetPlatformAnnotationsPlatformParameter.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetPlatformAnnotationsPlatformParameter.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of GetPlatformAnnotationsPlatformParameter.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of GetPlatformAnnotationsPlatformParameter.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetPlatformAnnotationsPlatformParameter.
    #'
    #' @param input The input JSON.
    #' @return An instance of GetPlatformAnnotationsPlatformParameter.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into GetPlatformAnnotationsPlatformParameter with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into GetPlatformAnnotationsPlatformParameter with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize GetPlatformAnnotationsPlatformParameter to JSON string.
    #'
    #' @description
    #' Serialize GetPlatformAnnotationsPlatformParameter to JSON string.
    #'
    #' @return JSON string representation of the GetPlatformAnnotationsPlatformParameter.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize GetPlatformAnnotationsPlatformParameter to JSON.
    #'
    #' @description
    #' Serialize GetPlatformAnnotationsPlatformParameter to JSON.
    #'
    #' @return JSON representation of the GetPlatformAnnotationsPlatformParameter.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to GetPlatformAnnotationsPlatformParameter.
    #'
    #' @description
    #' Validate the input JSON with respect to GetPlatformAnnotationsPlatformParameter and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GetPlatformAnnotationsPlatformParameter$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GetPlatformAnnotationsPlatformParameter$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GetPlatformAnnotationsPlatformParameter$lock()


#' @docType class
#' @title GetPlatformElementProbesParameterInner
#'
#' @description GetPlatformElementProbesParameterInner Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GetPlatformElementProbesParameterInner <- R6::R6Class(
  "GetPlatformElementProbesParameterInner",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new GetPlatformElementProbesParameterInner.
    #'
    #' @description
    #' Initialize a new GetPlatformElementProbesParameterInner.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize GetPlatformElementProbesParameterInner with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of GetPlatformElementProbesParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetPlatformElementProbesParameterInner.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of GetPlatformElementProbesParameterInner.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of GetPlatformElementProbesParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetPlatformElementProbesParameterInner.
    #'
    #' @param input The input JSON.
    #' @return An instance of GetPlatformElementProbesParameterInner.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into GetPlatformElementProbesParameterInner with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into GetPlatformElementProbesParameterInner with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize GetPlatformElementProbesParameterInner to JSON string.
    #'
    #' @description
    #' Serialize GetPlatformElementProbesParameterInner to JSON string.
    #'
    #' @return JSON string representation of the GetPlatformElementProbesParameterInner.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize GetPlatformElementProbesParameterInner to JSON.
    #'
    #' @description
    #' Serialize GetPlatformElementProbesParameterInner to JSON.
    #'
    #' @return JSON representation of the GetPlatformElementProbesParameterInner.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to GetPlatformElementProbesParameterInner.
    #'
    #' @description
    #' Validate the input JSON with respect to GetPlatformElementProbesParameterInner and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GetPlatformElementProbesParameterInner$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GetPlatformElementProbesParameterInner$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GetPlatformElementProbesParameterInner$lock()


#' @docType class
#' @title GetResultSetsDatabaseEntriesParameterInner
#'
#' @description GetResultSetsDatabaseEntriesParameterInner Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GetResultSetsDatabaseEntriesParameterInner <- R6::R6Class(
  "GetResultSetsDatabaseEntriesParameterInner",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new GetResultSetsDatabaseEntriesParameterInner.
    #'
    #' @description
    #' Initialize a new GetResultSetsDatabaseEntriesParameterInner.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize GetResultSetsDatabaseEntriesParameterInner with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of GetResultSetsDatabaseEntriesParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetResultSetsDatabaseEntriesParameterInner.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of GetResultSetsDatabaseEntriesParameterInner.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of GetResultSetsDatabaseEntriesParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetResultSetsDatabaseEntriesParameterInner.
    #'
    #' @param input The input JSON.
    #' @return An instance of GetResultSetsDatabaseEntriesParameterInner.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into GetResultSetsDatabaseEntriesParameterInner with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into GetResultSetsDatabaseEntriesParameterInner with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize GetResultSetsDatabaseEntriesParameterInner to JSON string.
    #'
    #' @description
    #' Serialize GetResultSetsDatabaseEntriesParameterInner to JSON string.
    #'
    #' @return JSON string representation of the GetResultSetsDatabaseEntriesParameterInner.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize GetResultSetsDatabaseEntriesParameterInner to JSON.
    #'
    #' @description
    #' Serialize GetResultSetsDatabaseEntriesParameterInner to JSON.
    #'
    #' @return JSON representation of the GetResultSetsDatabaseEntriesParameterInner.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to GetResultSetsDatabaseEntriesParameterInner.
    #'
    #' @description
    #' Validate the input JSON with respect to GetResultSetsDatabaseEntriesParameterInner and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GetResultSetsDatabaseEntriesParameterInner$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GetResultSetsDatabaseEntriesParameterInner$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GetResultSetsDatabaseEntriesParameterInner$lock()


#' @docType class
#' @title GetResultSetsDatasetsParameterInner
#'
#' @description GetResultSetsDatasetsParameterInner Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GetResultSetsDatasetsParameterInner <- R6::R6Class(
  "GetResultSetsDatasetsParameterInner",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new GetResultSetsDatasetsParameterInner.
    #'
    #' @description
    #' Initialize a new GetResultSetsDatasetsParameterInner.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize GetResultSetsDatasetsParameterInner with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of GetResultSetsDatasetsParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetResultSetsDatasetsParameterInner.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of GetResultSetsDatasetsParameterInner.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of GetResultSetsDatasetsParameterInner.
    #'
    #' @description
    #' Deserialize JSON string into an instance of GetResultSetsDatasetsParameterInner.
    #'
    #' @param input The input JSON.
    #' @return An instance of GetResultSetsDatasetsParameterInner.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into GetResultSetsDatasetsParameterInner with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into GetResultSetsDatasetsParameterInner with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize GetResultSetsDatasetsParameterInner to JSON string.
    #'
    #' @description
    #' Serialize GetResultSetsDatasetsParameterInner to JSON string.
    #'
    #' @return JSON string representation of the GetResultSetsDatasetsParameterInner.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize GetResultSetsDatasetsParameterInner to JSON.
    #'
    #' @description
    #' Serialize GetResultSetsDatasetsParameterInner to JSON.
    #'
    #' @return JSON representation of the GetResultSetsDatasetsParameterInner.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to GetResultSetsDatasetsParameterInner.
    #'
    #' @description
    #' Validate the input JSON with respect to GetResultSetsDatasetsParameterInner and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GetResultSetsDatasetsParameterInner$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GetResultSetsDatasetsParameterInner$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GetResultSetsDatasetsParameterInner$lock()


#' Create a new GOEvidenceCode
#'
#' @description
#' GOEvidenceCode Class
#'
#' @docType class
#' @title GOEvidenceCode
#' @description GOEvidenceCode Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
GOEvidenceCode <- R6::R6Class(
  "GOEvidenceCode",
  public = list(
    `value` = NULL,
    #' Initialize a new GOEvidenceCode class.
    #'
    #' @description
    #' Initialize a new GOEvidenceCode class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GOEvidenceCode in JSON format
    #' @keywords internal
    toJSON = function() {
      GOEvidenceCodeObject <- list()
      if (!is.null(self$`value`)) {
        GOEvidenceCodeObject[["value"]] <-
          self$`value`
      }
      GOEvidenceCodeObject
    },
    #' Deserialize JSON string into an instance of GOEvidenceCode
    #'
    #' @description
    #' Deserialize JSON string into an instance of GOEvidenceCode
    #'
    #' @param input_json the JSON input
    #' @return the instance of GOEvidenceCode
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return GOEvidenceCode in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of GOEvidenceCode
    #'
    #' @description
    #' Deserialize JSON string into an instance of GOEvidenceCode
    #'
    #' @param input_json the JSON input
    #' @return the instance of GOEvidenceCode
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to GOEvidenceCode
    #'
    #' @description
    #' Validate JSON input with respect to GOEvidenceCode and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of GOEvidenceCode
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
GOEvidenceCode$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
GOEvidenceCode$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
GOEvidenceCode$lock()


#' Create a new IdentifiableValueObject
#'
#' @description
#' IdentifiableValueObject Class
#'
#' @docType class
#' @title IdentifiableValueObject
#' @description IdentifiableValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
IdentifiableValueObject <- R6::R6Class(
  "IdentifiableValueObject",
  public = list(
    `id` = NULL,
    #' Initialize a new IdentifiableValueObject class.
    #'
    #' @description
    #' Initialize a new IdentifiableValueObject class.
    #'
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return IdentifiableValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      IdentifiableValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        IdentifiableValueObjectObject[["id"]] <-
          self$`id`
      }
      IdentifiableValueObjectObject
    },
    #' Deserialize JSON string into an instance of IdentifiableValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of IdentifiableValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of IdentifiableValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return IdentifiableValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of IdentifiableValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of IdentifiableValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of IdentifiableValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to IdentifiableValueObject
    #'
    #' @description
    #' Validate JSON input with respect to IdentifiableValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of IdentifiableValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
IdentifiableValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
IdentifiableValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
IdentifiableValueObject$lock()


#' Create a new IdentifiableValueObjectIdentifiable
#'
#' @description
#' IdentifiableValueObjectIdentifiable Class
#'
#' @docType class
#' @title IdentifiableValueObjectIdentifiable
#' @description IdentifiableValueObjectIdentifiable Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
IdentifiableValueObjectIdentifiable <- R6::R6Class(
  "IdentifiableValueObjectIdentifiable",
  public = list(
    `id` = NULL,
    #' Initialize a new IdentifiableValueObjectIdentifiable class.
    #'
    #' @description
    #' Initialize a new IdentifiableValueObjectIdentifiable class.
    #'
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return IdentifiableValueObjectIdentifiable in JSON format
    #' @keywords internal
    toJSON = function() {
      IdentifiableValueObjectIdentifiableObject <- list()
      if (!is.null(self$`id`)) {
        IdentifiableValueObjectIdentifiableObject[["id"]] <-
          self$`id`
      }
      IdentifiableValueObjectIdentifiableObject
    },
    #' Deserialize JSON string into an instance of IdentifiableValueObjectIdentifiable
    #'
    #' @description
    #' Deserialize JSON string into an instance of IdentifiableValueObjectIdentifiable
    #'
    #' @param input_json the JSON input
    #' @return the instance of IdentifiableValueObjectIdentifiable
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return IdentifiableValueObjectIdentifiable in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of IdentifiableValueObjectIdentifiable
    #'
    #' @description
    #' Deserialize JSON string into an instance of IdentifiableValueObjectIdentifiable
    #'
    #' @param input_json the JSON input
    #' @return the instance of IdentifiableValueObjectIdentifiable
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to IdentifiableValueObjectIdentifiable
    #'
    #' @description
    #' Validate JSON input with respect to IdentifiableValueObjectIdentifiable and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of IdentifiableValueObjectIdentifiable
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
IdentifiableValueObjectIdentifiable$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
IdentifiableValueObjectIdentifiable$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
IdentifiableValueObjectIdentifiable$lock()


#' Create a new JobInfo
#'
#' @description
#' JobInfo Class
#'
#' @docType class
#' @title JobInfo
#' @description JobInfo Class
#' @format An \code{R6Class} generator object
#' @field runningStatus  character optional
#' @field failedMessage  character optional
#' @field startTime  character optional
#' @field endTime  character optional
#' @field phases  integer optional
#' @field description  character optional
#' @field messages  character optional
#' @field taskId  character optional
#' @field id  integer optional
#' @field user  \link{User} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
JobInfo <- R6::R6Class(
  "JobInfo",
  public = list(
    `runningStatus` = NULL,
    `failedMessage` = NULL,
    `startTime` = NULL,
    `endTime` = NULL,
    `phases` = NULL,
    `description` = NULL,
    `messages` = NULL,
    `taskId` = NULL,
    `id` = NULL,
    `user` = NULL,
    #' Initialize a new JobInfo class.
    #'
    #' @description
    #' Initialize a new JobInfo class.
    #'
    #' @param runningStatus runningStatus
    #' @param failedMessage failedMessage
    #' @param startTime startTime
    #' @param endTime endTime
    #' @param phases phases
    #' @param description description
    #' @param messages messages
    #' @param taskId taskId
    #' @param id id
    #' @param user user
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `runningStatus` = NULL, `failedMessage` = NULL, `startTime` = NULL, `endTime` = NULL, `phases` = NULL, `description` = NULL, `messages` = NULL, `taskId` = NULL, `id` = NULL, `user` = NULL, ...
    ) {
      if (!is.null(`runningStatus`)) {
        stopifnot(is.logical(`runningStatus`), length(`runningStatus`) == 1)
        self$`runningStatus` <- `runningStatus`
      }
      if (!is.null(`failedMessage`)) {
        stopifnot(is.character(`failedMessage`), length(`failedMessage`) == 1)
        self$`failedMessage` <- `failedMessage`
      }
      if (!is.null(`startTime`)) {
        stopifnot(is.character(`startTime`), length(`startTime`) == 1)
        self$`startTime` <- `startTime`
      }
      if (!is.null(`endTime`)) {
        stopifnot(is.character(`endTime`), length(`endTime`) == 1)
        self$`endTime` <- `endTime`
      }
      if (!is.null(`phases`)) {
        stopifnot(is.numeric(`phases`), length(`phases`) == 1)
        self$`phases` <- `phases`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`messages`)) {
        stopifnot(is.character(`messages`), length(`messages`) == 1)
        self$`messages` <- `messages`
      }
      if (!is.null(`taskId`)) {
        stopifnot(is.character(`taskId`), length(`taskId`) == 1)
        self$`taskId` <- `taskId`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`user`)) {
        stopifnot(R6::is.R6(`user`))
        self$`user` <- `user`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return JobInfo in JSON format
    #' @keywords internal
    toJSON = function() {
      JobInfoObject <- list()
      if (!is.null(self$`runningStatus`)) {
        JobInfoObject[["runningStatus"]] <-
          self$`runningStatus`
      }
      if (!is.null(self$`failedMessage`)) {
        JobInfoObject[["failedMessage"]] <-
          self$`failedMessage`
      }
      if (!is.null(self$`startTime`)) {
        JobInfoObject[["startTime"]] <-
          self$`startTime`
      }
      if (!is.null(self$`endTime`)) {
        JobInfoObject[["endTime"]] <-
          self$`endTime`
      }
      if (!is.null(self$`phases`)) {
        JobInfoObject[["phases"]] <-
          self$`phases`
      }
      if (!is.null(self$`description`)) {
        JobInfoObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`messages`)) {
        JobInfoObject[["messages"]] <-
          self$`messages`
      }
      if (!is.null(self$`taskId`)) {
        JobInfoObject[["taskId"]] <-
          self$`taskId`
      }
      if (!is.null(self$`id`)) {
        JobInfoObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`user`)) {
        JobInfoObject[["user"]] <-
          self$`user`$toJSON()
      }
      JobInfoObject
    },
    #' Deserialize JSON string into an instance of JobInfo
    #'
    #' @description
    #' Deserialize JSON string into an instance of JobInfo
    #'
    #' @param input_json the JSON input
    #' @return the instance of JobInfo
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`runningStatus`)) {
        self$`runningStatus` <- this_object$`runningStatus`
      }
      if (!is.null(this_object$`failedMessage`)) {
        self$`failedMessage` <- this_object$`failedMessage`
      }
      if (!is.null(this_object$`startTime`)) {
        self$`startTime` <- this_object$`startTime`
      }
      if (!is.null(this_object$`endTime`)) {
        self$`endTime` <- this_object$`endTime`
      }
      if (!is.null(this_object$`phases`)) {
        self$`phases` <- this_object$`phases`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`messages`)) {
        self$`messages` <- this_object$`messages`
      }
      if (!is.null(this_object$`taskId`)) {
        self$`taskId` <- this_object$`taskId`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`user`)) {
        user_object <- User$new()
        user_object$fromJSON(jsonlite::toJSON(this_object$user, auto_unbox = TRUE, digits = NA))
        self$`user` <- user_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return JobInfo in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`runningStatus`)) {
          sprintf(
          '"runningStatus":
            %s
                    ',
          tolower(self$`runningStatus`)
          )
        },
        if (!is.null(self$`failedMessage`)) {
          sprintf(
          '"failedMessage":
            "%s"
                    ',
          self$`failedMessage`
          )
        },
        if (!is.null(self$`startTime`)) {
          sprintf(
          '"startTime":
            "%s"
                    ',
          self$`startTime`
          )
        },
        if (!is.null(self$`endTime`)) {
          sprintf(
          '"endTime":
            "%s"
                    ',
          self$`endTime`
          )
        },
        if (!is.null(self$`phases`)) {
          sprintf(
          '"phases":
            %d
                    ',
          self$`phases`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`messages`)) {
          sprintf(
          '"messages":
            "%s"
                    ',
          self$`messages`
          )
        },
        if (!is.null(self$`taskId`)) {
          sprintf(
          '"taskId":
            "%s"
                    ',
          self$`taskId`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`user`)) {
          sprintf(
          '"user":
          %s
          ',
          jsonlite::toJSON(self$`user`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of JobInfo
    #'
    #' @description
    #' Deserialize JSON string into an instance of JobInfo
    #'
    #' @param input_json the JSON input
    #' @return the instance of JobInfo
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`runningStatus` <- this_object$`runningStatus`
      self$`failedMessage` <- this_object$`failedMessage`
      self$`startTime` <- this_object$`startTime`
      self$`endTime` <- this_object$`endTime`
      self$`phases` <- this_object$`phases`
      self$`description` <- this_object$`description`
      self$`messages` <- this_object$`messages`
      self$`taskId` <- this_object$`taskId`
      self$`id` <- this_object$`id`
      self$`user` <- User$new()$fromJSON(jsonlite::toJSON(this_object$user, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to JobInfo
    #'
    #' @description
    #' Validate JSON input with respect to JobInfo and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of JobInfo
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
JobInfo$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
JobInfo$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
JobInfo$lock()


#' Create a new Keyword
#'
#' @description
#' Keyword Class
#'
#' @docType class
#' @title Keyword
#' @description Keyword Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field isMajorTopic  character optional
#' @field term  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Keyword <- R6::R6Class(
  "Keyword",
  public = list(
    `id` = NULL,
    `isMajorTopic` = NULL,
    `term` = NULL,
    #' Initialize a new Keyword class.
    #'
    #' @description
    #' Initialize a new Keyword class.
    #'
    #' @param id id
    #' @param isMajorTopic isMajorTopic
    #' @param term term
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `isMajorTopic` = NULL, `term` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`isMajorTopic`)) {
        stopifnot(is.logical(`isMajorTopic`), length(`isMajorTopic`) == 1)
        self$`isMajorTopic` <- `isMajorTopic`
      }
      if (!is.null(`term`)) {
        stopifnot(is.character(`term`), length(`term`) == 1)
        self$`term` <- `term`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Keyword in JSON format
    #' @keywords internal
    toJSON = function() {
      KeywordObject <- list()
      if (!is.null(self$`id`)) {
        KeywordObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`isMajorTopic`)) {
        KeywordObject[["isMajorTopic"]] <-
          self$`isMajorTopic`
      }
      if (!is.null(self$`term`)) {
        KeywordObject[["term"]] <-
          self$`term`
      }
      KeywordObject
    },
    #' Deserialize JSON string into an instance of Keyword
    #'
    #' @description
    #' Deserialize JSON string into an instance of Keyword
    #'
    #' @param input_json the JSON input
    #' @return the instance of Keyword
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`isMajorTopic`)) {
        self$`isMajorTopic` <- this_object$`isMajorTopic`
      }
      if (!is.null(this_object$`term`)) {
        self$`term` <- this_object$`term`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Keyword in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`isMajorTopic`)) {
          sprintf(
          '"isMajorTopic":
            %s
                    ',
          tolower(self$`isMajorTopic`)
          )
        },
        if (!is.null(self$`term`)) {
          sprintf(
          '"term":
            "%s"
                    ',
          self$`term`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Keyword
    #'
    #' @description
    #' Deserialize JSON string into an instance of Keyword
    #'
    #' @param input_json the JSON input
    #' @return the instance of Keyword
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`isMajorTopic` <- this_object$`isMajorTopic`
      self$`term` <- this_object$`term`
      self
    },
    #' Validate JSON input with respect to Keyword
    #'
    #' @description
    #' Validate JSON input with respect to Keyword and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Keyword
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Keyword$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Keyword$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Keyword$lock()


#' Create a new MeasurementValueObject
#'
#' @description
#' MeasurementValueObject Class
#'
#' @docType class
#' @title MeasurementValueObject
#' @description MeasurementValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field value  character optional
#' @field unit  character optional
#' @field unitId  integer optional
#' @field type  character optional
#' @field representation  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
MeasurementValueObject <- R6::R6Class(
  "MeasurementValueObject",
  public = list(
    `id` = NULL,
    `value` = NULL,
    `unit` = NULL,
    `unitId` = NULL,
    `type` = NULL,
    `representation` = NULL,
    #' Initialize a new MeasurementValueObject class.
    #'
    #' @description
    #' Initialize a new MeasurementValueObject class.
    #'
    #' @param id id
    #' @param value value
    #' @param unit unit
    #' @param unitId unitId
    #' @param type type
    #' @param representation representation
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `value` = NULL, `unit` = NULL, `unitId` = NULL, `type` = NULL, `representation` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
      if (!is.null(`unit`)) {
        stopifnot(is.character(`unit`), length(`unit`) == 1)
        self$`unit` <- `unit`
      }
      if (!is.null(`unitId`)) {
        stopifnot(is.numeric(`unitId`), length(`unitId`) == 1)
        self$`unitId` <- `unitId`
      }
      if (!is.null(`type`)) {
        stopifnot(is.character(`type`), length(`type`) == 1)
        self$`type` <- `type`
      }
      if (!is.null(`representation`)) {
        stopifnot(is.character(`representation`), length(`representation`) == 1)
        self$`representation` <- `representation`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return MeasurementValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      MeasurementValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        MeasurementValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`value`)) {
        MeasurementValueObjectObject[["value"]] <-
          self$`value`
      }
      if (!is.null(self$`unit`)) {
        MeasurementValueObjectObject[["unit"]] <-
          self$`unit`
      }
      if (!is.null(self$`unitId`)) {
        MeasurementValueObjectObject[["unitId"]] <-
          self$`unitId`
      }
      if (!is.null(self$`type`)) {
        MeasurementValueObjectObject[["type"]] <-
          self$`type`
      }
      if (!is.null(self$`representation`)) {
        MeasurementValueObjectObject[["representation"]] <-
          self$`representation`
      }
      MeasurementValueObjectObject
    },
    #' Deserialize JSON string into an instance of MeasurementValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of MeasurementValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of MeasurementValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      if (!is.null(this_object$`unit`)) {
        self$`unit` <- this_object$`unit`
      }
      if (!is.null(this_object$`unitId`)) {
        self$`unitId` <- this_object$`unitId`
      }
      if (!is.null(this_object$`type`)) {
        self$`type` <- this_object$`type`
      }
      if (!is.null(this_object$`representation`)) {
        self$`representation` <- this_object$`representation`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return MeasurementValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        },
        if (!is.null(self$`unit`)) {
          sprintf(
          '"unit":
            "%s"
                    ',
          self$`unit`
          )
        },
        if (!is.null(self$`unitId`)) {
          sprintf(
          '"unitId":
            %d
                    ',
          self$`unitId`
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
          '"type":
            "%s"
                    ',
          self$`type`
          )
        },
        if (!is.null(self$`representation`)) {
          sprintf(
          '"representation":
            "%s"
                    ',
          self$`representation`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of MeasurementValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of MeasurementValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of MeasurementValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`value` <- this_object$`value`
      self$`unit` <- this_object$`unit`
      self$`unitId` <- this_object$`unitId`
      self$`type` <- this_object$`type`
      self$`representation` <- this_object$`representation`
      self
    },
    #' Validate JSON input with respect to MeasurementValueObject
    #'
    #' @description
    #' Validate JSON input with respect to MeasurementValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of MeasurementValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
MeasurementValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
MeasurementValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
MeasurementValueObject$lock()


#' Create a new MedicalSubjectHeading
#'
#' @description
#' MedicalSubjectHeading Class
#'
#' @docType class
#' @title MedicalSubjectHeading
#' @description MedicalSubjectHeading Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field isMajorTopic  character optional
#' @field term  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
MedicalSubjectHeading <- R6::R6Class(
  "MedicalSubjectHeading",
  public = list(
    `id` = NULL,
    `isMajorTopic` = NULL,
    `term` = NULL,
    #' Initialize a new MedicalSubjectHeading class.
    #'
    #' @description
    #' Initialize a new MedicalSubjectHeading class.
    #'
    #' @param id id
    #' @param isMajorTopic isMajorTopic
    #' @param term term
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `isMajorTopic` = NULL, `term` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`isMajorTopic`)) {
        stopifnot(is.logical(`isMajorTopic`), length(`isMajorTopic`) == 1)
        self$`isMajorTopic` <- `isMajorTopic`
      }
      if (!is.null(`term`)) {
        stopifnot(is.character(`term`), length(`term`) == 1)
        self$`term` <- `term`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return MedicalSubjectHeading in JSON format
    #' @keywords internal
    toJSON = function() {
      MedicalSubjectHeadingObject <- list()
      if (!is.null(self$`id`)) {
        MedicalSubjectHeadingObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`isMajorTopic`)) {
        MedicalSubjectHeadingObject[["isMajorTopic"]] <-
          self$`isMajorTopic`
      }
      if (!is.null(self$`term`)) {
        MedicalSubjectHeadingObject[["term"]] <-
          self$`term`
      }
      MedicalSubjectHeadingObject
    },
    #' Deserialize JSON string into an instance of MedicalSubjectHeading
    #'
    #' @description
    #' Deserialize JSON string into an instance of MedicalSubjectHeading
    #'
    #' @param input_json the JSON input
    #' @return the instance of MedicalSubjectHeading
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`isMajorTopic`)) {
        self$`isMajorTopic` <- this_object$`isMajorTopic`
      }
      if (!is.null(this_object$`term`)) {
        self$`term` <- this_object$`term`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return MedicalSubjectHeading in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`isMajorTopic`)) {
          sprintf(
          '"isMajorTopic":
            %s
                    ',
          tolower(self$`isMajorTopic`)
          )
        },
        if (!is.null(self$`term`)) {
          sprintf(
          '"term":
            "%s"
                    ',
          self$`term`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of MedicalSubjectHeading
    #'
    #' @description
    #' Deserialize JSON string into an instance of MedicalSubjectHeading
    #'
    #' @param input_json the JSON input
    #' @return the instance of MedicalSubjectHeading
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`isMajorTopic` <- this_object$`isMajorTopic`
      self$`term` <- this_object$`term`
      self
    },
    #' Validate JSON input with respect to MedicalSubjectHeading
    #'
    #' @description
    #' Validate JSON input with respect to MedicalSubjectHeading and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of MedicalSubjectHeading
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
MedicalSubjectHeading$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
MedicalSubjectHeading$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
MedicalSubjectHeading$lock()


#' Create a new Multifunctionality
#'
#' @description
#' Multifunctionality Class
#'
#' @docType class
#' @title Multifunctionality
#' @description Multifunctionality Class
#' @format An \code{R6Class} generator object
#' @field score  numeric optional
#' @field rank  numeric optional
#' @field numGoTerms  integer optional
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Multifunctionality <- R6::R6Class(
  "Multifunctionality",
  public = list(
    `score` = NULL,
    `rank` = NULL,
    `numGoTerms` = NULL,
    `id` = NULL,
    #' Initialize a new Multifunctionality class.
    #'
    #' @description
    #' Initialize a new Multifunctionality class.
    #'
    #' @param score score
    #' @param rank rank
    #' @param numGoTerms numGoTerms
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `score` = NULL, `rank` = NULL, `numGoTerms` = NULL, `id` = NULL, ...
    ) {
      if (!is.null(`score`)) {
        stopifnot(is.numeric(`score`), length(`score`) == 1)
        self$`score` <- `score`
      }
      if (!is.null(`rank`)) {
        stopifnot(is.numeric(`rank`), length(`rank`) == 1)
        self$`rank` <- `rank`
      }
      if (!is.null(`numGoTerms`)) {
        stopifnot(is.numeric(`numGoTerms`), length(`numGoTerms`) == 1)
        self$`numGoTerms` <- `numGoTerms`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Multifunctionality in JSON format
    #' @keywords internal
    toJSON = function() {
      MultifunctionalityObject <- list()
      if (!is.null(self$`score`)) {
        MultifunctionalityObject[["score"]] <-
          self$`score`
      }
      if (!is.null(self$`rank`)) {
        MultifunctionalityObject[["rank"]] <-
          self$`rank`
      }
      if (!is.null(self$`numGoTerms`)) {
        MultifunctionalityObject[["numGoTerms"]] <-
          self$`numGoTerms`
      }
      if (!is.null(self$`id`)) {
        MultifunctionalityObject[["id"]] <-
          self$`id`
      }
      MultifunctionalityObject
    },
    #' Deserialize JSON string into an instance of Multifunctionality
    #'
    #' @description
    #' Deserialize JSON string into an instance of Multifunctionality
    #'
    #' @param input_json the JSON input
    #' @return the instance of Multifunctionality
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`score`)) {
        self$`score` <- this_object$`score`
      }
      if (!is.null(this_object$`rank`)) {
        self$`rank` <- this_object$`rank`
      }
      if (!is.null(this_object$`numGoTerms`)) {
        self$`numGoTerms` <- this_object$`numGoTerms`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Multifunctionality in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`score`)) {
          sprintf(
          '"score":
            %d
                    ',
          self$`score`
          )
        },
        if (!is.null(self$`rank`)) {
          sprintf(
          '"rank":
            %d
                    ',
          self$`rank`
          )
        },
        if (!is.null(self$`numGoTerms`)) {
          sprintf(
          '"numGoTerms":
            %d
                    ',
          self$`numGoTerms`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Multifunctionality
    #'
    #' @description
    #' Deserialize JSON string into an instance of Multifunctionality
    #'
    #' @param input_json the JSON input
    #' @return the instance of Multifunctionality
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`score` <- this_object$`score`
      self$`rank` <- this_object$`rank`
      self$`numGoTerms` <- this_object$`numGoTerms`
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to Multifunctionality
    #'
    #' @description
    #' Validate JSON input with respect to Multifunctionality and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Multifunctionality
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Multifunctionality$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Multifunctionality$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Multifunctionality$lock()


#' Create a new PaginatedResponseDataObjectArrayDesignValueObject
#'
#' @description
#' PaginatedResponseDataObjectArrayDesignValueObject Class
#'
#' @docType class
#' @title PaginatedResponseDataObjectArrayDesignValueObject
#' @description PaginatedResponseDataObjectArrayDesignValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{ArrayDesignValueObject}) optional
#' @field offset  integer optional
#' @field limit  integer optional
#' @field sort  \link{SortValueObject} optional
#' @field totalElements  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PaginatedResponseDataObjectArrayDesignValueObject <- R6::R6Class(
  "PaginatedResponseDataObjectArrayDesignValueObject",
  public = list(
    `data` = NULL,
    `offset` = NULL,
    `limit` = NULL,
    `sort` = NULL,
    `totalElements` = NULL,
    #' Initialize a new PaginatedResponseDataObjectArrayDesignValueObject class.
    #'
    #' @description
    #' Initialize a new PaginatedResponseDataObjectArrayDesignValueObject class.
    #'
    #' @param data data
    #' @param offset offset
    #' @param limit limit
    #' @param sort sort
    #' @param totalElements totalElements
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, `offset` = NULL, `limit` = NULL, `sort` = NULL, `totalElements` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
      if (!is.null(`offset`)) {
        stopifnot(is.numeric(`offset`), length(`offset`) == 1)
        self$`offset` <- `offset`
      }
      if (!is.null(`limit`)) {
        stopifnot(is.numeric(`limit`), length(`limit`) == 1)
        self$`limit` <- `limit`
      }
      if (!is.null(`sort`)) {
        stopifnot(R6::is.R6(`sort`))
        self$`sort` <- `sort`
      }
      if (!is.null(`totalElements`)) {
        stopifnot(is.numeric(`totalElements`), length(`totalElements`) == 1)
        self$`totalElements` <- `totalElements`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectArrayDesignValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      PaginatedResponseDataObjectArrayDesignValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        PaginatedResponseDataObjectArrayDesignValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      if (!is.null(self$`offset`)) {
        PaginatedResponseDataObjectArrayDesignValueObjectObject[["offset"]] <-
          self$`offset`
      }
      if (!is.null(self$`limit`)) {
        PaginatedResponseDataObjectArrayDesignValueObjectObject[["limit"]] <-
          self$`limit`
      }
      if (!is.null(self$`sort`)) {
        PaginatedResponseDataObjectArrayDesignValueObjectObject[["sort"]] <-
          self$`sort`$toJSON()
      }
      if (!is.null(self$`totalElements`)) {
        PaginatedResponseDataObjectArrayDesignValueObjectObject[["totalElements"]] <-
          self$`totalElements`
      }
      PaginatedResponseDataObjectArrayDesignValueObjectObject
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectArrayDesignValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectArrayDesignValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectArrayDesignValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ArrayDesignValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`offset`)) {
        self$`offset` <- this_object$`offset`
      }
      if (!is.null(this_object$`limit`)) {
        self$`limit` <- this_object$`limit`
      }
      if (!is.null(this_object$`sort`)) {
        sort_object <- SortValueObject$new()
        sort_object$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
        self$`sort` <- sort_object
      }
      if (!is.null(this_object$`totalElements`)) {
        self$`totalElements` <- this_object$`totalElements`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectArrayDesignValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`offset`)) {
          sprintf(
          '"offset":
            %d
                    ',
          self$`offset`
          )
        },
        if (!is.null(self$`limit`)) {
          sprintf(
          '"limit":
            %d
                    ',
          self$`limit`
          )
        },
        if (!is.null(self$`sort`)) {
          sprintf(
          '"sort":
          %s
          ',
          jsonlite::toJSON(self$`sort`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`totalElements`)) {
          sprintf(
          '"totalElements":
            %d
                    ',
          self$`totalElements`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectArrayDesignValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectArrayDesignValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectArrayDesignValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ArrayDesignValueObject]", loadNamespace("gemma.R"))
      self$`offset` <- this_object$`offset`
      self$`limit` <- this_object$`limit`
      self$`sort` <- SortValueObject$new()$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
      self$`totalElements` <- this_object$`totalElements`
      self
    },
    #' Validate JSON input with respect to PaginatedResponseDataObjectArrayDesignValueObject
    #'
    #' @description
    #' Validate JSON input with respect to PaginatedResponseDataObjectArrayDesignValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PaginatedResponseDataObjectArrayDesignValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PaginatedResponseDataObjectArrayDesignValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PaginatedResponseDataObjectArrayDesignValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PaginatedResponseDataObjectArrayDesignValueObject$lock()


#' Create a new PaginatedResponseDataObjectCompositeSequenceValueObject
#'
#' @description
#' PaginatedResponseDataObjectCompositeSequenceValueObject Class
#'
#' @docType class
#' @title PaginatedResponseDataObjectCompositeSequenceValueObject
#' @description PaginatedResponseDataObjectCompositeSequenceValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{CompositeSequenceValueObject}) optional
#' @field offset  integer optional
#' @field limit  integer optional
#' @field sort  \link{SortValueObject} optional
#' @field totalElements  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PaginatedResponseDataObjectCompositeSequenceValueObject <- R6::R6Class(
  "PaginatedResponseDataObjectCompositeSequenceValueObject",
  public = list(
    `data` = NULL,
    `offset` = NULL,
    `limit` = NULL,
    `sort` = NULL,
    `totalElements` = NULL,
    #' Initialize a new PaginatedResponseDataObjectCompositeSequenceValueObject class.
    #'
    #' @description
    #' Initialize a new PaginatedResponseDataObjectCompositeSequenceValueObject class.
    #'
    #' @param data data
    #' @param offset offset
    #' @param limit limit
    #' @param sort sort
    #' @param totalElements totalElements
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, `offset` = NULL, `limit` = NULL, `sort` = NULL, `totalElements` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
      if (!is.null(`offset`)) {
        stopifnot(is.numeric(`offset`), length(`offset`) == 1)
        self$`offset` <- `offset`
      }
      if (!is.null(`limit`)) {
        stopifnot(is.numeric(`limit`), length(`limit`) == 1)
        self$`limit` <- `limit`
      }
      if (!is.null(`sort`)) {
        stopifnot(R6::is.R6(`sort`))
        self$`sort` <- `sort`
      }
      if (!is.null(`totalElements`)) {
        stopifnot(is.numeric(`totalElements`), length(`totalElements`) == 1)
        self$`totalElements` <- `totalElements`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectCompositeSequenceValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      PaginatedResponseDataObjectCompositeSequenceValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        PaginatedResponseDataObjectCompositeSequenceValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      if (!is.null(self$`offset`)) {
        PaginatedResponseDataObjectCompositeSequenceValueObjectObject[["offset"]] <-
          self$`offset`
      }
      if (!is.null(self$`limit`)) {
        PaginatedResponseDataObjectCompositeSequenceValueObjectObject[["limit"]] <-
          self$`limit`
      }
      if (!is.null(self$`sort`)) {
        PaginatedResponseDataObjectCompositeSequenceValueObjectObject[["sort"]] <-
          self$`sort`$toJSON()
      }
      if (!is.null(self$`totalElements`)) {
        PaginatedResponseDataObjectCompositeSequenceValueObjectObject[["totalElements"]] <-
          self$`totalElements`
      }
      PaginatedResponseDataObjectCompositeSequenceValueObjectObject
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectCompositeSequenceValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectCompositeSequenceValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectCompositeSequenceValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[CompositeSequenceValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`offset`)) {
        self$`offset` <- this_object$`offset`
      }
      if (!is.null(this_object$`limit`)) {
        self$`limit` <- this_object$`limit`
      }
      if (!is.null(this_object$`sort`)) {
        sort_object <- SortValueObject$new()
        sort_object$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
        self$`sort` <- sort_object
      }
      if (!is.null(this_object$`totalElements`)) {
        self$`totalElements` <- this_object$`totalElements`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectCompositeSequenceValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`offset`)) {
          sprintf(
          '"offset":
            %d
                    ',
          self$`offset`
          )
        },
        if (!is.null(self$`limit`)) {
          sprintf(
          '"limit":
            %d
                    ',
          self$`limit`
          )
        },
        if (!is.null(self$`sort`)) {
          sprintf(
          '"sort":
          %s
          ',
          jsonlite::toJSON(self$`sort`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`totalElements`)) {
          sprintf(
          '"totalElements":
            %d
                    ',
          self$`totalElements`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectCompositeSequenceValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectCompositeSequenceValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectCompositeSequenceValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[CompositeSequenceValueObject]", loadNamespace("gemma.R"))
      self$`offset` <- this_object$`offset`
      self$`limit` <- this_object$`limit`
      self$`sort` <- SortValueObject$new()$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
      self$`totalElements` <- this_object$`totalElements`
      self
    },
    #' Validate JSON input with respect to PaginatedResponseDataObjectCompositeSequenceValueObject
    #'
    #' @description
    #' Validate JSON input with respect to PaginatedResponseDataObjectCompositeSequenceValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PaginatedResponseDataObjectCompositeSequenceValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PaginatedResponseDataObjectCompositeSequenceValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PaginatedResponseDataObjectCompositeSequenceValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PaginatedResponseDataObjectCompositeSequenceValueObject$lock()


#' Create a new PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
#'
#' @description
#' PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject Class
#'
#' @docType class
#' @title PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
#' @description PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{ExpressionAnalysisResultSetValueObject}) optional
#' @field offset  integer optional
#' @field limit  integer optional
#' @field sort  \link{SortValueObject} optional
#' @field totalElements  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject <- R6::R6Class(
  "PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject",
  public = list(
    `data` = NULL,
    `offset` = NULL,
    `limit` = NULL,
    `sort` = NULL,
    `totalElements` = NULL,
    #' Initialize a new PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject class.
    #'
    #' @description
    #' Initialize a new PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject class.
    #'
    #' @param data data
    #' @param offset offset
    #' @param limit limit
    #' @param sort sort
    #' @param totalElements totalElements
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, `offset` = NULL, `limit` = NULL, `sort` = NULL, `totalElements` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
      if (!is.null(`offset`)) {
        stopifnot(is.numeric(`offset`), length(`offset`) == 1)
        self$`offset` <- `offset`
      }
      if (!is.null(`limit`)) {
        stopifnot(is.numeric(`limit`), length(`limit`) == 1)
        self$`limit` <- `limit`
      }
      if (!is.null(`sort`)) {
        stopifnot(R6::is.R6(`sort`))
        self$`sort` <- `sort`
      }
      if (!is.null(`totalElements`)) {
        stopifnot(is.numeric(`totalElements`), length(`totalElements`) == 1)
        self$`totalElements` <- `totalElements`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      PaginatedResponseDataObjectExpressionAnalysisResultSetValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        PaginatedResponseDataObjectExpressionAnalysisResultSetValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      if (!is.null(self$`offset`)) {
        PaginatedResponseDataObjectExpressionAnalysisResultSetValueObjectObject[["offset"]] <-
          self$`offset`
      }
      if (!is.null(self$`limit`)) {
        PaginatedResponseDataObjectExpressionAnalysisResultSetValueObjectObject[["limit"]] <-
          self$`limit`
      }
      if (!is.null(self$`sort`)) {
        PaginatedResponseDataObjectExpressionAnalysisResultSetValueObjectObject[["sort"]] <-
          self$`sort`$toJSON()
      }
      if (!is.null(self$`totalElements`)) {
        PaginatedResponseDataObjectExpressionAnalysisResultSetValueObjectObject[["totalElements"]] <-
          self$`totalElements`
      }
      PaginatedResponseDataObjectExpressionAnalysisResultSetValueObjectObject
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ExpressionAnalysisResultSetValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`offset`)) {
        self$`offset` <- this_object$`offset`
      }
      if (!is.null(this_object$`limit`)) {
        self$`limit` <- this_object$`limit`
      }
      if (!is.null(this_object$`sort`)) {
        sort_object <- SortValueObject$new()
        sort_object$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
        self$`sort` <- sort_object
      }
      if (!is.null(this_object$`totalElements`)) {
        self$`totalElements` <- this_object$`totalElements`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`offset`)) {
          sprintf(
          '"offset":
            %d
                    ',
          self$`offset`
          )
        },
        if (!is.null(self$`limit`)) {
          sprintf(
          '"limit":
            %d
                    ',
          self$`limit`
          )
        },
        if (!is.null(self$`sort`)) {
          sprintf(
          '"sort":
          %s
          ',
          jsonlite::toJSON(self$`sort`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`totalElements`)) {
          sprintf(
          '"totalElements":
            %d
                    ',
          self$`totalElements`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ExpressionAnalysisResultSetValueObject]", loadNamespace("gemma.R"))
      self$`offset` <- this_object$`offset`
      self$`limit` <- this_object$`limit`
      self$`sort` <- SortValueObject$new()$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
      self$`totalElements` <- this_object$`totalElements`
      self
    },
    #' Validate JSON input with respect to PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Validate JSON input with respect to PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PaginatedResponseDataObjectExpressionAnalysisResultSetValueObject$lock()


#' Create a new PaginatedResponseDataObjectExpressionExperimentValueObject
#'
#' @description
#' PaginatedResponseDataObjectExpressionExperimentValueObject Class
#'
#' @docType class
#' @title PaginatedResponseDataObjectExpressionExperimentValueObject
#' @description PaginatedResponseDataObjectExpressionExperimentValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{ExpressionExperimentValueObject}) optional
#' @field offset  integer optional
#' @field limit  integer optional
#' @field sort  \link{SortValueObject} optional
#' @field totalElements  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PaginatedResponseDataObjectExpressionExperimentValueObject <- R6::R6Class(
  "PaginatedResponseDataObjectExpressionExperimentValueObject",
  public = list(
    `data` = NULL,
    `offset` = NULL,
    `limit` = NULL,
    `sort` = NULL,
    `totalElements` = NULL,
    #' Initialize a new PaginatedResponseDataObjectExpressionExperimentValueObject class.
    #'
    #' @description
    #' Initialize a new PaginatedResponseDataObjectExpressionExperimentValueObject class.
    #'
    #' @param data data
    #' @param offset offset
    #' @param limit limit
    #' @param sort sort
    #' @param totalElements totalElements
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, `offset` = NULL, `limit` = NULL, `sort` = NULL, `totalElements` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
      if (!is.null(`offset`)) {
        stopifnot(is.numeric(`offset`), length(`offset`) == 1)
        self$`offset` <- `offset`
      }
      if (!is.null(`limit`)) {
        stopifnot(is.numeric(`limit`), length(`limit`) == 1)
        self$`limit` <- `limit`
      }
      if (!is.null(`sort`)) {
        stopifnot(R6::is.R6(`sort`))
        self$`sort` <- `sort`
      }
      if (!is.null(`totalElements`)) {
        stopifnot(is.numeric(`totalElements`), length(`totalElements`) == 1)
        self$`totalElements` <- `totalElements`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      PaginatedResponseDataObjectExpressionExperimentValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        PaginatedResponseDataObjectExpressionExperimentValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      if (!is.null(self$`offset`)) {
        PaginatedResponseDataObjectExpressionExperimentValueObjectObject[["offset"]] <-
          self$`offset`
      }
      if (!is.null(self$`limit`)) {
        PaginatedResponseDataObjectExpressionExperimentValueObjectObject[["limit"]] <-
          self$`limit`
      }
      if (!is.null(self$`sort`)) {
        PaginatedResponseDataObjectExpressionExperimentValueObjectObject[["sort"]] <-
          self$`sort`$toJSON()
      }
      if (!is.null(self$`totalElements`)) {
        PaginatedResponseDataObjectExpressionExperimentValueObjectObject[["totalElements"]] <-
          self$`totalElements`
      }
      PaginatedResponseDataObjectExpressionExperimentValueObjectObject
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionExperimentValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionExperimentValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ExpressionExperimentValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`offset`)) {
        self$`offset` <- this_object$`offset`
      }
      if (!is.null(this_object$`limit`)) {
        self$`limit` <- this_object$`limit`
      }
      if (!is.null(this_object$`sort`)) {
        sort_object <- SortValueObject$new()
        sort_object$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
        self$`sort` <- sort_object
      }
      if (!is.null(this_object$`totalElements`)) {
        self$`totalElements` <- this_object$`totalElements`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectExpressionExperimentValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`offset`)) {
          sprintf(
          '"offset":
            %d
                    ',
          self$`offset`
          )
        },
        if (!is.null(self$`limit`)) {
          sprintf(
          '"limit":
            %d
                    ',
          self$`limit`
          )
        },
        if (!is.null(self$`sort`)) {
          sprintf(
          '"sort":
          %s
          ',
          jsonlite::toJSON(self$`sort`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`totalElements`)) {
          sprintf(
          '"totalElements":
            %d
                    ',
          self$`totalElements`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionExperimentValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectExpressionExperimentValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ExpressionExperimentValueObject]", loadNamespace("gemma.R"))
      self$`offset` <- this_object$`offset`
      self$`limit` <- this_object$`limit`
      self$`sort` <- SortValueObject$new()$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
      self$`totalElements` <- this_object$`totalElements`
      self
    },
    #' Validate JSON input with respect to PaginatedResponseDataObjectExpressionExperimentValueObject
    #'
    #' @description
    #' Validate JSON input with respect to PaginatedResponseDataObjectExpressionExperimentValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PaginatedResponseDataObjectExpressionExperimentValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PaginatedResponseDataObjectExpressionExperimentValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PaginatedResponseDataObjectExpressionExperimentValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PaginatedResponseDataObjectExpressionExperimentValueObject$lock()


#' Create a new PaginatedResponseDataObjectGeneValueObject
#'
#' @description
#' PaginatedResponseDataObjectGeneValueObject Class
#'
#' @docType class
#' @title PaginatedResponseDataObjectGeneValueObject
#' @description PaginatedResponseDataObjectGeneValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{GeneValueObject}) optional
#' @field offset  integer optional
#' @field limit  integer optional
#' @field sort  \link{SortValueObject} optional
#' @field totalElements  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PaginatedResponseDataObjectGeneValueObject <- R6::R6Class(
  "PaginatedResponseDataObjectGeneValueObject",
  public = list(
    `data` = NULL,
    `offset` = NULL,
    `limit` = NULL,
    `sort` = NULL,
    `totalElements` = NULL,
    #' Initialize a new PaginatedResponseDataObjectGeneValueObject class.
    #'
    #' @description
    #' Initialize a new PaginatedResponseDataObjectGeneValueObject class.
    #'
    #' @param data data
    #' @param offset offset
    #' @param limit limit
    #' @param sort sort
    #' @param totalElements totalElements
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, `offset` = NULL, `limit` = NULL, `sort` = NULL, `totalElements` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
      if (!is.null(`offset`)) {
        stopifnot(is.numeric(`offset`), length(`offset`) == 1)
        self$`offset` <- `offset`
      }
      if (!is.null(`limit`)) {
        stopifnot(is.numeric(`limit`), length(`limit`) == 1)
        self$`limit` <- `limit`
      }
      if (!is.null(`sort`)) {
        stopifnot(R6::is.R6(`sort`))
        self$`sort` <- `sort`
      }
      if (!is.null(`totalElements`)) {
        stopifnot(is.numeric(`totalElements`), length(`totalElements`) == 1)
        self$`totalElements` <- `totalElements`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectGeneValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      PaginatedResponseDataObjectGeneValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        PaginatedResponseDataObjectGeneValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      if (!is.null(self$`offset`)) {
        PaginatedResponseDataObjectGeneValueObjectObject[["offset"]] <-
          self$`offset`
      }
      if (!is.null(self$`limit`)) {
        PaginatedResponseDataObjectGeneValueObjectObject[["limit"]] <-
          self$`limit`
      }
      if (!is.null(self$`sort`)) {
        PaginatedResponseDataObjectGeneValueObjectObject[["sort"]] <-
          self$`sort`$toJSON()
      }
      if (!is.null(self$`totalElements`)) {
        PaginatedResponseDataObjectGeneValueObjectObject[["totalElements"]] <-
          self$`totalElements`
      }
      PaginatedResponseDataObjectGeneValueObjectObject
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectGeneValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectGeneValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectGeneValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`offset`)) {
        self$`offset` <- this_object$`offset`
      }
      if (!is.null(this_object$`limit`)) {
        self$`limit` <- this_object$`limit`
      }
      if (!is.null(this_object$`sort`)) {
        sort_object <- SortValueObject$new()
        sort_object$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
        self$`sort` <- sort_object
      }
      if (!is.null(this_object$`totalElements`)) {
        self$`totalElements` <- this_object$`totalElements`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PaginatedResponseDataObjectGeneValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`offset`)) {
          sprintf(
          '"offset":
            %d
                    ',
          self$`offset`
          )
        },
        if (!is.null(self$`limit`)) {
          sprintf(
          '"limit":
            %d
                    ',
          self$`limit`
          )
        },
        if (!is.null(self$`sort`)) {
          sprintf(
          '"sort":
          %s
          ',
          jsonlite::toJSON(self$`sort`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`totalElements`)) {
          sprintf(
          '"totalElements":
            %d
                    ',
          self$`totalElements`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectGeneValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PaginatedResponseDataObjectGeneValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PaginatedResponseDataObjectGeneValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      self$`offset` <- this_object$`offset`
      self$`limit` <- this_object$`limit`
      self$`sort` <- SortValueObject$new()$fromJSON(jsonlite::toJSON(this_object$sort, auto_unbox = TRUE, digits = NA))
      self$`totalElements` <- this_object$`totalElements`
      self
    },
    #' Validate JSON input with respect to PaginatedResponseDataObjectGeneValueObject
    #'
    #' @description
    #' Validate JSON input with respect to PaginatedResponseDataObjectGeneValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PaginatedResponseDataObjectGeneValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PaginatedResponseDataObjectGeneValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PaginatedResponseDataObjectGeneValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PaginatedResponseDataObjectGeneValueObject$lock()


#' Create a new PhenotypeAssociation
#'
#' @description
#' PhenotypeAssociation Class
#'
#' @docType class
#' @title PhenotypeAssociation
#' @description PhenotypeAssociation Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field auditTrail  \link{AuditTrail} optional
#' @field evidenceCode  \link{GOEvidenceCode} optional
#' @field isNegativeEvidence  character optional
#' @field score  character optional
#' @field strength  numeric optional
#' @field gene  \link{Gene} optional
#' @field phenotypes  list(\link{Characteristic}) optional
#' @field associationType  \link{Characteristic} optional
#' @field evidenceSource  \link{DatabaseEntry} optional
#' @field scoreType  \link{QuantitationType} optional
#' @field phenotypeAssociationPublications  list(\link{PhenotypeAssociationPublication}) optional
#' @field mappingType  \link{PhenotypeMappingType} optional
#' @field originalPhenotype  character optional
#' @field relationship  character optional
#' @field lastUpdated  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PhenotypeAssociation <- R6::R6Class(
  "PhenotypeAssociation",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `auditTrail` = NULL,
    `evidenceCode` = NULL,
    `isNegativeEvidence` = NULL,
    `score` = NULL,
    `strength` = NULL,
    `gene` = NULL,
    `phenotypes` = NULL,
    `associationType` = NULL,
    `evidenceSource` = NULL,
    `scoreType` = NULL,
    `phenotypeAssociationPublications` = NULL,
    `mappingType` = NULL,
    `originalPhenotype` = NULL,
    `relationship` = NULL,
    `lastUpdated` = NULL,
    #' Initialize a new PhenotypeAssociation class.
    #'
    #' @description
    #' Initialize a new PhenotypeAssociation class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param auditTrail auditTrail
    #' @param evidenceCode evidenceCode
    #' @param isNegativeEvidence isNegativeEvidence
    #' @param score score
    #' @param strength strength
    #' @param gene gene
    #' @param phenotypes phenotypes
    #' @param associationType associationType
    #' @param evidenceSource evidenceSource
    #' @param scoreType scoreType
    #' @param phenotypeAssociationPublications phenotypeAssociationPublications
    #' @param mappingType mappingType
    #' @param originalPhenotype originalPhenotype
    #' @param relationship relationship
    #' @param lastUpdated lastUpdated
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `auditTrail` = NULL, `evidenceCode` = NULL, `isNegativeEvidence` = NULL, `score` = NULL, `strength` = NULL, `gene` = NULL, `phenotypes` = NULL, `associationType` = NULL, `evidenceSource` = NULL, `scoreType` = NULL, `phenotypeAssociationPublications` = NULL, `mappingType` = NULL, `originalPhenotype` = NULL, `relationship` = NULL, `lastUpdated` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`auditTrail`)) {
        stopifnot(R6::is.R6(`auditTrail`))
        self$`auditTrail` <- `auditTrail`
      }
      if (!is.null(`evidenceCode`)) {
        stopifnot(R6::is.R6(`evidenceCode`))
        self$`evidenceCode` <- `evidenceCode`
      }
      if (!is.null(`isNegativeEvidence`)) {
        stopifnot(is.logical(`isNegativeEvidence`), length(`isNegativeEvidence`) == 1)
        self$`isNegativeEvidence` <- `isNegativeEvidence`
      }
      if (!is.null(`score`)) {
        stopifnot(is.character(`score`), length(`score`) == 1)
        self$`score` <- `score`
      }
      if (!is.null(`strength`)) {
        stopifnot(is.numeric(`strength`), length(`strength`) == 1)
        self$`strength` <- `strength`
      }
      if (!is.null(`gene`)) {
        stopifnot(R6::is.R6(`gene`))
        self$`gene` <- `gene`
      }
      if (!is.null(`phenotypes`)) {
        stopifnot(is.vector(`phenotypes`), length(`phenotypes`) != 0)
        sapply(`phenotypes`, function(x) stopifnot(R6::is.R6(x)))
        self$`phenotypes` <- `phenotypes`
      }
      if (!is.null(`associationType`)) {
        stopifnot(R6::is.R6(`associationType`))
        self$`associationType` <- `associationType`
      }
      if (!is.null(`evidenceSource`)) {
        stopifnot(R6::is.R6(`evidenceSource`))
        self$`evidenceSource` <- `evidenceSource`
      }
      if (!is.null(`scoreType`)) {
        stopifnot(R6::is.R6(`scoreType`))
        self$`scoreType` <- `scoreType`
      }
      if (!is.null(`phenotypeAssociationPublications`)) {
        stopifnot(is.vector(`phenotypeAssociationPublications`), length(`phenotypeAssociationPublications`) != 0)
        sapply(`phenotypeAssociationPublications`, function(x) stopifnot(R6::is.R6(x)))
        self$`phenotypeAssociationPublications` <- `phenotypeAssociationPublications`
      }
      if (!is.null(`mappingType`)) {
        stopifnot(R6::is.R6(`mappingType`))
        self$`mappingType` <- `mappingType`
      }
      if (!is.null(`originalPhenotype`)) {
        stopifnot(is.character(`originalPhenotype`), length(`originalPhenotype`) == 1)
        self$`originalPhenotype` <- `originalPhenotype`
      }
      if (!is.null(`relationship`)) {
        stopifnot(is.character(`relationship`), length(`relationship`) == 1)
        self$`relationship` <- `relationship`
      }
      if (!is.null(`lastUpdated`)) {
        stopifnot(is.character(`lastUpdated`), length(`lastUpdated`) == 1)
        self$`lastUpdated` <- `lastUpdated`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhenotypeAssociation in JSON format
    #' @keywords internal
    toJSON = function() {
      PhenotypeAssociationObject <- list()
      if (!is.null(self$`name`)) {
        PhenotypeAssociationObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        PhenotypeAssociationObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        PhenotypeAssociationObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`auditTrail`)) {
        PhenotypeAssociationObject[["auditTrail"]] <-
          self$`auditTrail`$toJSON()
      }
      if (!is.null(self$`evidenceCode`)) {
        PhenotypeAssociationObject[["evidenceCode"]] <-
          self$`evidenceCode`$toJSON()
      }
      if (!is.null(self$`isNegativeEvidence`)) {
        PhenotypeAssociationObject[["isNegativeEvidence"]] <-
          self$`isNegativeEvidence`
      }
      if (!is.null(self$`score`)) {
        PhenotypeAssociationObject[["score"]] <-
          self$`score`
      }
      if (!is.null(self$`strength`)) {
        PhenotypeAssociationObject[["strength"]] <-
          self$`strength`
      }
      if (!is.null(self$`gene`)) {
        PhenotypeAssociationObject[["gene"]] <-
          self$`gene`$toJSON()
      }
      if (!is.null(self$`phenotypes`)) {
        PhenotypeAssociationObject[["phenotypes"]] <-
          lapply(self$`phenotypes`, function(x) x$toJSON())
      }
      if (!is.null(self$`associationType`)) {
        PhenotypeAssociationObject[["associationType"]] <-
          self$`associationType`$toJSON()
      }
      if (!is.null(self$`evidenceSource`)) {
        PhenotypeAssociationObject[["evidenceSource"]] <-
          self$`evidenceSource`$toJSON()
      }
      if (!is.null(self$`scoreType`)) {
        PhenotypeAssociationObject[["scoreType"]] <-
          self$`scoreType`$toJSON()
      }
      if (!is.null(self$`phenotypeAssociationPublications`)) {
        PhenotypeAssociationObject[["phenotypeAssociationPublications"]] <-
          lapply(self$`phenotypeAssociationPublications`, function(x) x$toJSON())
      }
      if (!is.null(self$`mappingType`)) {
        PhenotypeAssociationObject[["mappingType"]] <-
          self$`mappingType`$toJSON()
      }
      if (!is.null(self$`originalPhenotype`)) {
        PhenotypeAssociationObject[["originalPhenotype"]] <-
          self$`originalPhenotype`
      }
      if (!is.null(self$`relationship`)) {
        PhenotypeAssociationObject[["relationship"]] <-
          self$`relationship`
      }
      if (!is.null(self$`lastUpdated`)) {
        PhenotypeAssociationObject[["lastUpdated"]] <-
          self$`lastUpdated`
      }
      PhenotypeAssociationObject
    },
    #' Deserialize JSON string into an instance of PhenotypeAssociation
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhenotypeAssociation
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhenotypeAssociation
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`auditTrail`)) {
        audittrail_object <- AuditTrail$new()
        audittrail_object$fromJSON(jsonlite::toJSON(this_object$auditTrail, auto_unbox = TRUE, digits = NA))
        self$`auditTrail` <- audittrail_object
      }
      if (!is.null(this_object$`evidenceCode`)) {
        evidencecode_object <- GOEvidenceCode$new()
        evidencecode_object$fromJSON(jsonlite::toJSON(this_object$evidenceCode, auto_unbox = TRUE, digits = NA))
        self$`evidenceCode` <- evidencecode_object
      }
      if (!is.null(this_object$`isNegativeEvidence`)) {
        self$`isNegativeEvidence` <- this_object$`isNegativeEvidence`
      }
      if (!is.null(this_object$`score`)) {
        self$`score` <- this_object$`score`
      }
      if (!is.null(this_object$`strength`)) {
        self$`strength` <- this_object$`strength`
      }
      if (!is.null(this_object$`gene`)) {
        gene_object <- Gene$new()
        gene_object$fromJSON(jsonlite::toJSON(this_object$gene, auto_unbox = TRUE, digits = NA))
        self$`gene` <- gene_object
      }
      if (!is.null(this_object$`phenotypes`)) {
        self$`phenotypes` <- ApiClient$new()$deserializeObj(this_object$`phenotypes`, "set[Characteristic]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`associationType`)) {
        associationtype_object <- Characteristic$new()
        associationtype_object$fromJSON(jsonlite::toJSON(this_object$associationType, auto_unbox = TRUE, digits = NA))
        self$`associationType` <- associationtype_object
      }
      if (!is.null(this_object$`evidenceSource`)) {
        evidencesource_object <- DatabaseEntry$new()
        evidencesource_object$fromJSON(jsonlite::toJSON(this_object$evidenceSource, auto_unbox = TRUE, digits = NA))
        self$`evidenceSource` <- evidencesource_object
      }
      if (!is.null(this_object$`scoreType`)) {
        scoretype_object <- QuantitationType$new()
        scoretype_object$fromJSON(jsonlite::toJSON(this_object$scoreType, auto_unbox = TRUE, digits = NA))
        self$`scoreType` <- scoretype_object
      }
      if (!is.null(this_object$`phenotypeAssociationPublications`)) {
        self$`phenotypeAssociationPublications` <- ApiClient$new()$deserializeObj(this_object$`phenotypeAssociationPublications`, "set[PhenotypeAssociationPublication]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`mappingType`)) {
        mappingtype_object <- PhenotypeMappingType$new()
        mappingtype_object$fromJSON(jsonlite::toJSON(this_object$mappingType, auto_unbox = TRUE, digits = NA))
        self$`mappingType` <- mappingtype_object
      }
      if (!is.null(this_object$`originalPhenotype`)) {
        self$`originalPhenotype` <- this_object$`originalPhenotype`
      }
      if (!is.null(this_object$`relationship`)) {
        self$`relationship` <- this_object$`relationship`
      }
      if (!is.null(this_object$`lastUpdated`)) {
        self$`lastUpdated` <- this_object$`lastUpdated`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhenotypeAssociation in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`auditTrail`)) {
          sprintf(
          '"auditTrail":
          %s
          ',
          jsonlite::toJSON(self$`auditTrail`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`evidenceCode`)) {
          sprintf(
          '"evidenceCode":
          %s
          ',
          jsonlite::toJSON(self$`evidenceCode`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`isNegativeEvidence`)) {
          sprintf(
          '"isNegativeEvidence":
            %s
                    ',
          tolower(self$`isNegativeEvidence`)
          )
        },
        if (!is.null(self$`score`)) {
          sprintf(
          '"score":
            "%s"
                    ',
          self$`score`
          )
        },
        if (!is.null(self$`strength`)) {
          sprintf(
          '"strength":
            %d
                    ',
          self$`strength`
          )
        },
        if (!is.null(self$`gene`)) {
          sprintf(
          '"gene":
          %s
          ',
          jsonlite::toJSON(self$`gene`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`phenotypes`)) {
          sprintf(
          '"phenotypes":
          [%s]
',
          paste(sapply(self$`phenotypes`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`associationType`)) {
          sprintf(
          '"associationType":
          %s
          ',
          jsonlite::toJSON(self$`associationType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`evidenceSource`)) {
          sprintf(
          '"evidenceSource":
          %s
          ',
          jsonlite::toJSON(self$`evidenceSource`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`scoreType`)) {
          sprintf(
          '"scoreType":
          %s
          ',
          jsonlite::toJSON(self$`scoreType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`phenotypeAssociationPublications`)) {
          sprintf(
          '"phenotypeAssociationPublications":
          [%s]
',
          paste(sapply(self$`phenotypeAssociationPublications`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`mappingType`)) {
          sprintf(
          '"mappingType":
          %s
          ',
          jsonlite::toJSON(self$`mappingType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`originalPhenotype`)) {
          sprintf(
          '"originalPhenotype":
            "%s"
                    ',
          self$`originalPhenotype`
          )
        },
        if (!is.null(self$`relationship`)) {
          sprintf(
          '"relationship":
            "%s"
                    ',
          self$`relationship`
          )
        },
        if (!is.null(self$`lastUpdated`)) {
          sprintf(
          '"lastUpdated":
            "%s"
                    ',
          self$`lastUpdated`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PhenotypeAssociation
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhenotypeAssociation
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhenotypeAssociation
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`auditTrail` <- AuditTrail$new()$fromJSON(jsonlite::toJSON(this_object$auditTrail, auto_unbox = TRUE, digits = NA))
      self$`evidenceCode` <- GOEvidenceCode$new()$fromJSON(jsonlite::toJSON(this_object$evidenceCode, auto_unbox = TRUE, digits = NA))
      self$`isNegativeEvidence` <- this_object$`isNegativeEvidence`
      self$`score` <- this_object$`score`
      self$`strength` <- this_object$`strength`
      self$`gene` <- Gene$new()$fromJSON(jsonlite::toJSON(this_object$gene, auto_unbox = TRUE, digits = NA))
      self$`phenotypes` <- ApiClient$new()$deserializeObj(this_object$`phenotypes`, "set[Characteristic]", loadNamespace("gemma.R"))
      self$`associationType` <- Characteristic$new()$fromJSON(jsonlite::toJSON(this_object$associationType, auto_unbox = TRUE, digits = NA))
      self$`evidenceSource` <- DatabaseEntry$new()$fromJSON(jsonlite::toJSON(this_object$evidenceSource, auto_unbox = TRUE, digits = NA))
      self$`scoreType` <- QuantitationType$new()$fromJSON(jsonlite::toJSON(this_object$scoreType, auto_unbox = TRUE, digits = NA))
      self$`phenotypeAssociationPublications` <- ApiClient$new()$deserializeObj(this_object$`phenotypeAssociationPublications`, "set[PhenotypeAssociationPublication]", loadNamespace("gemma.R"))
      self$`mappingType` <- PhenotypeMappingType$new()$fromJSON(jsonlite::toJSON(this_object$mappingType, auto_unbox = TRUE, digits = NA))
      self$`originalPhenotype` <- this_object$`originalPhenotype`
      self$`relationship` <- this_object$`relationship`
      self$`lastUpdated` <- this_object$`lastUpdated`
      self
    },
    #' Validate JSON input with respect to PhenotypeAssociation
    #'
    #' @description
    #' Validate JSON input with respect to PhenotypeAssociation and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PhenotypeAssociation
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {


      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()


      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PhenotypeAssociation$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PhenotypeAssociation$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PhenotypeAssociation$lock()


#' Create a new PhenotypeAssociationPublication
#'
#' @description
#' PhenotypeAssociationPublication Class
#'
#' @docType class
#' @title PhenotypeAssociationPublication
#' @description PhenotypeAssociationPublication Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field type  character optional
#' @field citation  \link{BibliographicReference} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PhenotypeAssociationPublication <- R6::R6Class(
  "PhenotypeAssociationPublication",
  public = list(
    `id` = NULL,
    `type` = NULL,
    `citation` = NULL,
    #' Initialize a new PhenotypeAssociationPublication class.
    #'
    #' @description
    #' Initialize a new PhenotypeAssociationPublication class.
    #'
    #' @param id id
    #' @param type type
    #' @param citation citation
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `type` = NULL, `citation` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`type`)) {
        stopifnot(is.character(`type`), length(`type`) == 1)
        self$`type` <- `type`
      }
      if (!is.null(`citation`)) {
        stopifnot(R6::is.R6(`citation`))
        self$`citation` <- `citation`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhenotypeAssociationPublication in JSON format
    #' @keywords internal
    toJSON = function() {
      PhenotypeAssociationPublicationObject <- list()
      if (!is.null(self$`id`)) {
        PhenotypeAssociationPublicationObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`type`)) {
        PhenotypeAssociationPublicationObject[["type"]] <-
          self$`type`
      }
      if (!is.null(self$`citation`)) {
        PhenotypeAssociationPublicationObject[["citation"]] <-
          self$`citation`$toJSON()
      }
      PhenotypeAssociationPublicationObject
    },
    #' Deserialize JSON string into an instance of PhenotypeAssociationPublication
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhenotypeAssociationPublication
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhenotypeAssociationPublication
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`type`)) {
        self$`type` <- this_object$`type`
      }
      if (!is.null(this_object$`citation`)) {
        citation_object <- BibliographicReference$new()
        citation_object$fromJSON(jsonlite::toJSON(this_object$citation, auto_unbox = TRUE, digits = NA))
        self$`citation` <- citation_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhenotypeAssociationPublication in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
          '"type":
            "%s"
                    ',
          self$`type`
          )
        },
        if (!is.null(self$`citation`)) {
          sprintf(
          '"citation":
          %s
          ',
          jsonlite::toJSON(self$`citation`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PhenotypeAssociationPublication
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhenotypeAssociationPublication
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhenotypeAssociationPublication
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`type` <- this_object$`type`
      self$`citation` <- BibliographicReference$new()$fromJSON(jsonlite::toJSON(this_object$citation, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to PhenotypeAssociationPublication
    #'
    #' @description
    #' Validate JSON input with respect to PhenotypeAssociationPublication and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PhenotypeAssociationPublication
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PhenotypeAssociationPublication$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PhenotypeAssociationPublication$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PhenotypeAssociationPublication$lock()


#' Create a new PhenotypeMappingType
#'
#' @description
#' PhenotypeMappingType Class
#'
#' @docType class
#' @title PhenotypeMappingType
#' @description PhenotypeMappingType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @field mutable  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PhenotypeMappingType <- R6::R6Class(
  "PhenotypeMappingType",
  public = list(
    `value` = NULL,
    `mutable` = NULL,
    #' Initialize a new PhenotypeMappingType class.
    #'
    #' @description
    #' Initialize a new PhenotypeMappingType class.
    #'
    #' @param value value
    #' @param mutable mutable
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, `mutable` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
      if (!is.null(`mutable`)) {
        stopifnot(is.logical(`mutable`), length(`mutable`) == 1)
        self$`mutable` <- `mutable`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhenotypeMappingType in JSON format
    #' @keywords internal
    toJSON = function() {
      PhenotypeMappingTypeObject <- list()
      if (!is.null(self$`value`)) {
        PhenotypeMappingTypeObject[["value"]] <-
          self$`value`
      }
      if (!is.null(self$`mutable`)) {
        PhenotypeMappingTypeObject[["mutable"]] <-
          self$`mutable`
      }
      PhenotypeMappingTypeObject
    },
    #' Deserialize JSON string into an instance of PhenotypeMappingType
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhenotypeMappingType
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhenotypeMappingType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      if (!is.null(this_object$`mutable`)) {
        self$`mutable` <- this_object$`mutable`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhenotypeMappingType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        },
        if (!is.null(self$`mutable`)) {
          sprintf(
          '"mutable":
            %s
                    ',
          tolower(self$`mutable`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PhenotypeMappingType
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhenotypeMappingType
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhenotypeMappingType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self$`mutable` <- this_object$`mutable`
      self
    },
    #' Validate JSON input with respect to PhenotypeMappingType
    #'
    #' @description
    #' Validate JSON input with respect to PhenotypeMappingType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PhenotypeMappingType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PhenotypeMappingType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PhenotypeMappingType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PhenotypeMappingType$lock()


#' Create a new PhysicalLocation
#'
#' @description
#' PhysicalLocation Class
#'
#' @docType class
#' @title PhysicalLocation
#' @description PhysicalLocation Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field chromosome  \link{Chromosome} optional
#' @field nucleotide  integer optional
#' @field nucleotideLength  integer optional
#' @field strand  character optional
#' @field bin  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PhysicalLocation <- R6::R6Class(
  "PhysicalLocation",
  public = list(
    `id` = NULL,
    `chromosome` = NULL,
    `nucleotide` = NULL,
    `nucleotideLength` = NULL,
    `strand` = NULL,
    `bin` = NULL,
    #' Initialize a new PhysicalLocation class.
    #'
    #' @description
    #' Initialize a new PhysicalLocation class.
    #'
    #' @param id id
    #' @param chromosome chromosome
    #' @param nucleotide nucleotide
    #' @param nucleotideLength nucleotideLength
    #' @param strand strand
    #' @param bin bin
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `chromosome` = NULL, `nucleotide` = NULL, `nucleotideLength` = NULL, `strand` = NULL, `bin` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`chromosome`)) {
        stopifnot(R6::is.R6(`chromosome`))
        self$`chromosome` <- `chromosome`
      }
      if (!is.null(`nucleotide`)) {
        stopifnot(is.numeric(`nucleotide`), length(`nucleotide`) == 1)
        self$`nucleotide` <- `nucleotide`
      }
      if (!is.null(`nucleotideLength`)) {
        stopifnot(is.numeric(`nucleotideLength`), length(`nucleotideLength`) == 1)
        self$`nucleotideLength` <- `nucleotideLength`
      }
      if (!is.null(`strand`)) {
        stopifnot(is.character(`strand`), length(`strand`) == 1)
        self$`strand` <- `strand`
      }
      if (!is.null(`bin`)) {
        stopifnot(is.numeric(`bin`), length(`bin`) == 1)
        self$`bin` <- `bin`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhysicalLocation in JSON format
    #' @keywords internal
    toJSON = function() {
      PhysicalLocationObject <- list()
      if (!is.null(self$`id`)) {
        PhysicalLocationObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`chromosome`)) {
        PhysicalLocationObject[["chromosome"]] <-
          self$`chromosome`$toJSON()
      }
      if (!is.null(self$`nucleotide`)) {
        PhysicalLocationObject[["nucleotide"]] <-
          self$`nucleotide`
      }
      if (!is.null(self$`nucleotideLength`)) {
        PhysicalLocationObject[["nucleotideLength"]] <-
          self$`nucleotideLength`
      }
      if (!is.null(self$`strand`)) {
        PhysicalLocationObject[["strand"]] <-
          self$`strand`
      }
      if (!is.null(self$`bin`)) {
        PhysicalLocationObject[["bin"]] <-
          self$`bin`
      }
      PhysicalLocationObject
    },
    #' Deserialize JSON string into an instance of PhysicalLocation
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhysicalLocation
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhysicalLocation
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`chromosome`)) {
        chromosome_object <- Chromosome$new()
        chromosome_object$fromJSON(jsonlite::toJSON(this_object$chromosome, auto_unbox = TRUE, digits = NA))
        self$`chromosome` <- chromosome_object
      }
      if (!is.null(this_object$`nucleotide`)) {
        self$`nucleotide` <- this_object$`nucleotide`
      }
      if (!is.null(this_object$`nucleotideLength`)) {
        self$`nucleotideLength` <- this_object$`nucleotideLength`
      }
      if (!is.null(this_object$`strand`)) {
        self$`strand` <- this_object$`strand`
      }
      if (!is.null(this_object$`bin`)) {
        self$`bin` <- this_object$`bin`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhysicalLocation in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`chromosome`)) {
          sprintf(
          '"chromosome":
          %s
          ',
          jsonlite::toJSON(self$`chromosome`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`nucleotide`)) {
          sprintf(
          '"nucleotide":
            %d
                    ',
          self$`nucleotide`
          )
        },
        if (!is.null(self$`nucleotideLength`)) {
          sprintf(
          '"nucleotideLength":
            %d
                    ',
          self$`nucleotideLength`
          )
        },
        if (!is.null(self$`strand`)) {
          sprintf(
          '"strand":
            "%s"
                    ',
          self$`strand`
          )
        },
        if (!is.null(self$`bin`)) {
          sprintf(
          '"bin":
            %d
                    ',
          self$`bin`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PhysicalLocation
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhysicalLocation
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhysicalLocation
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`chromosome` <- Chromosome$new()$fromJSON(jsonlite::toJSON(this_object$chromosome, auto_unbox = TRUE, digits = NA))
      self$`nucleotide` <- this_object$`nucleotide`
      self$`nucleotideLength` <- this_object$`nucleotideLength`
      self$`strand` <- this_object$`strand`
      self$`bin` <- this_object$`bin`
      self
    },
    #' Validate JSON input with respect to PhysicalLocation
    #'
    #' @description
    #' Validate JSON input with respect to PhysicalLocation and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PhysicalLocation
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PhysicalLocation$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PhysicalLocation$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PhysicalLocation$lock()


#' Create a new PhysicalLocationValueObject
#'
#' @description
#' PhysicalLocationValueObject Class
#'
#' @docType class
#' @title PhysicalLocationValueObject
#' @description PhysicalLocationValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field nucleotide  integer optional
#' @field nucleotideLength  integer optional
#' @field strand  character optional
#' @field bin  integer optional
#' @field chromosome  character optional
#' @field taxon  \link{TaxonValueObject} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PhysicalLocationValueObject <- R6::R6Class(
  "PhysicalLocationValueObject",
  public = list(
    `id` = NULL,
    `nucleotide` = NULL,
    `nucleotideLength` = NULL,
    `strand` = NULL,
    `bin` = NULL,
    `chromosome` = NULL,
    `taxon` = NULL,
    #' Initialize a new PhysicalLocationValueObject class.
    #'
    #' @description
    #' Initialize a new PhysicalLocationValueObject class.
    #'
    #' @param id id
    #' @param nucleotide nucleotide
    #' @param nucleotideLength nucleotideLength
    #' @param strand strand
    #' @param bin bin
    #' @param chromosome chromosome
    #' @param taxon taxon
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `nucleotide` = NULL, `nucleotideLength` = NULL, `strand` = NULL, `bin` = NULL, `chromosome` = NULL, `taxon` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`nucleotide`)) {
        stopifnot(is.numeric(`nucleotide`), length(`nucleotide`) == 1)
        self$`nucleotide` <- `nucleotide`
      }
      if (!is.null(`nucleotideLength`)) {
        stopifnot(is.numeric(`nucleotideLength`), length(`nucleotideLength`) == 1)
        self$`nucleotideLength` <- `nucleotideLength`
      }
      if (!is.null(`strand`)) {
        stopifnot(is.character(`strand`), length(`strand`) == 1)
        self$`strand` <- `strand`
      }
      if (!is.null(`bin`)) {
        stopifnot(is.numeric(`bin`), length(`bin`) == 1)
        self$`bin` <- `bin`
      }
      if (!is.null(`chromosome`)) {
        stopifnot(is.character(`chromosome`), length(`chromosome`) == 1)
        self$`chromosome` <- `chromosome`
      }
      if (!is.null(`taxon`)) {
        stopifnot(R6::is.R6(`taxon`))
        self$`taxon` <- `taxon`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhysicalLocationValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      PhysicalLocationValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        PhysicalLocationValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`nucleotide`)) {
        PhysicalLocationValueObjectObject[["nucleotide"]] <-
          self$`nucleotide`
      }
      if (!is.null(self$`nucleotideLength`)) {
        PhysicalLocationValueObjectObject[["nucleotideLength"]] <-
          self$`nucleotideLength`
      }
      if (!is.null(self$`strand`)) {
        PhysicalLocationValueObjectObject[["strand"]] <-
          self$`strand`
      }
      if (!is.null(self$`bin`)) {
        PhysicalLocationValueObjectObject[["bin"]] <-
          self$`bin`
      }
      if (!is.null(self$`chromosome`)) {
        PhysicalLocationValueObjectObject[["chromosome"]] <-
          self$`chromosome`
      }
      if (!is.null(self$`taxon`)) {
        PhysicalLocationValueObjectObject[["taxon"]] <-
          self$`taxon`$toJSON()
      }
      PhysicalLocationValueObjectObject
    },
    #' Deserialize JSON string into an instance of PhysicalLocationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhysicalLocationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhysicalLocationValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`nucleotide`)) {
        self$`nucleotide` <- this_object$`nucleotide`
      }
      if (!is.null(this_object$`nucleotideLength`)) {
        self$`nucleotideLength` <- this_object$`nucleotideLength`
      }
      if (!is.null(this_object$`strand`)) {
        self$`strand` <- this_object$`strand`
      }
      if (!is.null(this_object$`bin`)) {
        self$`bin` <- this_object$`bin`
      }
      if (!is.null(this_object$`chromosome`)) {
        self$`chromosome` <- this_object$`chromosome`
      }
      if (!is.null(this_object$`taxon`)) {
        taxon_object <- TaxonValueObject$new()
        taxon_object$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
        self$`taxon` <- taxon_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PhysicalLocationValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`nucleotide`)) {
          sprintf(
          '"nucleotide":
            %d
                    ',
          self$`nucleotide`
          )
        },
        if (!is.null(self$`nucleotideLength`)) {
          sprintf(
          '"nucleotideLength":
            %d
                    ',
          self$`nucleotideLength`
          )
        },
        if (!is.null(self$`strand`)) {
          sprintf(
          '"strand":
            "%s"
                    ',
          self$`strand`
          )
        },
        if (!is.null(self$`bin`)) {
          sprintf(
          '"bin":
            %d
                    ',
          self$`bin`
          )
        },
        if (!is.null(self$`chromosome`)) {
          sprintf(
          '"chromosome":
            "%s"
                    ',
          self$`chromosome`
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
          %s
          ',
          jsonlite::toJSON(self$`taxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PhysicalLocationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of PhysicalLocationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of PhysicalLocationValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`nucleotide` <- this_object$`nucleotide`
      self$`nucleotideLength` <- this_object$`nucleotideLength`
      self$`strand` <- this_object$`strand`
      self$`bin` <- this_object$`bin`
      self$`chromosome` <- this_object$`chromosome`
      self$`taxon` <- TaxonValueObject$new()$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to PhysicalLocationValueObject
    #'
    #' @description
    #' Validate JSON input with respect to PhysicalLocationValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PhysicalLocationValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PhysicalLocationValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PhysicalLocationValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PhysicalLocationValueObject$lock()


#' @docType class
#' @title PlatformArg
#'
#' @description PlatformArg Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PlatformArg <- R6::R6Class(
  "PlatformArg",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new PlatformArg.
    #'
    #' @description
    #' Initialize a new PlatformArg.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize PlatformArg with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of PlatformArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of PlatformArg.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of PlatformArg.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of PlatformArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of PlatformArg.
    #'
    #' @param input The input JSON.
    #' @return An instance of PlatformArg.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into PlatformArg with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into PlatformArg with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize PlatformArg to JSON string.
    #'
    #' @description
    #' Serialize PlatformArg to JSON string.
    #'
    #' @return JSON string representation of the PlatformArg.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize PlatformArg to JSON.
    #'
    #' @description
    #' Serialize PlatformArg to JSON.
    #'
    #' @return JSON representation of the PlatformArg.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to PlatformArg.
    #'
    #' @description
    #' Validate the input JSON with respect to PlatformArg and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PlatformArg$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PlatformArg$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PlatformArg$lock()


#' Create a new PolymerType
#'
#' @description
#' PolymerType Class
#'
#' @docType class
#' @title PolymerType
#' @description PolymerType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PolymerType <- R6::R6Class(
  "PolymerType",
  public = list(
    `value` = NULL,
    #' Initialize a new PolymerType class.
    #'
    #' @description
    #' Initialize a new PolymerType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PolymerType in JSON format
    #' @keywords internal
    toJSON = function() {
      PolymerTypeObject <- list()
      if (!is.null(self$`value`)) {
        PolymerTypeObject[["value"]] <-
          self$`value`
      }
      PolymerTypeObject
    },
    #' Deserialize JSON string into an instance of PolymerType
    #'
    #' @description
    #' Deserialize JSON string into an instance of PolymerType
    #'
    #' @param input_json the JSON input
    #' @return the instance of PolymerType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PolymerType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PolymerType
    #'
    #' @description
    #' Deserialize JSON string into an instance of PolymerType
    #'
    #' @param input_json the JSON input
    #' @return the instance of PolymerType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to PolymerType
    #'
    #' @description
    #' Validate JSON input with respect to PolymerType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PolymerType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PolymerType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PolymerType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PolymerType$lock()


#' Create a new PrimitiveType
#'
#' @description
#' PrimitiveType Class
#'
#' @docType class
#' @title PrimitiveType
#' @description PrimitiveType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
PrimitiveType <- R6::R6Class(
  "PrimitiveType",
  public = list(
    `value` = NULL,
    #' Initialize a new PrimitiveType class.
    #'
    #' @description
    #' Initialize a new PrimitiveType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PrimitiveType in JSON format
    #' @keywords internal
    toJSON = function() {
      PrimitiveTypeObject <- list()
      if (!is.null(self$`value`)) {
        PrimitiveTypeObject[["value"]] <-
          self$`value`
      }
      PrimitiveTypeObject
    },
    #' Deserialize JSON string into an instance of PrimitiveType
    #'
    #' @description
    #' Deserialize JSON string into an instance of PrimitiveType
    #'
    #' @param input_json the JSON input
    #' @return the instance of PrimitiveType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return PrimitiveType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of PrimitiveType
    #'
    #' @description
    #' Deserialize JSON string into an instance of PrimitiveType
    #'
    #' @param input_json the JSON input
    #' @return the instance of PrimitiveType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to PrimitiveType
    #'
    #' @description
    #' Validate JSON input with respect to PrimitiveType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of PrimitiveType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
PrimitiveType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
PrimitiveType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
PrimitiveType$lock()


#' Create a new Protocol
#'
#' @description
#' Protocol Class
#'
#' @docType class
#' @title Protocol
#' @description Protocol Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Protocol <- R6::R6Class(
  "Protocol",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    #' Initialize a new Protocol class.
    #'
    #' @description
    #' Initialize a new Protocol class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Protocol in JSON format
    #' @keywords internal
    toJSON = function() {
      ProtocolObject <- list()
      if (!is.null(self$`name`)) {
        ProtocolObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        ProtocolObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        ProtocolObject[["id"]] <-
          self$`id`
      }
      ProtocolObject
    },
    #' Deserialize JSON string into an instance of Protocol
    #'
    #' @description
    #' Deserialize JSON string into an instance of Protocol
    #'
    #' @param input_json the JSON input
    #' @return the instance of Protocol
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Protocol in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Protocol
    #'
    #' @description
    #' Deserialize JSON string into an instance of Protocol
    #'
    #' @param input_json the JSON input
    #' @return the instance of Protocol
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self
    },
    #' Validate JSON input with respect to Protocol
    #'
    #' @description
    #' Validate JSON input with respect to Protocol and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Protocol
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Protocol$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Protocol$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Protocol$lock()


#' Create a new QuantitationType
#'
#' @description
#' QuantitationType Class
#'
#' @docType class
#' @title QuantitationType
#' @description QuantitationType Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field isBackground  character optional
#' @field isBackgroundSubtracted  character optional
#' @field isBatchCorrected  character optional
#' @field isMaskedPreferred  character optional
#' @field isNormalized  character optional
#' @field isPreferred  character optional
#' @field isRecomputedFromRawData  character optional
#' @field isRatio  character optional
#' @field generalType  \link{GeneralType} optional
#' @field representation  \link{PrimitiveType} optional
#' @field scale  \link{ScaleType} optional
#' @field type  \link{StandardQuantitationType} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
QuantitationType <- R6::R6Class(
  "QuantitationType",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `isBackground` = NULL,
    `isBackgroundSubtracted` = NULL,
    `isBatchCorrected` = NULL,
    `isMaskedPreferred` = NULL,
    `isNormalized` = NULL,
    `isPreferred` = NULL,
    `isRecomputedFromRawData` = NULL,
    `isRatio` = NULL,
    `generalType` = NULL,
    `representation` = NULL,
    `scale` = NULL,
    `type` = NULL,
    #' Initialize a new QuantitationType class.
    #'
    #' @description
    #' Initialize a new QuantitationType class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param isBackground isBackground
    #' @param isBackgroundSubtracted isBackgroundSubtracted
    #' @param isBatchCorrected isBatchCorrected
    #' @param isMaskedPreferred isMaskedPreferred
    #' @param isNormalized isNormalized
    #' @param isPreferred isPreferred
    #' @param isRecomputedFromRawData isRecomputedFromRawData
    #' @param isRatio isRatio
    #' @param generalType generalType
    #' @param representation representation
    #' @param scale scale
    #' @param type type
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `isBackground` = NULL, `isBackgroundSubtracted` = NULL, `isBatchCorrected` = NULL, `isMaskedPreferred` = NULL, `isNormalized` = NULL, `isPreferred` = NULL, `isRecomputedFromRawData` = NULL, `isRatio` = NULL, `generalType` = NULL, `representation` = NULL, `scale` = NULL, `type` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`isBackground`)) {
        stopifnot(is.logical(`isBackground`), length(`isBackground`) == 1)
        self$`isBackground` <- `isBackground`
      }
      if (!is.null(`isBackgroundSubtracted`)) {
        stopifnot(is.logical(`isBackgroundSubtracted`), length(`isBackgroundSubtracted`) == 1)
        self$`isBackgroundSubtracted` <- `isBackgroundSubtracted`
      }
      if (!is.null(`isBatchCorrected`)) {
        stopifnot(is.logical(`isBatchCorrected`), length(`isBatchCorrected`) == 1)
        self$`isBatchCorrected` <- `isBatchCorrected`
      }
      if (!is.null(`isMaskedPreferred`)) {
        stopifnot(is.logical(`isMaskedPreferred`), length(`isMaskedPreferred`) == 1)
        self$`isMaskedPreferred` <- `isMaskedPreferred`
      }
      if (!is.null(`isNormalized`)) {
        stopifnot(is.logical(`isNormalized`), length(`isNormalized`) == 1)
        self$`isNormalized` <- `isNormalized`
      }
      if (!is.null(`isPreferred`)) {
        stopifnot(is.logical(`isPreferred`), length(`isPreferred`) == 1)
        self$`isPreferred` <- `isPreferred`
      }
      if (!is.null(`isRecomputedFromRawData`)) {
        stopifnot(is.logical(`isRecomputedFromRawData`), length(`isRecomputedFromRawData`) == 1)
        self$`isRecomputedFromRawData` <- `isRecomputedFromRawData`
      }
      if (!is.null(`isRatio`)) {
        stopifnot(is.logical(`isRatio`), length(`isRatio`) == 1)
        self$`isRatio` <- `isRatio`
      }
      if (!is.null(`generalType`)) {
        stopifnot(R6::is.R6(`generalType`))
        self$`generalType` <- `generalType`
      }
      if (!is.null(`representation`)) {
        stopifnot(R6::is.R6(`representation`))
        self$`representation` <- `representation`
      }
      if (!is.null(`scale`)) {
        stopifnot(R6::is.R6(`scale`))
        self$`scale` <- `scale`
      }
      if (!is.null(`type`)) {
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return QuantitationType in JSON format
    #' @keywords internal
    toJSON = function() {
      QuantitationTypeObject <- list()
      if (!is.null(self$`name`)) {
        QuantitationTypeObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        QuantitationTypeObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        QuantitationTypeObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`isBackground`)) {
        QuantitationTypeObject[["isBackground"]] <-
          self$`isBackground`
      }
      if (!is.null(self$`isBackgroundSubtracted`)) {
        QuantitationTypeObject[["isBackgroundSubtracted"]] <-
          self$`isBackgroundSubtracted`
      }
      if (!is.null(self$`isBatchCorrected`)) {
        QuantitationTypeObject[["isBatchCorrected"]] <-
          self$`isBatchCorrected`
      }
      if (!is.null(self$`isMaskedPreferred`)) {
        QuantitationTypeObject[["isMaskedPreferred"]] <-
          self$`isMaskedPreferred`
      }
      if (!is.null(self$`isNormalized`)) {
        QuantitationTypeObject[["isNormalized"]] <-
          self$`isNormalized`
      }
      if (!is.null(self$`isPreferred`)) {
        QuantitationTypeObject[["isPreferred"]] <-
          self$`isPreferred`
      }
      if (!is.null(self$`isRecomputedFromRawData`)) {
        QuantitationTypeObject[["isRecomputedFromRawData"]] <-
          self$`isRecomputedFromRawData`
      }
      if (!is.null(self$`isRatio`)) {
        QuantitationTypeObject[["isRatio"]] <-
          self$`isRatio`
      }
      if (!is.null(self$`generalType`)) {
        QuantitationTypeObject[["generalType"]] <-
          self$`generalType`$toJSON()
      }
      if (!is.null(self$`representation`)) {
        QuantitationTypeObject[["representation"]] <-
          self$`representation`$toJSON()
      }
      if (!is.null(self$`scale`)) {
        QuantitationTypeObject[["scale"]] <-
          self$`scale`$toJSON()
      }
      if (!is.null(self$`type`)) {
        QuantitationTypeObject[["type"]] <-
          self$`type`$toJSON()
      }
      QuantitationTypeObject
    },
    #' Deserialize JSON string into an instance of QuantitationType
    #'
    #' @description
    #' Deserialize JSON string into an instance of QuantitationType
    #'
    #' @param input_json the JSON input
    #' @return the instance of QuantitationType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`isBackground`)) {
        self$`isBackground` <- this_object$`isBackground`
      }
      if (!is.null(this_object$`isBackgroundSubtracted`)) {
        self$`isBackgroundSubtracted` <- this_object$`isBackgroundSubtracted`
      }
      if (!is.null(this_object$`isBatchCorrected`)) {
        self$`isBatchCorrected` <- this_object$`isBatchCorrected`
      }
      if (!is.null(this_object$`isMaskedPreferred`)) {
        self$`isMaskedPreferred` <- this_object$`isMaskedPreferred`
      }
      if (!is.null(this_object$`isNormalized`)) {
        self$`isNormalized` <- this_object$`isNormalized`
      }
      if (!is.null(this_object$`isPreferred`)) {
        self$`isPreferred` <- this_object$`isPreferred`
      }
      if (!is.null(this_object$`isRecomputedFromRawData`)) {
        self$`isRecomputedFromRawData` <- this_object$`isRecomputedFromRawData`
      }
      if (!is.null(this_object$`isRatio`)) {
        self$`isRatio` <- this_object$`isRatio`
      }
      if (!is.null(this_object$`generalType`)) {
        generaltype_object <- GeneralType$new()
        generaltype_object$fromJSON(jsonlite::toJSON(this_object$generalType, auto_unbox = TRUE, digits = NA))
        self$`generalType` <- generaltype_object
      }
      if (!is.null(this_object$`representation`)) {
        representation_object <- PrimitiveType$new()
        representation_object$fromJSON(jsonlite::toJSON(this_object$representation, auto_unbox = TRUE, digits = NA))
        self$`representation` <- representation_object
      }
      if (!is.null(this_object$`scale`)) {
        scale_object <- ScaleType$new()
        scale_object$fromJSON(jsonlite::toJSON(this_object$scale, auto_unbox = TRUE, digits = NA))
        self$`scale` <- scale_object
      }
      if (!is.null(this_object$`type`)) {
        type_object <- StandardQuantitationType$new()
        type_object$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
        self$`type` <- type_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return QuantitationType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`isBackground`)) {
          sprintf(
          '"isBackground":
            %s
                    ',
          tolower(self$`isBackground`)
          )
        },
        if (!is.null(self$`isBackgroundSubtracted`)) {
          sprintf(
          '"isBackgroundSubtracted":
            %s
                    ',
          tolower(self$`isBackgroundSubtracted`)
          )
        },
        if (!is.null(self$`isBatchCorrected`)) {
          sprintf(
          '"isBatchCorrected":
            %s
                    ',
          tolower(self$`isBatchCorrected`)
          )
        },
        if (!is.null(self$`isMaskedPreferred`)) {
          sprintf(
          '"isMaskedPreferred":
            %s
                    ',
          tolower(self$`isMaskedPreferred`)
          )
        },
        if (!is.null(self$`isNormalized`)) {
          sprintf(
          '"isNormalized":
            %s
                    ',
          tolower(self$`isNormalized`)
          )
        },
        if (!is.null(self$`isPreferred`)) {
          sprintf(
          '"isPreferred":
            %s
                    ',
          tolower(self$`isPreferred`)
          )
        },
        if (!is.null(self$`isRecomputedFromRawData`)) {
          sprintf(
          '"isRecomputedFromRawData":
            %s
                    ',
          tolower(self$`isRecomputedFromRawData`)
          )
        },
        if (!is.null(self$`isRatio`)) {
          sprintf(
          '"isRatio":
            %s
                    ',
          tolower(self$`isRatio`)
          )
        },
        if (!is.null(self$`generalType`)) {
          sprintf(
          '"generalType":
          %s
          ',
          jsonlite::toJSON(self$`generalType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`representation`)) {
          sprintf(
          '"representation":
          %s
          ',
          jsonlite::toJSON(self$`representation`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`scale`)) {
          sprintf(
          '"scale":
          %s
          ',
          jsonlite::toJSON(self$`scale`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
          '"type":
          %s
          ',
          jsonlite::toJSON(self$`type`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of QuantitationType
    #'
    #' @description
    #' Deserialize JSON string into an instance of QuantitationType
    #'
    #' @param input_json the JSON input
    #' @return the instance of QuantitationType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`isBackground` <- this_object$`isBackground`
      self$`isBackgroundSubtracted` <- this_object$`isBackgroundSubtracted`
      self$`isBatchCorrected` <- this_object$`isBatchCorrected`
      self$`isMaskedPreferred` <- this_object$`isMaskedPreferred`
      self$`isNormalized` <- this_object$`isNormalized`
      self$`isPreferred` <- this_object$`isPreferred`
      self$`isRecomputedFromRawData` <- this_object$`isRecomputedFromRawData`
      self$`isRatio` <- this_object$`isRatio`
      self$`generalType` <- GeneralType$new()$fromJSON(jsonlite::toJSON(this_object$generalType, auto_unbox = TRUE, digits = NA))
      self$`representation` <- PrimitiveType$new()$fromJSON(jsonlite::toJSON(this_object$representation, auto_unbox = TRUE, digits = NA))
      self$`scale` <- ScaleType$new()$fromJSON(jsonlite::toJSON(this_object$scale, auto_unbox = TRUE, digits = NA))
      self$`type` <- StandardQuantitationType$new()$fromJSON(jsonlite::toJSON(this_object$type, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to QuantitationType
    #'
    #' @description
    #' Validate JSON input with respect to QuantitationType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of QuantitationType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
QuantitationType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
QuantitationType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
QuantitationType$lock()


#' Create a new ResponseDataObjectApiInfoValueObject
#'
#' @description
#' ResponseDataObjectApiInfoValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectApiInfoValueObject
#' @description ResponseDataObjectApiInfoValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  \link{ApiInfoValueObject} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectApiInfoValueObject <- R6::R6Class(
  "ResponseDataObjectApiInfoValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectApiInfoValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectApiInfoValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(R6::is.R6(`data`))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectApiInfoValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectApiInfoValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectApiInfoValueObjectObject[["data"]] <-
          self$`data`$toJSON()
      }
      ResponseDataObjectApiInfoValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectApiInfoValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectApiInfoValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectApiInfoValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        data_object <- ApiInfoValueObject$new()
        data_object$fromJSON(jsonlite::toJSON(this_object$data, auto_unbox = TRUE, digits = NA))
        self$`data` <- data_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectApiInfoValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          %s
          ',
          jsonlite::toJSON(self$`data`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectApiInfoValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectApiInfoValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectApiInfoValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiInfoValueObject$new()$fromJSON(jsonlite::toJSON(this_object$data, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectApiInfoValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectApiInfoValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectApiInfoValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectApiInfoValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectApiInfoValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectApiInfoValueObject$lock()


#' Create a new ResponseDataObjectExpressionAnalysisResultSetValueObject
#'
#' @description
#' ResponseDataObjectExpressionAnalysisResultSetValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectExpressionAnalysisResultSetValueObject
#' @description ResponseDataObjectExpressionAnalysisResultSetValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  \link{ExpressionAnalysisResultSetValueObject} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectExpressionAnalysisResultSetValueObject <- R6::R6Class(
  "ResponseDataObjectExpressionAnalysisResultSetValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectExpressionAnalysisResultSetValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectExpressionAnalysisResultSetValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(R6::is.R6(`data`))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectExpressionAnalysisResultSetValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectExpressionAnalysisResultSetValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectExpressionAnalysisResultSetValueObjectObject[["data"]] <-
          self$`data`$toJSON()
      }
      ResponseDataObjectExpressionAnalysisResultSetValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        data_object <- ExpressionAnalysisResultSetValueObject$new()
        data_object$fromJSON(jsonlite::toJSON(this_object$data, auto_unbox = TRUE, digits = NA))
        self$`data` <- data_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectExpressionAnalysisResultSetValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          %s
          ',
          jsonlite::toJSON(self$`data`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ExpressionAnalysisResultSetValueObject$new()$fromJSON(jsonlite::toJSON(this_object$data, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectExpressionAnalysisResultSetValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectExpressionAnalysisResultSetValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectExpressionAnalysisResultSetValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectExpressionAnalysisResultSetValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectExpressionAnalysisResultSetValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectExpressionAnalysisResultSetValueObject$lock()


#' Create a new ResponseDataObjectListAnnotationSearchResultValueObject
#'
#' @description
#' ResponseDataObjectListAnnotationSearchResultValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListAnnotationSearchResultValueObject
#' @description ResponseDataObjectListAnnotationSearchResultValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{AnnotationSearchResultValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListAnnotationSearchResultValueObject <- R6::R6Class(
  "ResponseDataObjectListAnnotationSearchResultValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListAnnotationSearchResultValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListAnnotationSearchResultValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListAnnotationSearchResultValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListAnnotationSearchResultValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListAnnotationSearchResultValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListAnnotationSearchResultValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListAnnotationSearchResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListAnnotationSearchResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListAnnotationSearchResultValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[AnnotationSearchResultValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListAnnotationSearchResultValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListAnnotationSearchResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListAnnotationSearchResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListAnnotationSearchResultValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[AnnotationSearchResultValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListAnnotationSearchResultValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListAnnotationSearchResultValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListAnnotationSearchResultValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListAnnotationSearchResultValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListAnnotationSearchResultValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListAnnotationSearchResultValueObject$lock()


#' Create a new ResponseDataObjectListArrayDesignValueObject
#'
#' @description
#' ResponseDataObjectListArrayDesignValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListArrayDesignValueObject
#' @description ResponseDataObjectListArrayDesignValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{ArrayDesignValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListArrayDesignValueObject <- R6::R6Class(
  "ResponseDataObjectListArrayDesignValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListArrayDesignValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListArrayDesignValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListArrayDesignValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListArrayDesignValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListArrayDesignValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListArrayDesignValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListArrayDesignValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListArrayDesignValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListArrayDesignValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ArrayDesignValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListArrayDesignValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListArrayDesignValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListArrayDesignValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListArrayDesignValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ArrayDesignValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListArrayDesignValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListArrayDesignValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListArrayDesignValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListArrayDesignValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListArrayDesignValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListArrayDesignValueObject$lock()


#' Create a new ResponseDataObjectListBioAssayValueObject
#'
#' @description
#' ResponseDataObjectListBioAssayValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListBioAssayValueObject
#' @description ResponseDataObjectListBioAssayValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{BioAssayValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListBioAssayValueObject <- R6::R6Class(
  "ResponseDataObjectListBioAssayValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListBioAssayValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListBioAssayValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListBioAssayValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListBioAssayValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListBioAssayValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListBioAssayValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListBioAssayValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListBioAssayValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListBioAssayValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[BioAssayValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListBioAssayValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListBioAssayValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListBioAssayValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListBioAssayValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[BioAssayValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListBioAssayValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListBioAssayValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListBioAssayValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListBioAssayValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListBioAssayValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListBioAssayValueObject$lock()


#' Create a new ResponseDataObjectListCoexpressionValueObjectExt
#'
#' @description
#' ResponseDataObjectListCoexpressionValueObjectExt Class
#'
#' @docType class
#' @title ResponseDataObjectListCoexpressionValueObjectExt
#' @description ResponseDataObjectListCoexpressionValueObjectExt Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{CoexpressionValueObjectExt}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListCoexpressionValueObjectExt <- R6::R6Class(
  "ResponseDataObjectListCoexpressionValueObjectExt",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListCoexpressionValueObjectExt class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListCoexpressionValueObjectExt class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListCoexpressionValueObjectExt in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListCoexpressionValueObjectExtObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListCoexpressionValueObjectExtObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListCoexpressionValueObjectExtObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListCoexpressionValueObjectExt
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListCoexpressionValueObjectExt
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListCoexpressionValueObjectExt
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[CoexpressionValueObjectExt]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListCoexpressionValueObjectExt in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListCoexpressionValueObjectExt
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListCoexpressionValueObjectExt
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListCoexpressionValueObjectExt
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[CoexpressionValueObjectExt]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListCoexpressionValueObjectExt
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListCoexpressionValueObjectExt and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListCoexpressionValueObjectExt
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListCoexpressionValueObjectExt$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListCoexpressionValueObjectExt$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListCoexpressionValueObjectExt$lock()


#' Create a new ResponseDataObjectListDifferentialExpressionAnalysisValueObject
#'
#' @description
#' ResponseDataObjectListDifferentialExpressionAnalysisValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListDifferentialExpressionAnalysisValueObject
#' @description ResponseDataObjectListDifferentialExpressionAnalysisValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{DifferentialExpressionAnalysisValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListDifferentialExpressionAnalysisValueObject <- R6::R6Class(
  "ResponseDataObjectListDifferentialExpressionAnalysisValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListDifferentialExpressionAnalysisValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListDifferentialExpressionAnalysisValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListDifferentialExpressionAnalysisValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListDifferentialExpressionAnalysisValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListDifferentialExpressionAnalysisValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListDifferentialExpressionAnalysisValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[DifferentialExpressionAnalysisValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListDifferentialExpressionAnalysisValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[DifferentialExpressionAnalysisValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListDifferentialExpressionAnalysisValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListDifferentialExpressionAnalysisValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListDifferentialExpressionAnalysisValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListDifferentialExpressionAnalysisValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListDifferentialExpressionAnalysisValueObject$lock()


#' Create a new ResponseDataObjectListExperimentExpressionLevelsValueObject
#'
#' @description
#' ResponseDataObjectListExperimentExpressionLevelsValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListExperimentExpressionLevelsValueObject
#' @description ResponseDataObjectListExperimentExpressionLevelsValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{ExperimentExpressionLevelsValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListExperimentExpressionLevelsValueObject <- R6::R6Class(
  "ResponseDataObjectListExperimentExpressionLevelsValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListExperimentExpressionLevelsValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListExperimentExpressionLevelsValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListExperimentExpressionLevelsValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListExperimentExpressionLevelsValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListExperimentExpressionLevelsValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListExperimentExpressionLevelsValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListExperimentExpressionLevelsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListExperimentExpressionLevelsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListExperimentExpressionLevelsValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ExperimentExpressionLevelsValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListExperimentExpressionLevelsValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListExperimentExpressionLevelsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListExperimentExpressionLevelsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListExperimentExpressionLevelsValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[ExperimentExpressionLevelsValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListExperimentExpressionLevelsValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListExperimentExpressionLevelsValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListExperimentExpressionLevelsValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListExperimentExpressionLevelsValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListExperimentExpressionLevelsValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListExperimentExpressionLevelsValueObject$lock()


#' Create a new ResponseDataObjectListGeneOntologyTermValueObject
#'
#' @description
#' ResponseDataObjectListGeneOntologyTermValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListGeneOntologyTermValueObject
#' @description ResponseDataObjectListGeneOntologyTermValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{GeneOntologyTermValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListGeneOntologyTermValueObject <- R6::R6Class(
  "ResponseDataObjectListGeneOntologyTermValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListGeneOntologyTermValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListGeneOntologyTermValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListGeneOntologyTermValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListGeneOntologyTermValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListGeneOntologyTermValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListGeneOntologyTermValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneOntologyTermValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneOntologyTermValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListGeneOntologyTermValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[GeneOntologyTermValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListGeneOntologyTermValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneOntologyTermValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneOntologyTermValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListGeneOntologyTermValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[GeneOntologyTermValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListGeneOntologyTermValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListGeneOntologyTermValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListGeneOntologyTermValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListGeneOntologyTermValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListGeneOntologyTermValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListGeneOntologyTermValueObject$lock()


#' Create a new ResponseDataObjectListGeneValueObject
#'
#' @description
#' ResponseDataObjectListGeneValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListGeneValueObject
#' @description ResponseDataObjectListGeneValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{GeneValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListGeneValueObject <- R6::R6Class(
  "ResponseDataObjectListGeneValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListGeneValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListGeneValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListGeneValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListGeneValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListGeneValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListGeneValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListGeneValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListGeneValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListGeneValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListGeneValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[GeneValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListGeneValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListGeneValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListGeneValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListGeneValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListGeneValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListGeneValueObject$lock()


#' Create a new ResponseDataObjectListPhysicalLocationValueObject
#'
#' @description
#' ResponseDataObjectListPhysicalLocationValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListPhysicalLocationValueObject
#' @description ResponseDataObjectListPhysicalLocationValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{PhysicalLocationValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListPhysicalLocationValueObject <- R6::R6Class(
  "ResponseDataObjectListPhysicalLocationValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListPhysicalLocationValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListPhysicalLocationValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListPhysicalLocationValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListPhysicalLocationValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListPhysicalLocationValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListPhysicalLocationValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListPhysicalLocationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListPhysicalLocationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListPhysicalLocationValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[PhysicalLocationValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListPhysicalLocationValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListPhysicalLocationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListPhysicalLocationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListPhysicalLocationValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[PhysicalLocationValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListPhysicalLocationValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListPhysicalLocationValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListPhysicalLocationValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListPhysicalLocationValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListPhysicalLocationValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListPhysicalLocationValueObject$lock()


#' Create a new ResponseDataObjectListTaxonValueObject
#'
#' @description
#' ResponseDataObjectListTaxonValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectListTaxonValueObject
#' @description ResponseDataObjectListTaxonValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{TaxonValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectListTaxonValueObject <- R6::R6Class(
  "ResponseDataObjectListTaxonValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectListTaxonValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectListTaxonValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListTaxonValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectListTaxonValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectListTaxonValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectListTaxonValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListTaxonValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListTaxonValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListTaxonValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[TaxonValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectListTaxonValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectListTaxonValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectListTaxonValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectListTaxonValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[TaxonValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectListTaxonValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectListTaxonValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectListTaxonValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectListTaxonValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectListTaxonValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectListTaxonValueObject$lock()


#' Create a new ResponseDataObjectSetAnnotationValueObject
#'
#' @description
#' ResponseDataObjectSetAnnotationValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectSetAnnotationValueObject
#' @description ResponseDataObjectSetAnnotationValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{AnnotationValueObject}) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectSetAnnotationValueObject <- R6::R6Class(
  "ResponseDataObjectSetAnnotationValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectSetAnnotationValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectSetAnnotationValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectSetAnnotationValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectSetAnnotationValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectSetAnnotationValueObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      ResponseDataObjectSetAnnotationValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectSetAnnotationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectSetAnnotationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectSetAnnotationValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "set[AnnotationValueObject]", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectSetAnnotationValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectSetAnnotationValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectSetAnnotationValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectSetAnnotationValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "set[AnnotationValueObject]", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectSetAnnotationValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectSetAnnotationValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectSetAnnotationValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {

      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()

      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectSetAnnotationValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectSetAnnotationValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectSetAnnotationValueObject$lock()


#' Create a new ResponseDataObjectSimpleSVDValueObject
#'
#' @description
#' ResponseDataObjectSimpleSVDValueObject Class
#'
#' @docType class
#' @title ResponseDataObjectSimpleSVDValueObject
#' @description ResponseDataObjectSimpleSVDValueObject Class
#' @format An \code{R6Class} generator object
#' @field data  \link{SimpleSVDValueObject} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseDataObjectSimpleSVDValueObject <- R6::R6Class(
  "ResponseDataObjectSimpleSVDValueObject",
  public = list(
    `data` = NULL,
    #' Initialize a new ResponseDataObjectSimpleSVDValueObject class.
    #'
    #' @description
    #' Initialize a new ResponseDataObjectSimpleSVDValueObject class.
    #'
    #' @param data data
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(R6::is.R6(`data`))
        self$`data` <- `data`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectSimpleSVDValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseDataObjectSimpleSVDValueObjectObject <- list()
      if (!is.null(self$`data`)) {
        ResponseDataObjectSimpleSVDValueObjectObject[["data"]] <-
          self$`data`$toJSON()
      }
      ResponseDataObjectSimpleSVDValueObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectSimpleSVDValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectSimpleSVDValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectSimpleSVDValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        data_object <- SimpleSVDValueObject$new()
        data_object$fromJSON(jsonlite::toJSON(this_object$data, auto_unbox = TRUE, digits = NA))
        self$`data` <- data_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseDataObjectSimpleSVDValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          %s
          ',
          jsonlite::toJSON(self$`data`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseDataObjectSimpleSVDValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseDataObjectSimpleSVDValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseDataObjectSimpleSVDValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- SimpleSVDValueObject$new()$fromJSON(jsonlite::toJSON(this_object$data, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to ResponseDataObjectSimpleSVDValueObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseDataObjectSimpleSVDValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseDataObjectSimpleSVDValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseDataObjectSimpleSVDValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseDataObjectSimpleSVDValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseDataObjectSimpleSVDValueObject$lock()


#' Create a new ResponseErrorObject
#'
#' @description
#' ResponseErrorObject Class
#'
#' @docType class
#' @title ResponseErrorObject
#' @description ResponseErrorObject Class
#' @format An \code{R6Class} generator object
#' @field error  \link{WellComposedErrorBody} optional
#' @field apiVersion  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ResponseErrorObject <- R6::R6Class(
  "ResponseErrorObject",
  public = list(
    `error` = NULL,
    `apiVersion` = NULL,
    #' Initialize a new ResponseErrorObject class.
    #'
    #' @description
    #' Initialize a new ResponseErrorObject class.
    #'
    #' @param error error
    #' @param apiVersion apiVersion
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `error` = NULL, `apiVersion` = NULL, ...
    ) {
      if (!is.null(`error`)) {
        stopifnot(R6::is.R6(`error`))
        self$`error` <- `error`
      }
      if (!is.null(`apiVersion`)) {
        stopifnot(is.character(`apiVersion`), length(`apiVersion`) == 1)
        self$`apiVersion` <- `apiVersion`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseErrorObject in JSON format
    #' @keywords internal
    toJSON = function() {
      ResponseErrorObjectObject <- list()
      if (!is.null(self$`error`)) {
        ResponseErrorObjectObject[["error"]] <-
          self$`error`$toJSON()
      }
      if (!is.null(self$`apiVersion`)) {
        ResponseErrorObjectObject[["apiVersion"]] <-
          self$`apiVersion`
      }
      ResponseErrorObjectObject
    },
    #' Deserialize JSON string into an instance of ResponseErrorObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseErrorObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseErrorObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`error`)) {
        error_object <- WellComposedErrorBody$new()
        error_object$fromJSON(jsonlite::toJSON(this_object$error, auto_unbox = TRUE, digits = NA))
        self$`error` <- error_object
      }
      if (!is.null(this_object$`apiVersion`)) {
        self$`apiVersion` <- this_object$`apiVersion`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ResponseErrorObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`error`)) {
          sprintf(
          '"error":
          %s
          ',
          jsonlite::toJSON(self$`error`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`apiVersion`)) {
          sprintf(
          '"apiVersion":
            "%s"
                    ',
          self$`apiVersion`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ResponseErrorObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of ResponseErrorObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of ResponseErrorObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`error` <- WellComposedErrorBody$new()$fromJSON(jsonlite::toJSON(this_object$error, auto_unbox = TRUE, digits = NA))
      self$`apiVersion` <- this_object$`apiVersion`
      self
    },
    #' Validate JSON input with respect to ResponseErrorObject
    #'
    #' @description
    #' Validate JSON input with respect to ResponseErrorObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ResponseErrorObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ResponseErrorObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ResponseErrorObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ResponseErrorObject$lock()


#' Create a new ScaleType
#'
#' @description
#' ScaleType Class
#'
#' @docType class
#' @title ScaleType
#' @description ScaleType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ScaleType <- R6::R6Class(
  "ScaleType",
  public = list(
    `value` = NULL,
    #' Initialize a new ScaleType class.
    #'
    #' @description
    #' Initialize a new ScaleType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ScaleType in JSON format
    #' @keywords internal
    toJSON = function() {
      ScaleTypeObject <- list()
      if (!is.null(self$`value`)) {
        ScaleTypeObject[["value"]] <-
          self$`value`
      }
      ScaleTypeObject
    },
    #' Deserialize JSON string into an instance of ScaleType
    #'
    #' @description
    #' Deserialize JSON string into an instance of ScaleType
    #'
    #' @param input_json the JSON input
    #' @return the instance of ScaleType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ScaleType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ScaleType
    #'
    #' @description
    #' Deserialize JSON string into an instance of ScaleType
    #'
    #' @param input_json the JSON input
    #' @return the instance of ScaleType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to ScaleType
    #'
    #' @description
    #' Validate JSON input with respect to ScaleType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ScaleType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ScaleType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ScaleType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ScaleType$lock()


#' Create a new SearchResultValueObject
#'
#' @description
#' SearchResultValueObject Class
#'
#' @docType class
#' @title SearchResultValueObject
#' @description SearchResultValueObject Class
#' @format An \code{R6Class} generator object
#' @field resultId  integer optional
#' @field resultType  character optional
#' @field score  numeric optional
#' @field resultObject  \link{IdentifiableValueObjectIdentifiable} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
SearchResultValueObject <- R6::R6Class(
  "SearchResultValueObject",
  public = list(
    `resultId` = NULL,
    `resultType` = NULL,
    `score` = NULL,
    `resultObject` = NULL,
    #' Initialize a new SearchResultValueObject class.
    #'
    #' @description
    #' Initialize a new SearchResultValueObject class.
    #'
    #' @param resultId resultId
    #' @param resultType resultType
    #' @param score score
    #' @param resultObject resultObject
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `resultId` = NULL, `resultType` = NULL, `score` = NULL, `resultObject` = NULL, ...
    ) {
      if (!is.null(`resultId`)) {
        stopifnot(is.numeric(`resultId`), length(`resultId`) == 1)
        self$`resultId` <- `resultId`
      }
      if (!is.null(`resultType`)) {
        stopifnot(is.character(`resultType`), length(`resultType`) == 1)
        self$`resultType` <- `resultType`
      }
      if (!is.null(`score`)) {
        stopifnot(is.numeric(`score`), length(`score`) == 1)
        self$`score` <- `score`
      }
      if (!is.null(`resultObject`)) {
        stopifnot(R6::is.R6(`resultObject`))
        self$`resultObject` <- `resultObject`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SearchResultValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      SearchResultValueObjectObject <- list()
      if (!is.null(self$`resultId`)) {
        SearchResultValueObjectObject[["resultId"]] <-
          self$`resultId`
      }
      if (!is.null(self$`resultType`)) {
        SearchResultValueObjectObject[["resultType"]] <-
          self$`resultType`
      }
      if (!is.null(self$`score`)) {
        SearchResultValueObjectObject[["score"]] <-
          self$`score`
      }
      if (!is.null(self$`resultObject`)) {
        SearchResultValueObjectObject[["resultObject"]] <-
          self$`resultObject`$toJSON()
      }
      SearchResultValueObjectObject
    },
    #' Deserialize JSON string into an instance of SearchResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SearchResultValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`resultId`)) {
        self$`resultId` <- this_object$`resultId`
      }
      if (!is.null(this_object$`resultType`)) {
        self$`resultType` <- this_object$`resultType`
      }
      if (!is.null(this_object$`score`)) {
        self$`score` <- this_object$`score`
      }
      if (!is.null(this_object$`resultObject`)) {
        resultobject_object <- IdentifiableValueObjectIdentifiable$new()
        resultobject_object$fromJSON(jsonlite::toJSON(this_object$resultObject, auto_unbox = TRUE, digits = NA))
        self$`resultObject` <- resultobject_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SearchResultValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`resultId`)) {
          sprintf(
          '"resultId":
            %d
                    ',
          self$`resultId`
          )
        },
        if (!is.null(self$`resultType`)) {
          sprintf(
          '"resultType":
            "%s"
                    ',
          self$`resultType`
          )
        },
        if (!is.null(self$`score`)) {
          sprintf(
          '"score":
            %d
                    ',
          self$`score`
          )
        },
        if (!is.null(self$`resultObject`)) {
          sprintf(
          '"resultObject":
          %s
          ',
          jsonlite::toJSON(self$`resultObject`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of SearchResultValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchResultValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SearchResultValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`resultId` <- this_object$`resultId`
      self$`resultType` <- this_object$`resultType`
      self$`score` <- this_object$`score`
      self$`resultObject` <- IdentifiableValueObjectIdentifiable$new()$fromJSON(jsonlite::toJSON(this_object$resultObject, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to SearchResultValueObject
    #'
    #' @description
    #' Validate JSON input with respect to SearchResultValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of SearchResultValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
SearchResultValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
SearchResultValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
SearchResultValueObject$lock()


#' Create a new SearchResultsResponseDataObject
#'
#' @description
#' SearchResultsResponseDataObject Class
#'
#' @docType class
#' @title SearchResultsResponseDataObject
#' @description SearchResultsResponseDataObject Class
#' @format An \code{R6Class} generator object
#' @field data  list(\link{SearchResultValueObject}) optional
#' @field searchSettings  \link{SearchSettingsValueObject} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
SearchResultsResponseDataObject <- R6::R6Class(
  "SearchResultsResponseDataObject",
  public = list(
    `data` = NULL,
    `searchSettings` = NULL,
    #' Initialize a new SearchResultsResponseDataObject class.
    #'
    #' @description
    #' Initialize a new SearchResultsResponseDataObject class.
    #'
    #' @param data data
    #' @param searchSettings searchSettings
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `data` = NULL, `searchSettings` = NULL, ...
    ) {
      if (!is.null(`data`)) {
        stopifnot(is.vector(`data`), length(`data`) != 0)
        sapply(`data`, function(x) stopifnot(R6::is.R6(x)))
        self$`data` <- `data`
      }
      if (!is.null(`searchSettings`)) {
        stopifnot(R6::is.R6(`searchSettings`))
        self$`searchSettings` <- `searchSettings`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SearchResultsResponseDataObject in JSON format
    #' @keywords internal
    toJSON = function() {
      SearchResultsResponseDataObjectObject <- list()
      if (!is.null(self$`data`)) {
        SearchResultsResponseDataObjectObject[["data"]] <-
          lapply(self$`data`, function(x) x$toJSON())
      }
      if (!is.null(self$`searchSettings`)) {
        SearchResultsResponseDataObjectObject[["searchSettings"]] <-
          self$`searchSettings`$toJSON()
      }
      SearchResultsResponseDataObjectObject
    },
    #' Deserialize JSON string into an instance of SearchResultsResponseDataObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchResultsResponseDataObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SearchResultsResponseDataObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`data`)) {
        self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[SearchResultValueObject]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`searchSettings`)) {
        searchsettings_object <- SearchSettingsValueObject$new()
        searchsettings_object$fromJSON(jsonlite::toJSON(this_object$searchSettings, auto_unbox = TRUE, digits = NA))
        self$`searchSettings` <- searchsettings_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SearchResultsResponseDataObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`data`)) {
          sprintf(
          '"data":
          [%s]
',
          paste(sapply(self$`data`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`searchSettings`)) {
          sprintf(
          '"searchSettings":
          %s
          ',
          jsonlite::toJSON(self$`searchSettings`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of SearchResultsResponseDataObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchResultsResponseDataObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SearchResultsResponseDataObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`data` <- ApiClient$new()$deserializeObj(this_object$`data`, "array[SearchResultValueObject]", loadNamespace("gemma.R"))
      self$`searchSettings` <- SearchSettingsValueObject$new()$fromJSON(jsonlite::toJSON(this_object$searchSettings, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to SearchResultsResponseDataObject
    #'
    #' @description
    #' Validate JSON input with respect to SearchResultsResponseDataObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of SearchResultsResponseDataObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
SearchResultsResponseDataObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
SearchResultsResponseDataObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
SearchResultsResponseDataObject$lock()


#' Create a new SearchSettingsValueObject
#'
#' @description
#' SearchSettingsValueObject Class
#'
#' @docType class
#' @title SearchSettingsValueObject
#' @description SearchSettingsValueObject Class
#' @format An \code{R6Class} generator object
#' @field query  character optional
#' @field resultTypes  list(character) optional
#' @field taxon  \link{TaxonValueObject} optional
#' @field platform  \link{ArrayDesignValueObject} optional
#' @field maxResults  integer optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
SearchSettingsValueObject <- R6::R6Class(
  "SearchSettingsValueObject",
  public = list(
    `query` = NULL,
    `resultTypes` = NULL,
    `taxon` = NULL,
    `platform` = NULL,
    `maxResults` = NULL,
    #' Initialize a new SearchSettingsValueObject class.
    #'
    #' @description
    #' Initialize a new SearchSettingsValueObject class.
    #'
    #' @param query query
    #' @param resultTypes resultTypes
    #' @param taxon taxon
    #' @param platform platform
    #' @param maxResults maxResults
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `query` = NULL, `resultTypes` = NULL, `taxon` = NULL, `platform` = NULL, `maxResults` = NULL, ...
    ) {
      if (!is.null(`query`)) {
        stopifnot(is.character(`query`), length(`query`) == 1)
        self$`query` <- `query`
      }
      if (!is.null(`resultTypes`)) {
        stopifnot(is.vector(`resultTypes`), length(`resultTypes`) != 0)
        sapply(`resultTypes`, function(x) stopifnot(is.character(x)))
        self$`resultTypes` <- `resultTypes`
      }
      if (!is.null(`taxon`)) {
        stopifnot(R6::is.R6(`taxon`))
        self$`taxon` <- `taxon`
      }
      if (!is.null(`platform`)) {
        stopifnot(R6::is.R6(`platform`))
        self$`platform` <- `platform`
      }
      if (!is.null(`maxResults`)) {
        stopifnot(is.numeric(`maxResults`), length(`maxResults`) == 1)
        self$`maxResults` <- `maxResults`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SearchSettingsValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      SearchSettingsValueObjectObject <- list()
      if (!is.null(self$`query`)) {
        SearchSettingsValueObjectObject[["query"]] <-
          self$`query`
      }
      if (!is.null(self$`resultTypes`)) {
        SearchSettingsValueObjectObject[["resultTypes"]] <-
          self$`resultTypes`
      }
      if (!is.null(self$`taxon`)) {
        SearchSettingsValueObjectObject[["taxon"]] <-
          self$`taxon`$toJSON()
      }
      if (!is.null(self$`platform`)) {
        SearchSettingsValueObjectObject[["platform"]] <-
          self$`platform`$toJSON()
      }
      if (!is.null(self$`maxResults`)) {
        SearchSettingsValueObjectObject[["maxResults"]] <-
          self$`maxResults`
      }
      SearchSettingsValueObjectObject
    },
    #' Deserialize JSON string into an instance of SearchSettingsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchSettingsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SearchSettingsValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`query`)) {
        self$`query` <- this_object$`query`
      }
      if (!is.null(this_object$`resultTypes`)) {
        self$`resultTypes` <- ApiClient$new()$deserializeObj(this_object$`resultTypes`, "set[character]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`taxon`)) {
        taxon_object <- TaxonValueObject$new()
        taxon_object$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
        self$`taxon` <- taxon_object
      }
      if (!is.null(this_object$`platform`)) {
        platform_object <- ArrayDesignValueObject$new()
        platform_object$fromJSON(jsonlite::toJSON(this_object$platform, auto_unbox = TRUE, digits = NA))
        self$`platform` <- platform_object
      }
      if (!is.null(this_object$`maxResults`)) {
        self$`maxResults` <- this_object$`maxResults`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SearchSettingsValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`query`)) {
          sprintf(
          '"query":
            "%s"
                    ',
          self$`query`
          )
        },
        if (!is.null(self$`resultTypes`)) {
          sprintf(
          '"resultTypes":
             [%s]
          ',
          paste(unlist(lapply(self$`resultTypes`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`taxon`)) {
          sprintf(
          '"taxon":
          %s
          ',
          jsonlite::toJSON(self$`taxon`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`platform`)) {
          sprintf(
          '"platform":
          %s
          ',
          jsonlite::toJSON(self$`platform`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`maxResults`)) {
          sprintf(
          '"maxResults":
            %d
                    ',
          self$`maxResults`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of SearchSettingsValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchSettingsValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SearchSettingsValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`query` <- this_object$`query`
      self$`resultTypes` <- ApiClient$new()$deserializeObj(this_object$`resultTypes`, "set[character]", loadNamespace("gemma.R"))
      self$`taxon` <- TaxonValueObject$new()$fromJSON(jsonlite::toJSON(this_object$taxon, auto_unbox = TRUE, digits = NA))
      self$`platform` <- ArrayDesignValueObject$new()$fromJSON(jsonlite::toJSON(this_object$platform, auto_unbox = TRUE, digits = NA))
      self$`maxResults` <- this_object$`maxResults`
      self
    },
    #' Validate JSON input with respect to SearchSettingsValueObject
    #'
    #' @description
    #' Validate JSON input with respect to SearchSettingsValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of SearchSettingsValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {

      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()

      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
SearchSettingsValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
SearchSettingsValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
SearchSettingsValueObject$lock()


#' @docType class
#' @title SearchTaxonDatasetsTaxonParameter
#'
#' @description SearchTaxonDatasetsTaxonParameter Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
SearchTaxonDatasetsTaxonParameter <- R6::R6Class(
  "SearchTaxonDatasetsTaxonParameter",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new SearchTaxonDatasetsTaxonParameter.
    #'
    #' @description
    #' Initialize a new SearchTaxonDatasetsTaxonParameter.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize SearchTaxonDatasetsTaxonParameter with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of SearchTaxonDatasetsTaxonParameter.
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchTaxonDatasetsTaxonParameter.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of SearchTaxonDatasetsTaxonParameter.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of SearchTaxonDatasetsTaxonParameter.
    #'
    #' @description
    #' Deserialize JSON string into an instance of SearchTaxonDatasetsTaxonParameter.
    #'
    #' @param input The input JSON.
    #' @return An instance of SearchTaxonDatasetsTaxonParameter.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into SearchTaxonDatasetsTaxonParameter with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into SearchTaxonDatasetsTaxonParameter with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize SearchTaxonDatasetsTaxonParameter to JSON string.
    #'
    #' @description
    #' Serialize SearchTaxonDatasetsTaxonParameter to JSON string.
    #'
    #' @return JSON string representation of the SearchTaxonDatasetsTaxonParameter.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize SearchTaxonDatasetsTaxonParameter to JSON.
    #'
    #' @description
    #' Serialize SearchTaxonDatasetsTaxonParameter to JSON.
    #'
    #' @return JSON representation of the SearchTaxonDatasetsTaxonParameter.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to SearchTaxonDatasetsTaxonParameter.
    #'
    #' @description
    #' Validate the input JSON with respect to SearchTaxonDatasetsTaxonParameter and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
SearchTaxonDatasetsTaxonParameter$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
SearchTaxonDatasetsTaxonParameter$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
SearchTaxonDatasetsTaxonParameter$lock()


#' Create a new SequenceType
#'
#' @description
#' SequenceType Class
#'
#' @docType class
#' @title SequenceType
#' @description SequenceType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
SequenceType <- R6::R6Class(
  "SequenceType",
  public = list(
    `value` = NULL,
    #' Initialize a new SequenceType class.
    #'
    #' @description
    #' Initialize a new SequenceType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SequenceType in JSON format
    #' @keywords internal
    toJSON = function() {
      SequenceTypeObject <- list()
      if (!is.null(self$`value`)) {
        SequenceTypeObject[["value"]] <-
          self$`value`
      }
      SequenceTypeObject
    },
    #' Deserialize JSON string into an instance of SequenceType
    #'
    #' @description
    #' Deserialize JSON string into an instance of SequenceType
    #'
    #' @param input_json the JSON input
    #' @return the instance of SequenceType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SequenceType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of SequenceType
    #'
    #' @description
    #' Deserialize JSON string into an instance of SequenceType
    #'
    #' @param input_json the JSON input
    #' @return the instance of SequenceType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to SequenceType
    #'
    #' @description
    #' Validate JSON input with respect to SequenceType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of SequenceType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
SequenceType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
SequenceType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
SequenceType$lock()


#' Create a new SimpleSVDValueObject
#'
#' @description
#' SimpleSVDValueObject Class
#'
#' @docType class
#' @title SimpleSVDValueObject
#' @description SimpleSVDValueObject Class
#' @format An \code{R6Class} generator object
#' @field bioMaterialIds  list(integer) optional
#' @field variances  list(numeric) optional
#' @field getvMatrix  \link{DoubleMatrixLongInteger} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
SimpleSVDValueObject <- R6::R6Class(
  "SimpleSVDValueObject",
  public = list(
    `bioMaterialIds` = NULL,
    `variances` = NULL,
    `getvMatrix` = NULL,
    #' Initialize a new SimpleSVDValueObject class.
    #'
    #' @description
    #' Initialize a new SimpleSVDValueObject class.
    #'
    #' @param bioMaterialIds bioMaterialIds
    #' @param variances variances
    #' @param getvMatrix getvMatrix
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `bioMaterialIds` = NULL, `variances` = NULL, `getvMatrix` = NULL, ...
    ) {
      if (!is.null(`bioMaterialIds`)) {
        stopifnot(is.vector(`bioMaterialIds`), length(`bioMaterialIds`) != 0)
        sapply(`bioMaterialIds`, function(x) stopifnot(is.character(x)))
        self$`bioMaterialIds` <- `bioMaterialIds`
      }
      if (!is.null(`variances`)) {
        stopifnot(is.vector(`variances`), length(`variances`) != 0)
        sapply(`variances`, function(x) stopifnot(is.character(x)))
        self$`variances` <- `variances`
      }
      if (!is.null(`getvMatrix`)) {
        stopifnot(R6::is.R6(`getvMatrix`))
        self$`getvMatrix` <- `getvMatrix`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SimpleSVDValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      SimpleSVDValueObjectObject <- list()
      if (!is.null(self$`bioMaterialIds`)) {
        SimpleSVDValueObjectObject[["bioMaterialIds"]] <-
          self$`bioMaterialIds`
      }
      if (!is.null(self$`variances`)) {
        SimpleSVDValueObjectObject[["variances"]] <-
          self$`variances`
      }
      if (!is.null(self$`getvMatrix`)) {
        SimpleSVDValueObjectObject[["getvMatrix"]] <-
          self$`getvMatrix`$toJSON()
      }
      SimpleSVDValueObjectObject
    },
    #' Deserialize JSON string into an instance of SimpleSVDValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SimpleSVDValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SimpleSVDValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`bioMaterialIds`)) {
        self$`bioMaterialIds` <- ApiClient$new()$deserializeObj(this_object$`bioMaterialIds`, "array[integer]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`variances`)) {
        self$`variances` <- ApiClient$new()$deserializeObj(this_object$`variances`, "array[numeric]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`getvMatrix`)) {
        getvmatrix_object <- DoubleMatrixLongInteger$new()
        getvmatrix_object$fromJSON(jsonlite::toJSON(this_object$getvMatrix, auto_unbox = TRUE, digits = NA))
        self$`getvMatrix` <- getvmatrix_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SimpleSVDValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`bioMaterialIds`)) {
          sprintf(
          '"bioMaterialIds":
             [%s]
          ',
          paste(unlist(lapply(self$`bioMaterialIds`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`variances`)) {
          sprintf(
          '"variances":
             [%s]
          ',
          paste(unlist(lapply(self$`variances`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`getvMatrix`)) {
          sprintf(
          '"getvMatrix":
          %s
          ',
          jsonlite::toJSON(self$`getvMatrix`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of SimpleSVDValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SimpleSVDValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SimpleSVDValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`bioMaterialIds` <- ApiClient$new()$deserializeObj(this_object$`bioMaterialIds`, "array[integer]", loadNamespace("gemma.R"))
      self$`variances` <- ApiClient$new()$deserializeObj(this_object$`variances`, "array[numeric]", loadNamespace("gemma.R"))
      self$`getvMatrix` <- DoubleMatrixLongInteger$new()$fromJSON(jsonlite::toJSON(this_object$getvMatrix, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to SimpleSVDValueObject
    #'
    #' @description
    #' Validate JSON input with respect to SimpleSVDValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of SimpleSVDValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
SimpleSVDValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
SimpleSVDValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
SimpleSVDValueObject$lock()


#' Create a new SortValueObject
#'
#' @description
#' SortValueObject Class
#'
#' @docType class
#' @title SortValueObject
#' @description SortValueObject Class
#' @format An \code{R6Class} generator object
#' @field orderBy  character optional
#' @field direction  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
SortValueObject <- R6::R6Class(
  "SortValueObject",
  public = list(
    `orderBy` = NULL,
    `direction` = NULL,
    #' Initialize a new SortValueObject class.
    #'
    #' @description
    #' Initialize a new SortValueObject class.
    #'
    #' @param orderBy orderBy
    #' @param direction direction
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `orderBy` = NULL, `direction` = NULL, ...
    ) {
      if (!is.null(`orderBy`)) {
        stopifnot(is.character(`orderBy`), length(`orderBy`) == 1)
        self$`orderBy` <- `orderBy`
      }
      if (!is.null(`direction`)) {
        stopifnot(is.character(`direction`), length(`direction`) == 1)
        self$`direction` <- `direction`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SortValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      SortValueObjectObject <- list()
      if (!is.null(self$`orderBy`)) {
        SortValueObjectObject[["orderBy"]] <-
          self$`orderBy`
      }
      if (!is.null(self$`direction`)) {
        SortValueObjectObject[["direction"]] <-
          self$`direction`
      }
      SortValueObjectObject
    },
    #' Deserialize JSON string into an instance of SortValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SortValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SortValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`orderBy`)) {
        self$`orderBy` <- this_object$`orderBy`
      }
      if (!is.null(this_object$`direction`)) {
        self$`direction` <- this_object$`direction`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return SortValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`orderBy`)) {
          sprintf(
          '"orderBy":
            "%s"
                    ',
          self$`orderBy`
          )
        },
        if (!is.null(self$`direction`)) {
          sprintf(
          '"direction":
            "%s"
                    ',
          self$`direction`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of SortValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of SortValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of SortValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`orderBy` <- this_object$`orderBy`
      self$`direction` <- this_object$`direction`
      self
    },
    #' Validate JSON input with respect to SortValueObject
    #'
    #' @description
    #' Validate JSON input with respect to SortValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of SortValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
SortValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
SortValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
SortValueObject$lock()


#' Create a new StandardQuantitationType
#'
#' @description
#' StandardQuantitationType Class
#'
#' @docType class
#' @title StandardQuantitationType
#' @description StandardQuantitationType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
StandardQuantitationType <- R6::R6Class(
  "StandardQuantitationType",
  public = list(
    `value` = NULL,
    #' Initialize a new StandardQuantitationType class.
    #'
    #' @description
    #' Initialize a new StandardQuantitationType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return StandardQuantitationType in JSON format
    #' @keywords internal
    toJSON = function() {
      StandardQuantitationTypeObject <- list()
      if (!is.null(self$`value`)) {
        StandardQuantitationTypeObject[["value"]] <-
          self$`value`
      }
      StandardQuantitationTypeObject
    },
    #' Deserialize JSON string into an instance of StandardQuantitationType
    #'
    #' @description
    #' Deserialize JSON string into an instance of StandardQuantitationType
    #'
    #' @param input_json the JSON input
    #' @return the instance of StandardQuantitationType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return StandardQuantitationType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of StandardQuantitationType
    #'
    #' @description
    #' Deserialize JSON string into an instance of StandardQuantitationType
    #'
    #' @param input_json the JSON input
    #' @return the instance of StandardQuantitationType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to StandardQuantitationType
    #'
    #' @description
    #' Validate JSON input with respect to StandardQuantitationType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of StandardQuantitationType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
StandardQuantitationType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
StandardQuantitationType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
StandardQuantitationType$lock()


#' Create a new Taxon
#'
#' @description
#' Taxon Class
#'
#' @docType class
#' @title Taxon
#' @description Taxon Class
#' @format An \code{R6Class} generator object
#' @field scientificName  character optional
#' @field commonName  character optional
#' @field ncbiId  integer optional
#' @field isGenesUsable  character optional
#' @field secondaryNcbiId  integer optional
#' @field id  integer optional
#' @field externalDatabase  \link{ExternalDatabase} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
Taxon <- R6::R6Class(
  "Taxon",
  public = list(
    `scientificName` = NULL,
    `commonName` = NULL,
    `ncbiId` = NULL,
    `isGenesUsable` = NULL,
    `secondaryNcbiId` = NULL,
    `id` = NULL,
    `externalDatabase` = NULL,
    #' Initialize a new Taxon class.
    #'
    #' @description
    #' Initialize a new Taxon class.
    #'
    #' @param scientificName scientificName
    #' @param commonName commonName
    #' @param ncbiId ncbiId
    #' @param isGenesUsable isGenesUsable
    #' @param secondaryNcbiId secondaryNcbiId
    #' @param id id
    #' @param externalDatabase externalDatabase
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `scientificName` = NULL, `commonName` = NULL, `ncbiId` = NULL, `isGenesUsable` = NULL, `secondaryNcbiId` = NULL, `id` = NULL, `externalDatabase` = NULL, ...
    ) {
      if (!is.null(`scientificName`)) {
        stopifnot(is.character(`scientificName`), length(`scientificName`) == 1)
        self$`scientificName` <- `scientificName`
      }
      if (!is.null(`commonName`)) {
        stopifnot(is.character(`commonName`), length(`commonName`) == 1)
        self$`commonName` <- `commonName`
      }
      if (!is.null(`ncbiId`)) {
        stopifnot(is.numeric(`ncbiId`), length(`ncbiId`) == 1)
        self$`ncbiId` <- `ncbiId`
      }
      if (!is.null(`isGenesUsable`)) {
        stopifnot(is.logical(`isGenesUsable`), length(`isGenesUsable`) == 1)
        self$`isGenesUsable` <- `isGenesUsable`
      }
      if (!is.null(`secondaryNcbiId`)) {
        stopifnot(is.numeric(`secondaryNcbiId`), length(`secondaryNcbiId`) == 1)
        self$`secondaryNcbiId` <- `secondaryNcbiId`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`externalDatabase`)) {
        stopifnot(R6::is.R6(`externalDatabase`))
        self$`externalDatabase` <- `externalDatabase`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Taxon in JSON format
    #' @keywords internal
    toJSON = function() {
      TaxonObject <- list()
      if (!is.null(self$`scientificName`)) {
        TaxonObject[["scientificName"]] <-
          self$`scientificName`
      }
      if (!is.null(self$`commonName`)) {
        TaxonObject[["commonName"]] <-
          self$`commonName`
      }
      if (!is.null(self$`ncbiId`)) {
        TaxonObject[["ncbiId"]] <-
          self$`ncbiId`
      }
      if (!is.null(self$`isGenesUsable`)) {
        TaxonObject[["isGenesUsable"]] <-
          self$`isGenesUsable`
      }
      if (!is.null(self$`secondaryNcbiId`)) {
        TaxonObject[["secondaryNcbiId"]] <-
          self$`secondaryNcbiId`
      }
      if (!is.null(self$`id`)) {
        TaxonObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`externalDatabase`)) {
        TaxonObject[["externalDatabase"]] <-
          self$`externalDatabase`$toJSON()
      }
      TaxonObject
    },
    #' Deserialize JSON string into an instance of Taxon
    #'
    #' @description
    #' Deserialize JSON string into an instance of Taxon
    #'
    #' @param input_json the JSON input
    #' @return the instance of Taxon
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`scientificName`)) {
        self$`scientificName` <- this_object$`scientificName`
      }
      if (!is.null(this_object$`commonName`)) {
        self$`commonName` <- this_object$`commonName`
      }
      if (!is.null(this_object$`ncbiId`)) {
        self$`ncbiId` <- this_object$`ncbiId`
      }
      if (!is.null(this_object$`isGenesUsable`)) {
        self$`isGenesUsable` <- this_object$`isGenesUsable`
      }
      if (!is.null(this_object$`secondaryNcbiId`)) {
        self$`secondaryNcbiId` <- this_object$`secondaryNcbiId`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`externalDatabase`)) {
        externaldatabase_object <- ExternalDatabase$new()
        externaldatabase_object$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
        self$`externalDatabase` <- externaldatabase_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return Taxon in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`scientificName`)) {
          sprintf(
          '"scientificName":
            "%s"
                    ',
          self$`scientificName`
          )
        },
        if (!is.null(self$`commonName`)) {
          sprintf(
          '"commonName":
            "%s"
                    ',
          self$`commonName`
          )
        },
        if (!is.null(self$`ncbiId`)) {
          sprintf(
          '"ncbiId":
            %d
                    ',
          self$`ncbiId`
          )
        },
        if (!is.null(self$`isGenesUsable`)) {
          sprintf(
          '"isGenesUsable":
            %s
                    ',
          tolower(self$`isGenesUsable`)
          )
        },
        if (!is.null(self$`secondaryNcbiId`)) {
          sprintf(
          '"secondaryNcbiId":
            %d
                    ',
          self$`secondaryNcbiId`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`externalDatabase`)) {
          sprintf(
          '"externalDatabase":
          %s
          ',
          jsonlite::toJSON(self$`externalDatabase`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of Taxon
    #'
    #' @description
    #' Deserialize JSON string into an instance of Taxon
    #'
    #' @param input_json the JSON input
    #' @return the instance of Taxon
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`scientificName` <- this_object$`scientificName`
      self$`commonName` <- this_object$`commonName`
      self$`ncbiId` <- this_object$`ncbiId`
      self$`isGenesUsable` <- this_object$`isGenesUsable`
      self$`secondaryNcbiId` <- this_object$`secondaryNcbiId`
      self$`id` <- this_object$`id`
      self$`externalDatabase` <- ExternalDatabase$new()$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to Taxon
    #'
    #' @description
    #' Validate JSON input with respect to Taxon and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Taxon
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
Taxon$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
Taxon$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
Taxon$lock()


#' @docType class
#' @title TaxonArg
#'
#' @description TaxonArg Class
#'
#' @format An \code{R6Class} generator object
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
TaxonArg <- R6::R6Class(
  "TaxonArg",
  public = list(
    #' @field actual_instance the object stored in this instance.
    actual_instance = NULL,
    #' @field actual_type the type of the object stored in this instance.
    actual_type = NULL,
    #' @field one_of  a list of types defined in the oneOf schema.
    one_of = list("character", "integer"),
    #' Initialize a new TaxonArg.
    #'
    #' @description
    #' Initialize a new TaxonArg.
    #'
    #' @param instance an instance of the object defined in the oneOf schemas: "character", "integer"
    #' @keywords internal
    initialize = function(instance = NULL) {
      if (is.null(instance)) {
        # do nothing
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "character") {
        self$actual_instance <- instance
        self$actual_type <- "character"
      } else if (get(class(instance)[[1]], pos = -1)$classname ==  "integer") {
        self$actual_instance <- instance
        self$actual_type <- "integer"
      } else {
        stop(paste("Failed to initialize TaxonArg with oneOf schemas character, integer. Provided class name: ",
                   get(class(instance)[[1]], pos = -1)$classname))
      }
    },
    #' Deserialize JSON string into an instance of TaxonArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of TaxonArg.
    #' An alias to the method `fromJSON` .
    #'
    #' @param input The input JSON.
    #' @return An instance of TaxonArg.
    #' @keywords internal
    fromJSONString = function(input) {
      self$fromJSON(input)
    },
    #' Deserialize JSON string into an instance of TaxonArg.
    #'
    #' @description
    #' Deserialize JSON string into an instance of TaxonArg.
    #'
    #' @param input The input JSON.
    #' @return An instance of TaxonArg.
    #' @keywords internal
    fromJSON = function(input) {
      matched <- 0 # match counter
      matched_schemas <- list() #names of matched schemas
      error_messages <- list()
      instance <- NULL

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      integer_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "integer") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "integer", typeof(instance)))
          }
          instance_type <- "integer"
          matched_schemas <- append(matched_schemas, "integer")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(integer_result["error"])) {
        error_messages <- append(error_messages, integer_result["message"])
      }

      character_result <- tryCatch({
          instance <- jsonlite::fromJSON(input, simplifyVector = FALSE)
          if (typeof(instance) != "character") {
            stop(sprintf("Data type doesn't match. Expected: %s. Actual: %s.", "character", typeof(instance)))
          }
          instance_type <- "character"
          matched_schemas <- append(matched_schemas, "character")
          matched <- matched + 1
        },
        error = function(err) err
      )

      if (!is.null(character_result["error"])) {
        error_messages <- append(error_messages, character_result["message"])
      }

      if (matched == 1) {
        # successfully match exactly 1 schema specified in oneOf
        self$actual_instance <- instance
        self$actual_type <- instance_type
      } else if (matched > 1) {
        # more than 1 match
        stop("Multiple matches found when deserializing the payload into TaxonArg with oneOf schemas character, integer.")
      } else {
        # no match
        stop(paste("No match found when deserializing the payload into TaxonArg with oneOf schemas character, integer. Details: ",
                   paste(error_messages, collapse = ", ")))
      }

      self
    },
    #' Serialize TaxonArg to JSON string.
    #'
    #' @description
    #' Serialize TaxonArg to JSON string.
    #'
    #' @return JSON string representation of the TaxonArg.
    #' @keywords internal
    toJSONString = function() {
      if (!is.null(self$actual_instance)) {
        as.character(jsonlite::minify(self$actual_instance$toJSONString()))
      } else {
        NULL
      }
    },
    #' Serialize TaxonArg to JSON.
    #'
    #' @description
    #' Serialize TaxonArg to JSON.
    #'
    #' @return JSON representation of the TaxonArg.
    #' @keywords internal
    toJSON = function() {
      if (!is.null(self$actual_instance)) {
        self$actual_instance$toJSON()
      } else {
        NULL
      }
    },
    #' Validate the input JSON with respect to TaxonArg.
    #'
    #' @description
    #' Validate the input JSON with respect to TaxonArg and
    #' throw exception if invalid.
    #'
    #' @param input The input JSON.
    #' @keywords internal
    validateJSON = function(input) {
      # backup current values
      actual_instance_bak <- self$actual_instance
      actual_type_bak <- self$actual_type

      # if it's not valid, an error will be thrown
      self$fromJSON(input)

      # no error thrown, restore old values
      self$actual_instance <- actual_instance_bak
      self$actual_type <- actual_type_bak
    },
    #' Returns the string representation of the instance.
    #'
    #' @description
    #' Returns the string representation of the instance.
    #'
    #' @return The string representation of the instance.
    #' @keywords internal
    toString = function() {
      jsoncontent <- c(
        sprintf('"actual_instance": %s', if (is.null(self$actual_instance)) NULL else self$actual_instance$toJSONString()),
        sprintf('"actual_type": "%s"', self$actual_type),
        sprintf('"one_of": "%s"', paste(unlist(self$one_of), collapse = ", "))
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      as.character(jsonlite::prettify(paste("{", jsoncontent, "}", sep = "")))
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
TaxonArg$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
TaxonArg$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
TaxonArg$lock()


#' Create a new TaxonValueObject
#'
#' @description
#' TaxonValueObject Class
#'
#' @docType class
#' @title TaxonValueObject
#' @description TaxonValueObject Class
#' @format An \code{R6Class} generator object
#' @field id  integer optional
#' @field scientificName  character optional
#' @field commonName  character optional
#' @field ncbiId  integer optional
#' @field isSpecies  character optional
#' @field isGenesUsable  character optional
#' @field externalDatabase  \link{ExternalDatabaseValueObject} optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
TaxonValueObject <- R6::R6Class(
  "TaxonValueObject",
  public = list(
    `id` = NULL,
    `scientificName` = NULL,
    `commonName` = NULL,
    `ncbiId` = NULL,
    `isSpecies` = NULL,
    `isGenesUsable` = NULL,
    `externalDatabase` = NULL,
    #' Initialize a new TaxonValueObject class.
    #'
    #' @description
    #' Initialize a new TaxonValueObject class.
    #'
    #' @param id id
    #' @param scientificName scientificName
    #' @param commonName commonName
    #' @param ncbiId ncbiId
    #' @param isSpecies isSpecies
    #' @param isGenesUsable isGenesUsable
    #' @param externalDatabase externalDatabase
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `id` = NULL, `scientificName` = NULL, `commonName` = NULL, `ncbiId` = NULL, `isSpecies` = NULL, `isGenesUsable` = NULL, `externalDatabase` = NULL, ...
    ) {
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`scientificName`)) {
        stopifnot(is.character(`scientificName`), length(`scientificName`) == 1)
        self$`scientificName` <- `scientificName`
      }
      if (!is.null(`commonName`)) {
        stopifnot(is.character(`commonName`), length(`commonName`) == 1)
        self$`commonName` <- `commonName`
      }
      if (!is.null(`ncbiId`)) {
        stopifnot(is.numeric(`ncbiId`), length(`ncbiId`) == 1)
        self$`ncbiId` <- `ncbiId`
      }
      if (!is.null(`isSpecies`)) {
        stopifnot(is.logical(`isSpecies`), length(`isSpecies`) == 1)
        self$`isSpecies` <- `isSpecies`
      }
      if (!is.null(`isGenesUsable`)) {
        stopifnot(is.logical(`isGenesUsable`), length(`isGenesUsable`) == 1)
        self$`isGenesUsable` <- `isGenesUsable`
      }
      if (!is.null(`externalDatabase`)) {
        stopifnot(R6::is.R6(`externalDatabase`))
        self$`externalDatabase` <- `externalDatabase`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return TaxonValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      TaxonValueObjectObject <- list()
      if (!is.null(self$`id`)) {
        TaxonValueObjectObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`scientificName`)) {
        TaxonValueObjectObject[["scientificName"]] <-
          self$`scientificName`
      }
      if (!is.null(self$`commonName`)) {
        TaxonValueObjectObject[["commonName"]] <-
          self$`commonName`
      }
      if (!is.null(self$`ncbiId`)) {
        TaxonValueObjectObject[["ncbiId"]] <-
          self$`ncbiId`
      }
      if (!is.null(self$`isSpecies`)) {
        TaxonValueObjectObject[["isSpecies"]] <-
          self$`isSpecies`
      }
      if (!is.null(self$`isGenesUsable`)) {
        TaxonValueObjectObject[["isGenesUsable"]] <-
          self$`isGenesUsable`
      }
      if (!is.null(self$`externalDatabase`)) {
        TaxonValueObjectObject[["externalDatabase"]] <-
          self$`externalDatabase`$toJSON()
      }
      TaxonValueObjectObject
    },
    #' Deserialize JSON string into an instance of TaxonValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of TaxonValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of TaxonValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`scientificName`)) {
        self$`scientificName` <- this_object$`scientificName`
      }
      if (!is.null(this_object$`commonName`)) {
        self$`commonName` <- this_object$`commonName`
      }
      if (!is.null(this_object$`ncbiId`)) {
        self$`ncbiId` <- this_object$`ncbiId`
      }
      if (!is.null(this_object$`isSpecies`)) {
        self$`isSpecies` <- this_object$`isSpecies`
      }
      if (!is.null(this_object$`isGenesUsable`)) {
        self$`isGenesUsable` <- this_object$`isGenesUsable`
      }
      if (!is.null(this_object$`externalDatabase`)) {
        externaldatabase_object <- ExternalDatabaseValueObject$new()
        externaldatabase_object$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
        self$`externalDatabase` <- externaldatabase_object
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return TaxonValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`scientificName`)) {
          sprintf(
          '"scientificName":
            "%s"
                    ',
          self$`scientificName`
          )
        },
        if (!is.null(self$`commonName`)) {
          sprintf(
          '"commonName":
            "%s"
                    ',
          self$`commonName`
          )
        },
        if (!is.null(self$`ncbiId`)) {
          sprintf(
          '"ncbiId":
            %d
                    ',
          self$`ncbiId`
          )
        },
        if (!is.null(self$`isSpecies`)) {
          sprintf(
          '"isSpecies":
            %s
                    ',
          tolower(self$`isSpecies`)
          )
        },
        if (!is.null(self$`isGenesUsable`)) {
          sprintf(
          '"isGenesUsable":
            %s
                    ',
          tolower(self$`isGenesUsable`)
          )
        },
        if (!is.null(self$`externalDatabase`)) {
          sprintf(
          '"externalDatabase":
          %s
          ',
          jsonlite::toJSON(self$`externalDatabase`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of TaxonValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of TaxonValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of TaxonValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`scientificName` <- this_object$`scientificName`
      self$`commonName` <- this_object$`commonName`
      self$`ncbiId` <- this_object$`ncbiId`
      self$`isSpecies` <- this_object$`isSpecies`
      self$`isGenesUsable` <- this_object$`isGenesUsable`
      self$`externalDatabase` <- ExternalDatabaseValueObject$new()$fromJSON(jsonlite::toJSON(this_object$externalDatabase, auto_unbox = TRUE, digits = NA))
      self
    },
    #' Validate JSON input with respect to TaxonValueObject
    #'
    #' @description
    #' Validate JSON input with respect to TaxonValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of TaxonValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
TaxonValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
TaxonValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
TaxonValueObject$lock()


#' Create a new TechnologyType
#'
#' @description
#' TechnologyType Class
#'
#' @docType class
#' @title TechnologyType
#' @description TechnologyType Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
TechnologyType <- R6::R6Class(
  "TechnologyType",
  public = list(
    `value` = NULL,
    #' Initialize a new TechnologyType class.
    #'
    #' @description
    #' Initialize a new TechnologyType class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return TechnologyType in JSON format
    #' @keywords internal
    toJSON = function() {
      TechnologyTypeObject <- list()
      if (!is.null(self$`value`)) {
        TechnologyTypeObject[["value"]] <-
          self$`value`
      }
      TechnologyTypeObject
    },
    #' Deserialize JSON string into an instance of TechnologyType
    #'
    #' @description
    #' Deserialize JSON string into an instance of TechnologyType
    #'
    #' @param input_json the JSON input
    #' @return the instance of TechnologyType
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return TechnologyType in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of TechnologyType
    #'
    #' @description
    #' Deserialize JSON string into an instance of TechnologyType
    #'
    #' @param input_json the JSON input
    #' @return the instance of TechnologyType
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to TechnologyType
    #'
    #' @description
    #' Validate JSON input with respect to TechnologyType and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of TechnologyType
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
TechnologyType$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
TechnologyType$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
TechnologyType$lock()


#' Create a new ThreePrimeDistanceMethod
#'
#' @description
#' ThreePrimeDistanceMethod Class
#'
#' @docType class
#' @title ThreePrimeDistanceMethod
#' @description ThreePrimeDistanceMethod Class
#' @format An \code{R6Class} generator object
#' @field value  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
ThreePrimeDistanceMethod <- R6::R6Class(
  "ThreePrimeDistanceMethod",
  public = list(
    `value` = NULL,
    #' Initialize a new ThreePrimeDistanceMethod class.
    #'
    #' @description
    #' Initialize a new ThreePrimeDistanceMethod class.
    #'
    #' @param value value
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `value` = NULL, ...
    ) {
      if (!is.null(`value`)) {
        stopifnot(is.character(`value`), length(`value`) == 1)
        self$`value` <- `value`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ThreePrimeDistanceMethod in JSON format
    #' @keywords internal
    toJSON = function() {
      ThreePrimeDistanceMethodObject <- list()
      if (!is.null(self$`value`)) {
        ThreePrimeDistanceMethodObject[["value"]] <-
          self$`value`
      }
      ThreePrimeDistanceMethodObject
    },
    #' Deserialize JSON string into an instance of ThreePrimeDistanceMethod
    #'
    #' @description
    #' Deserialize JSON string into an instance of ThreePrimeDistanceMethod
    #'
    #' @param input_json the JSON input
    #' @return the instance of ThreePrimeDistanceMethod
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return ThreePrimeDistanceMethod in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`value`)) {
          sprintf(
          '"value":
            "%s"
                    ',
          self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of ThreePrimeDistanceMethod
    #'
    #' @description
    #' Deserialize JSON string into an instance of ThreePrimeDistanceMethod
    #'
    #' @param input_json the JSON input
    #' @return the instance of ThreePrimeDistanceMethod
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`value` <- this_object$`value`
      self
    },
    #' Validate JSON input with respect to ThreePrimeDistanceMethod
    #'
    #' @description
    #' Validate JSON input with respect to ThreePrimeDistanceMethod and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ThreePrimeDistanceMethod
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
ThreePrimeDistanceMethod$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
ThreePrimeDistanceMethod$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
ThreePrimeDistanceMethod$lock()


#' Create a new User
#'
#' @description
#' User Class
#'
#' @docType class
#' @title User
#' @description User Class
#' @format An \code{R6Class} generator object
#' @field name  character optional
#' @field description  character optional
#' @field id  integer optional
#' @field email  character optional
#' @field lastName  character optional
#' @field userName  character optional
#' @field password  character optional
#' @field passwordHint  character optional
#' @field enabled  character optional
#' @field signupToken  character optional
#' @field signupTokenDatestamp  character optional
#' @field jobs  list(\link{JobInfo}) optional
#' @field fullName  character optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
User <- R6::R6Class(
  "User",
  public = list(
    `name` = NULL,
    `description` = NULL,
    `id` = NULL,
    `email` = NULL,
    `lastName` = NULL,
    `userName` = NULL,
    `password` = NULL,
    `passwordHint` = NULL,
    `enabled` = NULL,
    `signupToken` = NULL,
    `signupTokenDatestamp` = NULL,
    `jobs` = NULL,
    `fullName` = NULL,
    #' Initialize a new User class.
    #'
    #' @description
    #' Initialize a new User class.
    #'
    #' @param name name
    #' @param description description
    #' @param id id
    #' @param email email
    #' @param lastName lastName
    #' @param userName userName
    #' @param password password
    #' @param passwordHint passwordHint
    #' @param enabled enabled
    #' @param signupToken signupToken
    #' @param signupTokenDatestamp signupTokenDatestamp
    #' @param jobs jobs
    #' @param fullName fullName
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `name` = NULL, `description` = NULL, `id` = NULL, `email` = NULL, `lastName` = NULL, `userName` = NULL, `password` = NULL, `passwordHint` = NULL, `enabled` = NULL, `signupToken` = NULL, `signupTokenDatestamp` = NULL, `jobs` = NULL, `fullName` = NULL, ...
    ) {
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
        self$`id` <- `id`
      }
      if (!is.null(`email`)) {
        stopifnot(is.character(`email`), length(`email`) == 1)
        self$`email` <- `email`
      }
      if (!is.null(`lastName`)) {
        stopifnot(is.character(`lastName`), length(`lastName`) == 1)
        self$`lastName` <- `lastName`
      }
      if (!is.null(`userName`)) {
        stopifnot(is.character(`userName`), length(`userName`) == 1)
        self$`userName` <- `userName`
      }
      if (!is.null(`password`)) {
        stopifnot(is.character(`password`), length(`password`) == 1)
        self$`password` <- `password`
      }
      if (!is.null(`passwordHint`)) {
        stopifnot(is.character(`passwordHint`), length(`passwordHint`) == 1)
        self$`passwordHint` <- `passwordHint`
      }
      if (!is.null(`enabled`)) {
        stopifnot(is.logical(`enabled`), length(`enabled`) == 1)
        self$`enabled` <- `enabled`
      }
      if (!is.null(`signupToken`)) {
        stopifnot(is.character(`signupToken`), length(`signupToken`) == 1)
        self$`signupToken` <- `signupToken`
      }
      if (!is.null(`signupTokenDatestamp`)) {
        stopifnot(is.character(`signupTokenDatestamp`), length(`signupTokenDatestamp`) == 1)
        self$`signupTokenDatestamp` <- `signupTokenDatestamp`
      }
      if (!is.null(`jobs`)) {
        stopifnot(is.vector(`jobs`), length(`jobs`) != 0)
        sapply(`jobs`, function(x) stopifnot(R6::is.R6(x)))
        self$`jobs` <- `jobs`
      }
      if (!is.null(`fullName`)) {
        stopifnot(is.character(`fullName`), length(`fullName`) == 1)
        self$`fullName` <- `fullName`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return User in JSON format
    #' @keywords internal
    toJSON = function() {
      UserObject <- list()
      if (!is.null(self$`name`)) {
        UserObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        UserObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`id`)) {
        UserObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`email`)) {
        UserObject[["email"]] <-
          self$`email`
      }
      if (!is.null(self$`lastName`)) {
        UserObject[["lastName"]] <-
          self$`lastName`
      }
      if (!is.null(self$`userName`)) {
        UserObject[["userName"]] <-
          self$`userName`
      }
      if (!is.null(self$`password`)) {
        UserObject[["password"]] <-
          self$`password`
      }
      if (!is.null(self$`passwordHint`)) {
        UserObject[["passwordHint"]] <-
          self$`passwordHint`
      }
      if (!is.null(self$`enabled`)) {
        UserObject[["enabled"]] <-
          self$`enabled`
      }
      if (!is.null(self$`signupToken`)) {
        UserObject[["signupToken"]] <-
          self$`signupToken`
      }
      if (!is.null(self$`signupTokenDatestamp`)) {
        UserObject[["signupTokenDatestamp"]] <-
          self$`signupTokenDatestamp`
      }
      if (!is.null(self$`jobs`)) {
        UserObject[["jobs"]] <-
          lapply(self$`jobs`, function(x) x$toJSON())
      }
      if (!is.null(self$`fullName`)) {
        UserObject[["fullName"]] <-
          self$`fullName`
      }
      UserObject
    },
    #' Deserialize JSON string into an instance of User
    #'
    #' @description
    #' Deserialize JSON string into an instance of User
    #'
    #' @param input_json the JSON input
    #' @return the instance of User
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`email`)) {
        self$`email` <- this_object$`email`
      }
      if (!is.null(this_object$`lastName`)) {
        self$`lastName` <- this_object$`lastName`
      }
      if (!is.null(this_object$`userName`)) {
        self$`userName` <- this_object$`userName`
      }
      if (!is.null(this_object$`password`)) {
        self$`password` <- this_object$`password`
      }
      if (!is.null(this_object$`passwordHint`)) {
        self$`passwordHint` <- this_object$`passwordHint`
      }
      if (!is.null(this_object$`enabled`)) {
        self$`enabled` <- this_object$`enabled`
      }
      if (!is.null(this_object$`signupToken`)) {
        self$`signupToken` <- this_object$`signupToken`
      }
      if (!is.null(this_object$`signupTokenDatestamp`)) {
        self$`signupTokenDatestamp` <- this_object$`signupTokenDatestamp`
      }
      if (!is.null(this_object$`jobs`)) {
        self$`jobs` <- ApiClient$new()$deserializeObj(this_object$`jobs`, "set[JobInfo]", loadNamespace("gemma.R"))
      }
      if (!is.null(this_object$`fullName`)) {
        self$`fullName` <- this_object$`fullName`
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return User in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
          sprintf(
          '"name":
            "%s"
                    ',
          self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
          '"description":
            "%s"
                    ',
          self$`description`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
          '"id":
            %d
                    ',
          self$`id`
          )
        },
        if (!is.null(self$`email`)) {
          sprintf(
          '"email":
            "%s"
                    ',
          self$`email`
          )
        },
        if (!is.null(self$`lastName`)) {
          sprintf(
          '"lastName":
            "%s"
                    ',
          self$`lastName`
          )
        },
        if (!is.null(self$`userName`)) {
          sprintf(
          '"userName":
            "%s"
                    ',
          self$`userName`
          )
        },
        if (!is.null(self$`password`)) {
          sprintf(
          '"password":
            "%s"
                    ',
          self$`password`
          )
        },
        if (!is.null(self$`passwordHint`)) {
          sprintf(
          '"passwordHint":
            "%s"
                    ',
          self$`passwordHint`
          )
        },
        if (!is.null(self$`enabled`)) {
          sprintf(
          '"enabled":
            %s
                    ',
          tolower(self$`enabled`)
          )
        },
        if (!is.null(self$`signupToken`)) {
          sprintf(
          '"signupToken":
            "%s"
                    ',
          self$`signupToken`
          )
        },
        if (!is.null(self$`signupTokenDatestamp`)) {
          sprintf(
          '"signupTokenDatestamp":
            "%s"
                    ',
          self$`signupTokenDatestamp`
          )
        },
        if (!is.null(self$`jobs`)) {
          sprintf(
          '"jobs":
          [%s]
',
          paste(sapply(self$`jobs`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`fullName`)) {
          sprintf(
          '"fullName":
            "%s"
                    ',
          self$`fullName`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of User
    #'
    #' @description
    #' Deserialize JSON string into an instance of User
    #'
    #' @param input_json the JSON input
    #' @return the instance of User
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`id` <- this_object$`id`
      self$`email` <- this_object$`email`
      self$`lastName` <- this_object$`lastName`
      self$`userName` <- this_object$`userName`
      self$`password` <- this_object$`password`
      self$`passwordHint` <- this_object$`passwordHint`
      self$`enabled` <- this_object$`enabled`
      self$`signupToken` <- this_object$`signupToken`
      self$`signupTokenDatestamp` <- this_object$`signupTokenDatestamp`
      self$`jobs` <- ApiClient$new()$deserializeObj(this_object$`jobs`, "set[JobInfo]", loadNamespace("gemma.R"))
      self$`fullName` <- this_object$`fullName`
      self
    },
    #' Validate JSON input with respect to User
    #'
    #' @description
    #' Validate JSON input with respect to User and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of User
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {

      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()

      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
User$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
User$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
User$lock()


#' Create a new VectorElementValueObject
#'
#' @description
#' VectorElementValueObject Class
#'
#' @docType class
#' @title VectorElementValueObject
#' @description VectorElementValueObject Class
#' @format An \code{R6Class} generator object
#' @field designElementName  character optional
#' @field bioAssayExpressionLevels  named list(numeric) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
VectorElementValueObject <- R6::R6Class(
  "VectorElementValueObject",
  public = list(
    `designElementName` = NULL,
    `bioAssayExpressionLevels` = NULL,
    #' Initialize a new VectorElementValueObject class.
    #'
    #' @description
    #' Initialize a new VectorElementValueObject class.
    #'
    #' @param designElementName designElementName
    #' @param bioAssayExpressionLevels bioAssayExpressionLevels
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `designElementName` = NULL, `bioAssayExpressionLevels` = NULL, ...
    ) {
      if (!is.null(`designElementName`)) {
        stopifnot(is.character(`designElementName`), length(`designElementName`) == 1)
        self$`designElementName` <- `designElementName`
      }
      if (!is.null(`bioAssayExpressionLevels`)) {
        stopifnot(is.vector(`bioAssayExpressionLevels`), length(`bioAssayExpressionLevels`) != 0)
        sapply(`bioAssayExpressionLevels`, function(x) stopifnot(is.character(x)))
        self$`bioAssayExpressionLevels` <- `bioAssayExpressionLevels`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return VectorElementValueObject in JSON format
    #' @keywords internal
    toJSON = function() {
      VectorElementValueObjectObject <- list()
      if (!is.null(self$`designElementName`)) {
        VectorElementValueObjectObject[["designElementName"]] <-
          self$`designElementName`
      }
      if (!is.null(self$`bioAssayExpressionLevels`)) {
        VectorElementValueObjectObject[["bioAssayExpressionLevels"]] <-
          self$`bioAssayExpressionLevels`
      }
      VectorElementValueObjectObject
    },
    #' Deserialize JSON string into an instance of VectorElementValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of VectorElementValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of VectorElementValueObject
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`designElementName`)) {
        self$`designElementName` <- this_object$`designElementName`
      }
      if (!is.null(this_object$`bioAssayExpressionLevels`)) {
        self$`bioAssayExpressionLevels` <- ApiClient$new()$deserializeObj(this_object$`bioAssayExpressionLevels`, "map(numeric)", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return VectorElementValueObject in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`designElementName`)) {
          sprintf(
          '"designElementName":
            "%s"
                    ',
          self$`designElementName`
          )
        },
        if (!is.null(self$`bioAssayExpressionLevels`)) {
          sprintf(
          '"bioAssayExpressionLevels":
            "%s"
          ',
          jsonlite::toJSON(lapply(self$`bioAssayExpressionLevels`, function(x){ x }), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of VectorElementValueObject
    #'
    #' @description
    #' Deserialize JSON string into an instance of VectorElementValueObject
    #'
    #' @param input_json the JSON input
    #' @return the instance of VectorElementValueObject
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`designElementName` <- this_object$`designElementName`
      self$`bioAssayExpressionLevels` <- ApiClient$new()$deserializeObj(this_object$`bioAssayExpressionLevels`, "map(numeric)", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to VectorElementValueObject
    #'
    #' @description
    #' Validate JSON input with respect to VectorElementValueObject and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of VectorElementValueObject
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
VectorElementValueObject$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
VectorElementValueObject$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
VectorElementValueObject$lock()


#' Create a new WellComposedErrorBody
#'
#' @description
#' WellComposedErrorBody Class
#'
#' @docType class
#' @title WellComposedErrorBody
#' @description WellComposedErrorBody Class
#' @format An \code{R6Class} generator object
#' @field code  integer optional
#' @field message  character optional
#' @field errors  named list(character) optional
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
WellComposedErrorBody <- R6::R6Class(
  "WellComposedErrorBody",
  public = list(
    `code` = NULL,
    `message` = NULL,
    `errors` = NULL,
    #' Initialize a new WellComposedErrorBody class.
    #'
    #' @description
    #' Initialize a new WellComposedErrorBody class.
    #'
    #' @param code code
    #' @param message message
    #' @param errors errors
    #' @param ... Other optional arguments.
    #' @keywords internal
    initialize = function(
        `code` = NULL, `message` = NULL, `errors` = NULL, ...
    ) {
      if (!is.null(`code`)) {
        stopifnot(is.numeric(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`message`)) {
        stopifnot(is.character(`message`), length(`message`) == 1)
        self$`message` <- `message`
      }
      if (!is.null(`errors`)) {
        stopifnot(is.vector(`errors`), length(`errors`) != 0)
        sapply(`errors`, function(x) stopifnot(is.character(x)))
        self$`errors` <- `errors`
      }
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return WellComposedErrorBody in JSON format
    #' @keywords internal
    toJSON = function() {
      WellComposedErrorBodyObject <- list()
      if (!is.null(self$`code`)) {
        WellComposedErrorBodyObject[["code"]] <-
          self$`code`
      }
      if (!is.null(self$`message`)) {
        WellComposedErrorBodyObject[["message"]] <-
          self$`message`
      }
      if (!is.null(self$`errors`)) {
        WellComposedErrorBodyObject[["errors"]] <-
          self$`errors`
      }
      WellComposedErrorBodyObject
    },
    #' Deserialize JSON string into an instance of WellComposedErrorBody
    #'
    #' @description
    #' Deserialize JSON string into an instance of WellComposedErrorBody
    #'
    #' @param input_json the JSON input
    #' @return the instance of WellComposedErrorBody
    #' @keywords internal
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`code`)) {
        self$`code` <- this_object$`code`
      }
      if (!is.null(this_object$`message`)) {
        self$`message` <- this_object$`message`
      }
      if (!is.null(this_object$`errors`)) {
        self$`errors` <- ApiClient$new()$deserializeObj(this_object$`errors`, "map(character)", loadNamespace("gemma.R"))
      }
      self
    },
    #' To JSON string
    #'
    #' @description
    #' To JSON String
    #'
    #' @return WellComposedErrorBody in JSON format
    #' @keywords internal
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`code`)) {
          sprintf(
          '"code":
            %d
                    ',
          self$`code`
          )
        },
        if (!is.null(self$`message`)) {
          sprintf(
          '"message":
            "%s"
                    ',
          self$`message`
          )
        },
        if (!is.null(self$`errors`)) {
          sprintf(
          '"errors":
            "%s"
          ',
          jsonlite::toJSON(lapply(self$`errors`, function(x){ x }), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    #' Deserialize JSON string into an instance of WellComposedErrorBody
    #'
    #' @description
    #' Deserialize JSON string into an instance of WellComposedErrorBody
    #'
    #' @param input_json the JSON input
    #' @return the instance of WellComposedErrorBody
    #' @keywords internal
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`code` <- this_object$`code`
      self$`message` <- this_object$`message`
      self$`errors` <- ApiClient$new()$deserializeObj(this_object$`errors`, "map(character)", loadNamespace("gemma.R"))
      self
    },
    #' Validate JSON input with respect to WellComposedErrorBody
    #'
    #' @description
    #' Validate JSON input with respect to WellComposedErrorBody and throw an exception if invalid
    #'
    #' @param input the JSON input
    #' @keywords internal
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    #' To string (JSON format)
    #'
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of WellComposedErrorBody
    #' @keywords internal
    toString = function() {
      self$toJSONString()
    },
    #' Return true if the values in all fields are valid.
    #'
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    #' @keywords internal
    isValid = function() {
      TRUE
    },
    #' Return a list of invalid fields (if any).
    #'
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    #' @keywords internal
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)

# Unlock the class to allow modifications of the method or field
WellComposedErrorBody$unlock()

#' Print the object
#'
#' @description
#' Print the object
#'
#' @keywords internal
WellComposedErrorBody$set("public", "print", function(...) {
  print(jsonlite::prettify(self$toJSONString()))
  invisible(self)
})

# Lock the class to prevent modifications to the method or field
WellComposedErrorBody$lock()


